<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMX Stream</title>
  <style>
    :root {
      --bg: #0e0e0e;
      --fg: #f0f0f0;
      --accent: #e91e63;
      --track: #1c1c1c;
      --hover: rgba(255, 255, 255, 0.1);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .navbar {
      background: var(--track);
      padding: 1rem 0;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .navbar-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      display: flex;
      align-items: center;
      color: var(--fg);
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
    }
    
    .logo span {
      margin-right: 10px;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1.5rem;
    }
    
    .btn {
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--fg);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.75rem 1.5rem;
      border-radius: 50px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      font-weight: 500;
      white-space: nowrap;
    }
    
    .btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 
        0 2px 10px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), #ff1744);
      border-color: var(--accent);
      color: white;
      box-shadow: 
        0 4px 15px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .btn-primary:hover {
      background: linear-gradient(135deg, #ff1744, var(--accent));
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(233, 30, 99, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .main-content {
      flex: 1;
      padding: 2rem 0;
    }
    
    .player-wrapper {
      background: rgba(28, 28, 28, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 25px;
      overflow: hidden;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      margin-bottom: 1.5rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .video-container {
      width: 100%;
      position: relative;
      padding-top: 56.25%; /* 16:9 aspect ratio */
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.8));
      border-radius: 25px 25px 0 0;
      overflow: hidden;
    }
    
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 25px 25px 0 0;
      box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.3);
    }
    
    .video-info {
      padding: 2rem;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .video-title {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .video-description {
      color: rgba(255,255,255,0.7);
    }
    
    .controls {
      display: flex;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 0 0 25px 25px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      gap: 1rem;
      align-items: center;
      justify-content: center;
    }
    
    #timeline {
      position: relative;
      height: 12px;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border-radius: 50px;
      cursor: pointer;
      flex: 1;
      margin: 0 1rem;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        inset 0 2px 4px rgba(0, 0, 0, 0.3),
        0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    #progress {
      height: 100%;
      background: linear-gradient(90deg, var(--accent), #ff1744);
      border-radius: 50px;
      width: 0;
      box-shadow: 
        0 0 10px rgba(233, 30, 99, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      transition: width 0.1s ease;
    }
    
    #playhead {
      position: absolute;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, #ffffff, #f0f0f0);
      border: 3px solid var(--accent);
      border-radius: 50%;
      top: -4px;
      margin-left: -10px;
      left: 0%;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.8);
      cursor: grab;
      transition: all 0.2s ease;
    }
    
    #playhead:hover {
      transform: scale(1.2);
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.4),
        0 0 15px rgba(233, 30, 99, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.9);
    }
    
    #playhead:active {
      cursor: grabbing;
      transform: scale(1.1);
    }
    
    .thumbnail-preview {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid rgba(233, 30, 99, 0.8);
      border-radius: 20px;
      padding: 12px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .thumbnail-preview img {
      width: 120px;
      height: 70px;
      border-radius: 12px;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .thumbnail-preview .time-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-family: monospace;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      background: rgba(233, 30, 99, 0.2);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--accent);
      border-right: 4px solid rgba(233, 30, 99, 0.6);
      border-radius: 50%;
      animation: spin 1s infinite linear;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    .live-badge {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      background: linear-gradient(135deg, var(--accent), #ff1744);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 25px;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 10;
      border: 2px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 6px 20px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      animation: pulse 2s infinite;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1.05);
      }
    }
    
    .select-enhanced {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .select-enhanced option {
      background: rgba(28, 28, 28, 0.95);
      color: white;
      padding: 8px;
    }
    
    /* Welcome Modal Styles */
    .welcome-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .welcome-modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .welcome-content {
      background: linear-gradient(135deg, rgba(28, 28, 28, 0.95), rgba(40, 40, 40, 0.95));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid rgba(233, 30, 99, 0.3);
      border-radius: 25px;
      padding: 2.5rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
      animation: modalSlideIn 0.4s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .welcome-title {
      font-size: 2rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, var(--accent), #ff1744);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .welcome-text {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    
    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }
    
    .welcome-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .welcome-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .welcome-close {
      background: linear-gradient(135deg, var(--accent), #ff1744);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 
        0 4px 15px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .welcome-close:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(233, 30, 99, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .welcome-close:active {
      transform: translateY(0);
    }
    
    /* Stream Type Indicator */
    .stream-type-indicator {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* WebRTC Video Styling */
    #webrtcVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 25px 25px 0 0;
      object-fit: cover;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-content">
        <a href="/" class="logo">
          <span>📡</span>SMX Stream
        </a>
        
        <div class="nav-buttons">
          <a href="dashboard.html" class="btn">Dashboard</a>
          <a href="#" class="btn">Settings</a>
        </div>
      </div>
    </div>
  </nav>
  
  <div class="main-content">
    <div class="container">
      <div class="player-wrapper">
        <div class="video-container">
          <div class="live-badge">LIVE</div>
          <video id="video" autoplay muted></video>
          <video id="webrtcVideo" autoplay playsinline style="display:none;"></video>
          <div class="loading-spinner" id="loading"></div>
          <div class="stream-type-indicator" id="streamTypeIndicator">File Stream</div>
        </div>
        
        <div class="video-info">
          <h2 class="video-title">SMX Live Training Session</h2>
          <p class="video-description">Security Mission Exercise - Live Training</p>
        </div>
        
        <div class="controls">
          <button id="rewind30" class="btn">⏪ 30s</button>
          <button id="rewind10" class="btn">⏪ 10s</button>
          <button id="playBtn" class="btn">Play</button>
          <button id="forward10" class="btn">10s ⏩</button>
          <button id="forward30" class="btn">30s ⏩</button>
          <button id="rateBtn" class="btn">1x</button>
          <button id="liveBtn" class="btn">LIVE</button>
          <div id="timeline">
            <div id="progress"></div>
            <div id="playhead"></div>
          </div>
          <button id="fullscreenBtn" class="btn">Fullscreen</button>
          <select id="streamMode" class="btn select-enhanced">
            <option value="live">Live Stream</option>
            <option value="local">Local File</option>
          </select>
        </div>
        
        <!-- Thumbnail preview -->
        <div class="thumbnail-preview" id="thumbnailPreview">
          <img id="thumbnailImg" src="" alt="Preview">
          <div class="time-label" id="thumbnailTime">0:00</div>
        </div>
        
        <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
      </div>
      
      <div style="margin-top: 2rem; text-align: center;">
        <p style="margin-bottom: 1rem; color: rgba(255,255,255,0.7);">
          To stream to this page, use OBS or other streaming software with the following settings:
        </p>
        <div style="background: var(--track); padding: 1rem; border-radius: 5px; display: inline-block; text-align: left;">
          <p><strong>Server:</strong> rtmp://127.0.0.1:1935/live</p>
          <p><strong>Stream Key:</strong> Contact administrator for your stream key</p>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-content">
      <h2 class="welcome-title">WELCOME TO SMX STREAM</h2>
      <div class="welcome-text">
        <p>SMX Stream is your live training platform for Security Mission Exercises. Watch live training sessions, access recorded content, and interact with instructors in real-time. Use the controls below to navigate through streams, adjust playback settings, and switch between live and local content.</p>
      </div>
      <div class="welcome-actions">
        <div class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          <label for="dontShowAgain">Don't show this again</label>
        </div>
        <button class="welcome-close" id="closeWelcome">Get Started</button>
      </div>
    </div>
  </div>
  
  <script>
    // Welcome Modal Functionality
    const welcomeModal = document.getElementById('welcomeModal');
    const closeWelcomeBtn = document.getElementById('closeWelcome');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    
    // Check if user has chosen not to show the welcome modal
    function shouldShowWelcome() {
      return localStorage.getItem('smx-stream-hide-welcome') !== 'true';
    }
    
    // Show welcome modal on page load
    function showWelcomeModal() {
      if (shouldShowWelcome()) {
        setTimeout(() => {
          welcomeModal.classList.add('show');
        }, 500); // Small delay for better UX
      }
    }
    
    // Close welcome modal
    function closeWelcomeModal() {
      welcomeModal.classList.remove('show');
      
      // Save preference if checkbox is checked
      if (dontShowAgainCheckbox.checked) {
        localStorage.setItem('smx-stream-hide-welcome', 'true');
      }
    }
    
    // Event listeners for welcome modal
    closeWelcomeBtn.addEventListener('click', closeWelcomeModal);
    
    // Close modal when clicking outside the content
    welcomeModal.addEventListener('click', function(e) {
      if (e.target === welcomeModal) {
        closeWelcomeModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && welcomeModal.classList.contains('show')) {
        closeWelcomeModal();
      }
    });
    
    // Show welcome modal when page loads
    window.addEventListener('load', showWelcomeModal);
    
    // Error message display function
    function showErrorMessage(title, message) {
      // Hide loading spinner
      loading.style.display = 'none';
      
      // Create error overlay
      const errorOverlay = document.createElement('div');
      errorOverlay.className = 'welcome-modal show';
      errorOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ef4444;">⚠️ ${title}</h2>
          <div class="welcome-text">
            <p>${message}</p>
            <div style="margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border-left: 4px solid #ef4444;">
              <strong>Quick Fixes:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>Make sure you're logged in to the system</li>
                <li>Access the stream through the dashboard or class page</li>
                <li>Check that the class ID in the URL is correct</li>
                <li>Contact your instructor if the problem persists</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="goToDashboard()">Go to Dashboard</button>
            <button class="welcome-close" onclick="retryConnection()" style="background: #22c55e;">Retry</button>
            <button class="welcome-close" onclick="openDebugTool()" style="background: #ff9800;">Debug Tool</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(errorOverlay);
    }
    
    function goToDashboard() {
      window.location.href = '/dashboard.html';
    }
    
    function retryConnection() {
      // Remove error overlay
      const errorOverlay = document.querySelector('.welcome-modal');
      if (errorOverlay) {
        errorOverlay.remove();
      }
      
      // Show loading and retry
      loading.style.display = 'block';
      fetchClassInfo();
    }
    
    function openDebugTool() {
      window.open('/debug-stream.html', '_blank');
    }
    
    function showWaitingMessage() {
      // Update the stream type indicator
      streamTypeIndicator.textContent = 'Waiting for Stream...';
      
      // Create a waiting overlay
      const waitingOverlay = document.createElement('div');
      waitingOverlay.className = 'welcome-modal show';
      waitingOverlay.id = 'waitingOverlay';
      waitingOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ff9800;">⏳ Waiting for Stream</h2>
          <div class="welcome-text">
            <p>The instructor hasn't started streaming yet. The page will automatically update when the stream becomes available.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 152, 0, 0.1); border-radius: 10px; border-left: 4px solid #ff9800;">
              <strong>What's happening:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>✅ Connected to class successfully</li>
                <li>⏳ Waiting for instructor to start streaming</li>
                <li>🔄 Automatically checking for updates every 3 seconds</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closeWaitingMessage()">Continue Waiting</button>
            <button class="welcome-close" onclick="goToDashboard()" style="background: #6b7280;">Back to Dashboard</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(waitingOverlay);
    }
    
    function closeWaitingMessage() {
      const waitingOverlay = document.getElementById('waitingOverlay');
      if (waitingOverlay) {
        waitingOverlay.remove();
      }
    }
    
    const video = document.getElementById('video');
    const webrtcVideo = document.getElementById('webrtcVideo');
    const streamTypeIndicator = document.getElementById('streamTypeIndicator');
    const playBtn = document.getElementById('playBtn');
    const timeline = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    
    // WebRTC Variables
    let peerConnection = null;
    let webrtcSocket = null;
    let isWebRTCMode = false;
    let classId = null;
    const playhead = document.getElementById('playhead');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const loading = document.getElementById('loading');
    const rateBtn = document.getElementById('rateBtn');
    const liveBtn = document.getElementById('liveBtn');
    const streamMode = document.getElementById('streamMode');
    const fileInput = document.getElementById('fileInput');
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImg = document.getElementById('thumbnailImg');
    const thumbnailTime = document.getElementById('thumbnailTime');
    
    // Skip buttons
    document.getElementById('rewind10').onclick = () => video.currentTime -= 10;
    document.getElementById('rewind30').onclick = () => video.currentTime -= 30;
    document.getElementById('forward10').onclick = () => video.currentTime += 10;
    document.getElementById('forward30').onclick = () => video.currentTime += 30;
    
    let hlsInstance = null;
    
    // Thumbnail generation functionality
    let thumbnailCache = [];
    
    function generateThumbnails() {
      const offscreen = document.createElement('canvas');
      offscreen.width = 120;
      offscreen.height = 70;
      const offCtx = offscreen.getContext('2d');

      let current = 0;
      const end = Math.floor(video.duration);

      function snapNext() {
        if (current > end) return;

        video.currentTime = current;
        video.addEventListener('seeked', function capture() {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
          const img = new Image();
          img.src = offscreen.toDataURL();
          thumbnailCache.push({ time: current, img });

          current++;
          video.removeEventListener('seeked', capture);
          setTimeout(snapNext, 200); // short delay ensures rendering stability
        }, { once: true });
      }

      snapNext();
    }
    
    // Function to get thumbnail for a specific time
    function getThumbnailForTime(time) {
      if (thumbnailCache.length === 0) return null;
      
      // Find the closest thumbnail
      let closest = thumbnailCache[0];
      let minDiff = Math.abs(closest.time - time);
      
      for (let i = 1; i < thumbnailCache.length; i++) {
        const diff = Math.abs(thumbnailCache[i].time - time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = thumbnailCache[i];
        }
      }
      
      return closest;
    }
    
    // WebRTC Functions
    function initializeWebRTCSocket() {
      if (webrtcSocket) return;
      
      webrtcSocket = io();
      
      webrtcSocket.on('connect', () => {
        console.log('🔌 WebRTC Socket connected');
        if (classId) {
          webrtcSocket.emit('student-join-class', { classId: classId });
        }
      });
      
      webrtcSocket.on('disconnect', () => {
        console.log('❌ WebRTC Socket disconnected');
      });
      
      webrtcSocket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Instructor started WebRTC stream:', data.mediaType);
        switchToWebRTCMode();
        streamTypeIndicator.textContent = `Live ${data.mediaType}`;
      });
      
      webrtcSocket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Instructor stopped WebRTC stream');
        switchToFileMode();
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      });
      
      webrtcSocket.on('webrtc-offer', async (data) => {
        console.log('📡 Received WebRTC offer from instructor');
        await handleWebRTCOffer(data.offer);
      });
      
      webrtcSocket.on('webrtc-ice-candidate', async (data) => {
        console.log('🧊 Received ICE candidate from instructor');
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    async function handleWebRTCOffer(offer) {
      try {
        console.log('🔗 Creating WebRTC peer connection...');
        
        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });
        
        // Handle incoming stream
        peerConnection.ontrack = (event) => {
          console.log('📺 Received WebRTC stream');
          webrtcVideo.srcObject = event.streams[0];
          loading.style.display = 'none';
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            webrtcSocket.emit('webrtc-ice-candidate', {
              to: 'instructor',
              candidate: event.candidate
            });
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          console.log('🔗 WebRTC connection state:', state);
          
          if (state === 'connected') {
            console.log('✅ WebRTC connection established');
          } else if (state === 'disconnected' || state === 'failed') {
            console.log('❌ WebRTC connection lost');
            switchToFileMode();
          }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer back to instructor
        webrtcSocket.emit('webrtc-answer', {
          to: 'instructor',
          answer: answer
        });
        
        console.log('📤 Sent WebRTC answer to instructor');
      } catch (error) {
        console.error('❌ Error handling WebRTC offer:', error);
        switchToFileMode();
      }
    }
    
    function switchToWebRTCMode() {
      console.log('🔄 Switching to WebRTC mode');
      isWebRTCMode = true;
      
      video.style.display = 'none';
      webrtcVideo.style.display = 'block';
      
      // Hide file-based controls
      document.getElementById('controls').style.display = 'none';
      
      streamTypeIndicator.textContent = 'Live WebRTC Stream';
      loading.style.display = 'block';
    }
    
    function switchToFileMode() {
      console.log('🔄 Switching to file mode');
      isWebRTCMode = false;
      
      webrtcVideo.style.display = 'none';
      video.style.display = 'block';
      
      // Show file-based controls
      document.getElementById('controls').style.display = 'flex';
      
      streamTypeIndicator.textContent = 'File Stream';
      
      if (webrtcVideo.srcObject) {
        webrtcVideo.srcObject = null;
      }
    }

    // Fetch class information from the backend
    async function fetchClassInfo() {
      try {
        // Get classId from URL parameters or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
        
        if (!classId) {
          console.error('❌ No class ID provided');
          showErrorMessage('No Class ID Found', 'Please provide a class ID in the URL (?classId=xxx) or ensure you are logged in with a valid class assignment.');
          return;
        }
        
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('❌ Authentication failed');
            showErrorMessage('Authentication Required', 'You need to log in to access this stream. Please log in and try again.');
            return;
          } else if (response.status === 403) {
            console.error('❌ Access denied');
            showErrorMessage('Access Denied', 'You do not have permission to access this class stream. Please contact your instructor.');
            return;
          } else if (response.status === 404) {
            console.error('❌ Class not found');
            showErrorMessage('Class Not Found', 'The requested class could not be found. Please check the class ID and try again.');
            return;
          }
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('📊 Stream status data:', data);
        
        const streamKey = data.streamKey;
        const streamStatus = data.status;
        const currentSource = data.currentSource;

        console.log('🔑 StreamKey:', streamKey);
        console.log('📡 Status:', streamStatus);
        console.log('📹 Source:', currentSource);

        // Check if stream is active
        if (streamStatus !== 'live') {
          console.log('⏸️ Stream is not live, waiting for instructor...');
          loading.style.display = 'block';
          
          // Show waiting message after 10 seconds
          setTimeout(() => {
            if (loading.style.display === 'block') {
              showWaitingMessage();
            }
          }, 10000);
          
          // Retry after 3 seconds
          setTimeout(() => fetchClassInfo(), 3000);
          return;
        }

        // Handle different stream sources
        if (currentSource === 'upload' && data.session && data.session.uploadFilename) {
          // For uploaded videos, use direct video URL
          const videoUrl = `/api/stream/video/${data.session.uploadFilename}`;
          console.log('📹 Loading uploaded video:', videoUrl);
          console.log('📁 Upload filename:', data.session.uploadFilename);
          
          // Use direct video playback for uploaded files
          video.src = videoUrl;
          video.load();
          
          video.addEventListener('loadstart', () => console.log('🔄 Video load started'));
          video.addEventListener('loadeddata', () => console.log('✅ Video data loaded'));
          video.addEventListener('canplay', () => console.log('▶️ Video can play'));
          video.addEventListener('error', (e) => console.error('❌ Video error:', e));
          
          video.play().catch(e => console.log('🔇 Video autoplay prevented:', e));
          
        } else {
          // For live streams, use HLS
          const streamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          console.log('Loading HLS stream:', streamUrl);
          
          // Initialize HLS.js
          if (Hls.isSupported()) {
            hlsInstance = new Hls({
              enableWorker: true,
              lowLatencyMode: true,
              backBufferLength: 90
            });
            hlsInstance.loadSource(streamUrl);
            hlsInstance.attachMedia(video);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
              video.play();
            });
          
          // Generate thumbnails when video metadata is loaded
          video.addEventListener('loadedmetadata', function() {
            generateThumbnails();
          }, { once: true });

            hlsInstance.on(Hls.Events.ERROR, function(event, data) {
              console.error('HLS error:', data);
              if (data.fatal) {
                setTimeout(() => fetchClassInfo(), 5000); // Retry after 5 seconds
              }
            });
          } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = streamUrl;
            video.addEventListener('loadedmetadata', function() {
              video.play();
              generateThumbnails();
            });
          } else {
            console.error('HLS is not supported in this browser');
          }
        }
        
        video.addEventListener('canplay', function() {
          loading.style.display = 'none';
        });
        
        video.addEventListener('waiting', function() {
          loading.style.display = 'block';
        });
        
        video.addEventListener('playing', function() {
          loading.style.display = 'none';
        });
        
        // Initialize WebRTC socket for live streaming
        initializeWebRTCSocket();
        
        // Connect to Socket.IO for real-time updates
        if (streamKey && typeof io !== 'undefined') {
          const socket = io();
          console.log('🔌 Connecting to Socket.IO with streamKey:', streamKey);
          socket.emit('join-stream', streamKey);
          
          socket.on('connect', () => {
            console.log('✅ Socket.IO connected successfully');
          });
          
          socket.on('disconnect', () => {
            console.log('❌ Socket.IO disconnected');
          });
          
          socket.on('streamStatus', (data) => {
            console.log('📡 Stream status update:', data);
            if (data.status === 'offline') {
              // Stream ended
              if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
              }
              video.src = '';
              video.pause();
              loading.style.display = 'block';
            } else if (data.status === 'live') {
              // New stream started
              loading.style.display = 'none';
              
              if (data.source === 'upload' && data.streamUrl) {
                // Switch to uploaded video
                if (hlsInstance) {
                  hlsInstance.destroy();
                  hlsInstance = null;
                }
                video.src = data.streamUrl;
                video.load();
                video.play().catch(e => console.log('Video autoplay prevented:', e));
              } else {
                // Switch to live HLS stream
                const newStreamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
                if (hlsInstance) {
                  hlsInstance.loadSource(newStreamUrl);
                } else if (Hls.isSupported()) {
                  hlsInstance = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                  });
                  hlsInstance.loadSource(newStreamUrl);
                  hlsInstance.attachMedia(video);
                }
              }
            } else if (data.status === 'paused') {
              video.pause();
            }
          });
          
          socket.on('notice', (data) => {
            // Display instructor notice
            console.log('Instructor notice:', data.message);
            // You can add UI to display notices here
          });
        }
        
      } catch (error) {
        console.error('Error fetching class information:', error);
        // Retry after 5 seconds
        setTimeout(() => fetchClassInfo(), 5000);
      }
    }
    
    // Debug information on page load
    console.log('🚀 SMX Stream page loaded');
    console.log('🔍 Checking for class ID and authentication...');
    
    const urlParams = new URLSearchParams(window.location.search);
    const urlClassId = urlParams.get('classId');
    const storedClassId = localStorage.getItem('currentClassId');
    const authToken = localStorage.getItem('token');
    
    console.log('📋 URL Class ID:', urlClassId);
    console.log('💾 Stored Class ID:', storedClassId);
    console.log('🔐 Auth Token:', authToken ? 'Present' : 'Missing');
    
    if (!urlClassId && !storedClassId) {
      console.warn('⚠️ No class ID found - this will likely cause issues');
    }
    
    if (!authToken) {
      console.warn('⚠️ No authentication token found - this will likely cause issues');
    }
    
    // Call the function to fetch class info and load the stream
    fetchClassInfo();
    
    // Play/pause toggle
    playBtn.addEventListener('click', function() {
      if (video.paused) {
        video.play();
      } else {
        video.pause();
      }
      updatePlayButton();
    });
    
    function updatePlayButton() {
      playBtn.textContent = video.paused ? 'Play' : 'Pause';
    }
    
    // Timeline functionality
    video.addEventListener('timeupdate', function() {
      const percent = (video.currentTime / video.duration) * 100;
      progress.style.width = percent + '%';
      playhead.style.left = percent + '%';
    });
    
    timeline.addEventListener('click', function(e) {
      const rect = timeline.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      video.currentTime = pos * video.duration;
    });
    
    // Timeline hover for thumbnail preview
    timeline.addEventListener('mousemove', function(e) {
      if (!video.duration || thumbnailCache.length === 0) return;
      
      const rect = timeline.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      const hoverTime = pos * video.duration;
      
      const thumbnail = getThumbnailForTime(hoverTime);
      if (thumbnail) {
        thumbnailImg.src = thumbnail.img.src;
        thumbnailTime.textContent = formatTime(hoverTime);
        
        // Position the preview
        const previewX = e.clientX - rect.left;
        thumbnailPreview.style.left = previewX + 'px';
        thumbnailPreview.style.display = 'block';
      }
    });
    
    timeline.addEventListener('mouseleave', function() {
      thumbnailPreview.style.display = 'none';
    });
    
    // Helper function to format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Fullscreen
    fullscreenBtn.addEventListener('click', function() {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.msRequestFullscreen) {
        video.msRequestFullscreen();
      }
    });
    
    // ⏩ Playback rate toggle
    rateBtn.addEventListener('click', function() {
      video.playbackRate = video.playbackRate === 1 ? 2 : video.playbackRate === 2 ? 0.5 : 1;
      rateBtn.textContent = video.playbackRate + 'x';
    });
    
    // 🔄 LIVE button
    liveBtn.addEventListener('click', function() {
      if (video.duration) {
        video.currentTime = video.duration - 0.05;
      }
    });
    
    // Update live status
    setInterval(() => {
      if (video.duration) {
        const live = Math.abs(video.duration - video.currentTime) < 2;
        liveBtn.style.display = live ? 'none' : 'inline-block';
      }
    }, 500);
    
    // 📦 Stream mode selector
    streamMode.addEventListener('change', function() {
      if (streamMode.value === 'local') {
        fileInput.click();
      } else {
        fetchClassInfo();
      }
    });
    
    fileInput.addEventListener('change', function() {
      const file = fileInput.files[0];
      if (file) {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        const url = URL.createObjectURL(file);
        video.src = url;
        loading.style.display = 'block';
        
        // Generate thumbnails for local file
        video.addEventListener('loadedmetadata', function() {
          generateThumbnails();
        }, { once: true });
      }
    });
    
    // ⌨️ Keyboard shortcuts
    window.addEventListener('keydown', function(e) {
      if (e.key === 'k' || e.key === ' ') {
        e.preventDefault();
        playBtn.click();
      }
      else if (e.key === 'j') video.currentTime -= 10;
      else if (e.key === 'l') video.currentTime += 10;
      else if (e.key === 'f') fullscreenBtn.click();
      else if (e.key === 'm') video.muted = !video.muted;
      else if (e.key === 'ArrowLeft') video.currentTime -= 5;
      else if (e.key === 'ArrowRight') video.currentTime += 5;
    });
    
    // Enhanced video event listeners
    video.addEventListener('playing', function() {
      loading.style.display = 'none';
      playBtn.textContent = 'Pause';
    });
    
    video.addEventListener('pause', function() {
      playBtn.textContent = 'Play';
    });
  </script>
</body>
</html>