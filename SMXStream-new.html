<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMX Stream</title>
  <style>
    :root {
      --bg: #0e0e0e;
      --fg: #f0f0f0;
      --accent: #e91e63;
      --track: #1c1c1c;
      --hover: rgba(255, 255, 255, 0.1);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Segoe UI', sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    .navbar {
      background: var(--track);
      padding: 1rem 0;
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 1rem;
    }
    
    .navbar-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      display: flex;
      align-items: center;
      color: var(--fg);
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
    }
    
    .logo span {
      margin-right: 10px;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1.5rem;
    }
    
    .btn {
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      color: var(--fg);
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 0.75rem 1.5rem;
      border-radius: 50px;
      cursor: pointer;
      text-decoration: none;
      transition: all 0.3s ease;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      font-weight: 500;
      white-space: nowrap;
    }
    
    .btn:hover {
      background: rgba(255, 255, 255, 0.2);
      border-color: rgba(255, 255, 255, 0.4);
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .btn:active {
      transform: translateY(0);
      box-shadow: 
        0 2px 10px rgba(0, 0, 0, 0.2),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), #ff1744);
      border-color: var(--accent);
      color: white;
      box-shadow: 
        0 4px 15px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .btn-primary:hover {
      background: linear-gradient(135deg, #ff1744, var(--accent));
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(233, 30, 99, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .main-content {
      flex: 1;
      padding: 0;
    }
    
    .player-wrapper {
      background: rgba(28, 28, 28, 0.8);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 0;
      overflow: hidden;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      margin: 0;
      border: none;
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .video-container {
      width: 100%;
      position: relative;
      flex: 1;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 20, 20, 0.8));
      border-radius: 0;
      overflow: hidden;
    }

    /* Video Overlay Controls */
    .video-controls-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      backdrop-filter: blur(5px);
    }

    .video-container:hover .video-controls-overlay {
      opacity: 1;
      pointer-events: all;
    }

    .video-control-btn {
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(233, 30, 99, 0.3);
      border-radius: 50%;
      width: 60px;
      height: 60px;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(10px);
    }

    .video-control-btn:hover {
      background: rgba(233, 30, 99, 0.8);
      border-color: rgba(233, 30, 99, 0.8);
      transform: scale(1.1);
      box-shadow: 0 5px 15px rgba(233, 30, 99, 0.4);
    }

    .play-pause-btn {
      width: 80px;
      height: 80px;
      font-size: 1.5rem;
    }

    .live-btn {
      width: auto;
      padding: 0 1rem;
      border-radius: 25px;
      font-size: 0.9rem;
      font-weight: bold;
      gap: 0.5rem;
    }

    .live-btn:hover {
      background: rgba(255, 71, 87, 0.8);
      border-color: rgba(255, 71, 87, 0.8);
    }

    .zoom-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 0.5rem;
    }

    .zoom-btn {
      width: 45px;
      height: 45px;
      font-size: 1rem;
    }

    .time-display {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-family: monospace;
      font-size: 0.9rem;
      color: white;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(233, 30, 99, 0.2);
    }

    /* Hide default video controls */
    .video-container video::-webkit-media-controls {
      display: none !important;
    }

    .video-container video::-moz-media-controls {
      display: none !important;
    }

    .video-container video {
      outline: none;
    }
    
    video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.3);
      object-fit: cover;
    }
    
    .video-info {
      padding: 1rem 2rem;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    
    .video-title {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .video-description {
      color: rgba(255,255,255,0.7);
    }
    
    .controls {
      display: flex;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      gap: 1rem;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    #timeline {
      position: relative;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
      margin: 1rem 0;
      flex: none;
    }

    #timeline::-webkit-scrollbar {
      height: 8px;
    }

    #timeline::-webkit-scrollbar-track {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    #timeline::-webkit-scrollbar-thumb {
      background: linear-gradient(90deg, var(--accent), #ff1744);
      border-radius: 4px;
    }

    .timeline-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: stretch;
      min-width: 100%;
    }

    .thumbnail-frame {
      position: relative;
      height: 100%;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
    }

    .thumbnail-frame:hover {
      transform: scale(1.02);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(233, 30, 99, 0.3);
    }

    .thumbnail-frame img {
      width: 100%;
      height: calc(100% - 20px);
      object-fit: cover;
      border-radius: 4px 4px 0 0;
    }

    .time-tick {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      border-radius: 0 0 4px 4px;
    }
    
    #scrubber {
      position: absolute;
      top: 0;
      left: 0;
      width: 3px;
      height: 100%;
      background: linear-gradient(180deg, var(--accent), #ff1744);
      z-index: 100;
      cursor: grab;
      box-shadow: 0 0 10px rgba(233, 30, 99, 0.8);
      transition: left 0.1s ease;
    }

    #scrubber:active {
      cursor: grabbing;
    }

    #scrubber.dragging {
      transition: none;
    }

    #scrubber::before {
      content: '';
      position: absolute;
      top: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(233, 30, 99, 0.6);
    }

    #scrubber::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(233, 30, 99, 0.6);
    }
    
    .thumbnail-preview {
      position: absolute;
      bottom: 120px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid rgba(233, 30, 99, 0.8);
      border-radius: 20px;
      padding: 12px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 
        0 10px 30px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .thumbnail-preview img {
      width: 120px;
      height: 70px;
      border-radius: 12px;
      box-shadow: 
        0 4px 15px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    .thumbnail-preview .time-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-family: monospace;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
      background: rgba(233, 30, 99, 0.2);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--accent);
      border-right: 4px solid rgba(233, 30, 99, 0.6);
      border-radius: 50%;
      animation: spin 1s infinite linear;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 8px 25px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    .live-badge {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      background: linear-gradient(135deg, var(--accent), #ff1744);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 25px;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 10;
      border: 2px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 
        0 6px 20px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
      animation: pulse 2s infinite;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1.05);
      }
    }
    
    .select-enhanced {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .select-enhanced option {
      background: rgba(28, 28, 28, 0.95);
      color: white;
      padding: 8px;
    }
    
    /* Welcome Modal Styles */
    .welcome-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .welcome-modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .welcome-content {
      background: linear-gradient(135deg, rgba(28, 28, 28, 0.95), rgba(40, 40, 40, 0.95));
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid rgba(233, 30, 99, 0.3);
      border-radius: 25px;
      padding: 2.5rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      position: relative;
      animation: modalSlideIn 0.4s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .welcome-title {
      font-size: 2rem;
      font-weight: bold;
      color: var(--accent);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      background: linear-gradient(135deg, var(--accent), #ff1744);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .welcome-text {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    
    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }
    
    .welcome-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .welcome-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .welcome-close {
      background: linear-gradient(135deg, var(--accent), #ff1744);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 
        0 4px 15px rgba(233, 30, 99, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }
    
    .welcome-close:hover {
      transform: translateY(-2px);
      box-shadow: 
        0 8px 25px rgba(233, 30, 99, 0.6),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
    }
    
    .welcome-close:active {
      transform: translateY(0);
    }
    
    /* Stream Type Indicator */
    .stream-type-indicator {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* WebRTC Video Styling */
    #webrtcVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      object-fit: cover;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-content">
        <a href="/" class="logo">
          <span>üì°</span>SMX Stream
        </a>
        
        <div class="nav-buttons">
          <a href="dashboard.html" class="btn">Dashboard</a>
          <a href="#" class="btn">Settings</a>
        </div>
      </div>
    </div>
  </nav>
  
  <div class="main-content">
    <div class="player-wrapper">
        <div class="video-container">
          <div class="live-badge">LIVE</div>
          <video id="video" autoplay muted></video>
          <video id="webrtcVideo" autoplay playsinline muted style="display:none; width:100%; height:100%; background:#000;"></video>
          <div class="loading-spinner" id="loading"></div>
          <div class="stream-type-indicator" id="streamTypeIndicator">File Stream</div>
          <div class="webrtc-status" id="webrtcStatus" style="display:none; position:absolute; top:60px; right:20px; background:rgba(139, 92, 246, 0.9); color:white; padding:8px 12px; border-radius:6px; font-size:12px; font-weight:600;">
            üî¥ LIVE WebRTC
          </div>
          
          <!-- Video Overlay Controls (Hidden by default, show on hover) -->
          <div class="video-controls-overlay">
            <!-- Play/Pause Button -->
            <button class="video-control-btn play-pause-btn" onclick="togglePlayPause()">
              <i class="fas fa-play">‚ñ∂</i>
            </button>
            
            <!-- Rewind Button -->
            <button class="video-control-btn rewind-btn" onclick="rewindVideo()">
              <span>‚è™</span>
            </button>
            
            <!-- Fast Forward Button -->
            <button class="video-control-btn forward-btn" onclick="forwardVideo()">
              <span>‚è©</span>
            </button>
            
            <!-- Jump to Live Button (for live streams) -->
            <button class="video-control-btn live-btn" onclick="jumpToLive()">
              <span style="color: #ff4757;">‚óè</span>
              <span>LIVE</span>
            </button>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls">
              <button class="video-control-btn zoom-btn" onclick="zoomTimeline(0.5)">
                <span>üîç-</span>
              </button>
              <button class="video-control-btn zoom-btn" onclick="zoomTimeline(2)">
                <span>üîç+</span>
              </button>
            </div>
            
            <!-- Time Display -->
            <div class="time-display">
              <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
            </div>
          </div>
        </div>
        
        <div class="video-info">
          <h2 class="video-title">SMX Live Training Session</h2>
          <p class="video-description">Security Mission Exercise - Live Training</p>
        </div>
        
        <div class="controls">
          <button id="rewind30" class="btn">‚è™ 30s</button>
          <button id="rewind10" class="btn">‚è™ 10s</button>
          <button id="playBtn" class="btn">Play</button>
          <button id="forward10" class="btn">10s ‚è©</button>
          <button id="forward30" class="btn">30s ‚è©</button>
          <button id="rateBtn" class="btn">1x</button>
          <button id="liveBtn" class="btn">LIVE</button>
          <div id="timeline">
            <div id="scrubber"></div>
          </div>
          <button id="fullscreenBtn" class="btn">Fullscreen</button>
          <select id="streamMode" class="btn select-enhanced">
            <option value="live">Live Stream</option>
            <option value="local">Local File</option>
          </select>
        </div>
        
        <!-- Thumbnail preview -->
        <div class="thumbnail-preview" id="thumbnailPreview">
          <img id="thumbnailImg" src="" alt="Preview">
          <div class="time-label" id="thumbnailTime">0:00</div>
        </div>
        
        <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
      </div>
  </div>
  
  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-content">
      <h2 class="welcome-title">WELCOME TO SMX STREAM</h2>
      <div class="welcome-text">
        <p>SMX Stream is your live training platform for Security Mission Exercises. Watch live training sessions, access recorded content, and interact with instructors in real-time. Use the controls below to navigate through streams, adjust playback settings, and switch between live and local content.</p>
      </div>
      <div class="welcome-actions">
        <div class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          <label for="dontShowAgain">Don't show this again</label>
        </div>
        <button class="welcome-close" id="closeWelcome">Get Started</button>
      </div>
    </div>
  </div>
  
  <script>
    // Welcome Modal Functionality
    const welcomeModal = document.getElementById('welcomeModal');
    const closeWelcomeBtn = document.getElementById('closeWelcome');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    
    // Check if user has chosen not to show the welcome modal
    function shouldShowWelcome() {
      return localStorage.getItem('smx-stream-hide-welcome') !== 'true';
    }
    
    // Show welcome modal on page load
    function showWelcomeModal() {
      if (shouldShowWelcome()) {
        setTimeout(() => {
          welcomeModal.classList.add('show');
        }, 500); // Small delay for better UX
      }
    }
    
    // Close welcome modal
    function closeWelcomeModal() {
      welcomeModal.classList.remove('show');
      
      // Save preference if checkbox is checked
      if (dontShowAgainCheckbox.checked) {
        localStorage.setItem('smx-stream-hide-welcome', 'true');
      }
    }
    
    // Event listeners for welcome modal
    closeWelcomeBtn.addEventListener('click', closeWelcomeModal);
    
    // Close modal when clicking outside the content
    welcomeModal.addEventListener('click', function(e) {
      if (e.target === welcomeModal) {
        closeWelcomeModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && welcomeModal.classList.contains('show')) {
        closeWelcomeModal();
      }
    });
    
    // Show welcome modal when page loads
    window.addEventListener('load', showWelcomeModal);
    
    // Error message display function
    function showErrorMessage(title, message) {
      // Hide loading spinner
      loading.style.display = 'none';
      
      // Create error overlay
      const errorOverlay = document.createElement('div');
      errorOverlay.className = 'welcome-modal show';
      errorOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ef4444;">‚ö†Ô∏è ${title}</h2>
          <div class="welcome-text">
            <p>${message}</p>
            <div style="margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border-left: 4px solid #ef4444;">
              <strong>Quick Fixes:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>Make sure you're logged in to the system</li>
                <li>Access the stream through the dashboard or class page</li>
                <li>Check that the class ID in the URL is correct</li>
                <li>Contact your instructor if the problem persists</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="goToDashboard()">Go to Dashboard</button>
            <button class="welcome-close" onclick="retryConnection()" style="background: #22c55e;">Retry</button>
            <button class="welcome-close" onclick="openDebugTool()" style="background: #ff9800;">Debug Tool</button>
            <button class="welcome-close" onclick="testWebRTCConnection()" style="background: #8b5cf6;">Test WebRTC</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(errorOverlay);
    }
    
    function goToDashboard() {
      window.location.href = '/dashboard.html';
    }
    
    function retryConnection() {
      // Remove error overlay
      const errorOverlay = document.querySelector('.welcome-modal');
      if (errorOverlay) {
        errorOverlay.remove();
      }
      
      // Show loading and retry
      loading.style.display = 'block';
      fetchClassInfo();
    }
    
    function openDebugTool() {
      window.open('/debug-stream.html', '_blank');
    }
    
    // Test WebRTC connection manually
    function testWebRTCConnection() {
      console.log('üß™ Testing WebRTC connection...');
      console.log('üìä Current state:');
      console.log('  - Class ID:', classId);
      console.log('  - WebRTC Socket:', webrtcSocket ? 'Connected' : 'Not connected');
      console.log('  - Peer Connection:', peerConnection ? 'Exists' : 'None');
      console.log('  - WebRTC Video Element:', webrtcVideo);
      console.log('  - Is WebRTC Mode:', isWebRTCMode);
      
      // Force switch to WebRTC mode for testing
      switchToWebRTCMode();
      
      // Test video element
      if (webrtcVideo) {
        console.log('üì∫ WebRTC Video Element Properties:');
        console.log('  - Display:', webrtcVideo.style.display);
        console.log('  - Source Object:', webrtcVideo.srcObject);
        console.log('  - Autoplay:', webrtcVideo.autoplay);
        console.log('  - Muted:', webrtcVideo.muted);
      }
    }
    
    // Test streaming connection end-to-end
    async function testStreamingConnection() {
      console.log('üß™ Testing streaming connection...');
      
      const results = {
        classId: classId || 'Not set',
        streamKey: streamKey || 'Not set',
        socketConnection: false,
        hlsServer: false,
        streamEndpoint: false,
        streamStatus: 'Unknown'
      };
      
      try {
        // Test 1: Check if we have class ID and stream key
        if (!classId) {
          console.error('‚ùå No class ID available');
          return results;
        }
        
        if (!streamKey) {
          console.error('‚ùå No stream key available');
          return results;
        }
        
        // Test 2: Check Socket.IO connection
        if (typeof io !== 'undefined') {
          results.socketConnection = true;
          console.log('‚úÖ Socket.IO is available');
        } else {
          console.error('‚ùå Socket.IO not available');
        }
        
        // Test 3: Check HLS server
        try {
          const hlsTestUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          const hlsResponse = await fetch(hlsTestUrl, { method: 'HEAD' });
          results.hlsServer = hlsResponse.ok;
          console.log(hlsResponse.ok ? '‚úÖ HLS server responding' : '‚ùå HLS server not responding');
        } catch (error) {
          console.error('‚ùå HLS server test failed:', error.message);
        }
        
        // Test 4: Check stream status endpoint
        try {
          const authToken = localStorage.getItem('token');
          const statusResponse = await fetch(`/api/stream/status/${classId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });
          
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            results.streamStatus = statusData.status;
            results.streamEndpoint = true;
            console.log('‚úÖ Stream status endpoint working, status:', statusData.status);
          } else {
            console.error('‚ùå Stream status endpoint failed:', statusResponse.status);
          }
        } catch (error) {
          console.error('‚ùå Stream status test failed:', error.message);
        }
        
        // Test 5: Test stream start simulation (for instructors only)
        const userRole = localStorage.getItem('role');
        if (userRole === 'instructor' || userRole === 'admin') {
          console.log('üë®‚Äçüè´ Instructor detected - testing stream start capability');
          try {
            const authToken = localStorage.getItem('token');
            const testResponse = await fetch(`/api/streams/start/${classId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ source: 'test' })
            });
            
            if (testResponse.ok) {
              console.log('‚úÖ Stream start endpoint accessible');
              // Immediately stop the test stream
              await fetch(`/api/streams/stop/${classId}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({})
              });
            } else {
              console.error('‚ùå Stream start endpoint failed:', testResponse.status);
            }
          } catch (error) {
            console.error('‚ùå Stream start test failed:', error.message);
          }
        }
        
        console.log('üß™ Streaming connection test results:', results);
        return results;
        
      } catch (error) {
        console.error('‚ùå Streaming connection test failed:', error);
        return results;
      }
    }
    
    // Pre-Stream Checklist System
    async function runPreStreamChecklist() {
      console.log('üîç Running Pre-Stream Checklist...');
      
      const checklist = {
        authentication: { status: 'pending', message: 'Checking authentication...' },
        classAccess: { status: 'pending', message: 'Verifying class access...' },
        streamKey: { status: 'pending', message: 'Validating stream key...' },
        studentEnrollment: { status: 'pending', message: 'Checking student enrollment...' },
        streamingInfrastructure: { status: 'pending', message: 'Testing streaming infrastructure...' },
        socketConnection: { status: 'pending', message: 'Establishing real-time connection...' },
        streamStatus: { status: 'pending', message: 'Initializing stream status...' }
      };
      
      // Show checklist if instructor
      const userRole = localStorage.getItem('role');
      if (userRole === 'instructor') {
        showPreStreamChecklist(checklist);
      }
      
      try {
        // 1. Authentication Check
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          checklist.authentication = { status: 'failed', message: 'No authentication token found' };
          throw new Error('Authentication required');
        }
        
        // Verify token with server
        const authResponse = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!authResponse.ok) {
          checklist.authentication = { status: 'failed', message: 'Invalid or expired token' };
          throw new Error('Authentication failed');
        }
        
        checklist.authentication = { status: 'success', message: 'Authentication verified' };
        updateChecklistItem('authentication', checklist.authentication);
        
        // 2. Class Access Check
        const classResponse = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!classResponse.ok) {
          if (classResponse.status === 403) {
            checklist.classAccess = { status: 'failed', message: 'Access denied to this class' };
          } else if (classResponse.status === 404) {
            checklist.classAccess = { status: 'failed', message: 'Class not found' };
          } else {
            checklist.classAccess = { status: 'failed', message: `Server error: ${classResponse.status}` };
          }
          throw new Error('Class access failed');
        }
        
        const classData = await classResponse.json();
        checklist.classAccess = { status: 'success', message: `Access granted to "${classData.currentLesson?.title || 'class'}"` };
        updateChecklistItem('classAccess', checklist.classAccess);
        
        // 3. Stream Key Validation
        if (!classData.streamKey) {
          checklist.streamKey = { status: 'warning', message: 'No stream key configured - will generate one' };
          // Auto-generate stream key for the class
          await generateStreamKey(classId);
        } else {
          checklist.streamKey = { status: 'success', message: `Stream key ready: ${classData.streamKey.substring(0, 8)}...` };
        }
        updateChecklistItem('streamKey', checklist.streamKey);
        
        // 4. Student Enrollment Check
        const enrollmentCount = classData.session?.enrolledStudents || 0;
        if (enrollmentCount === 0) {
          checklist.studentEnrollment = { status: 'warning', message: 'No students enrolled yet' };
        } else {
          checklist.studentEnrollment = { status: 'success', message: `${enrollmentCount} students enrolled` };
        }
        updateChecklistItem('studentEnrollment', checklist.studentEnrollment);
        
        // 5. Streaming Infrastructure Check
        const hlsServerUrl = process.env.HLS_SERVER_URL || 'http://127.0.0.1:8888';
        try {
          const infraResponse = await fetch(`${hlsServerUrl}/health`, { method: 'HEAD' });
          if (infraResponse.ok) {
            checklist.streamingInfrastructure = { status: 'success', message: 'Streaming server ready' };
          } else {
            checklist.streamingInfrastructure = { status: 'warning', message: 'Streaming server may not be ready' };
          }
        } catch (error) {
          checklist.streamingInfrastructure = { status: 'warning', message: 'Cannot verify streaming server' };
        }
        updateChecklistItem('streamingInfrastructure', checklist.streamingInfrastructure);
        
        // 6. Socket.IO Connection
        if (typeof io !== 'undefined') {
          checklist.socketConnection = { status: 'success', message: 'Real-time connection ready' };
        } else {
          checklist.socketConnection = { status: 'warning', message: 'Socket.IO not available' };
        }
        updateChecklistItem('socketConnection', checklist.socketConnection);
        
        // 7. Stream Status Initialization
        checklist.streamStatus = { status: 'success', message: `Stream status: ${classData.status}` };
        updateChecklistItem('streamStatus', checklist.streamStatus);
        
        console.log('‚úÖ Pre-Stream Checklist completed successfully');
        return { success: true, checklist };
        
      } catch (error) {
        console.error('‚ùå Pre-Stream Checklist failed:', error);
        return { success: false, checklist, error: error.message };
      }
    }
    
    // Generate stream key for class
    async function generateStreamKey(classId) {
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/classes/${classId}/generate-stream-key`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('‚úÖ Stream key generated:', data.streamKey);
          return data.streamKey;
        }
      } catch (error) {
        console.error('‚ùå Failed to generate stream key:', error);
      }
      return null;
    }
    
    // Show pre-stream checklist for instructors
    function showPreStreamChecklist(checklist) {
      const checklistOverlay = document.createElement('div');
      checklistOverlay.className = 'welcome-modal show';
      checklistOverlay.id = 'preStreamChecklist';
      checklistOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title">üîç Pre-Stream Checklist</h2>
          <div class="welcome-text">
            <p>Verifying all systems are ready for streaming...</p>
            <div id="checklistItems" style="margin: 20px 0; text-align: left;">
              ${Object.entries(checklist).map(([key, item]) => `
                <div class="checklist-item" id="checklist-${key}" style="
                  padding: 10px;
                  margin: 8px 0;
                  background: rgba(255, 255, 255, 0.05);
                  border-radius: 8px;
                  border-left: 4px solid #fbbf24;
                  display: flex;
                  align-items: center;
                ">
                  <div class="status-icon" style="margin-right: 10px; font-size: 1.2em;">‚è≥</div>
                  <div class="status-text">${item.message}</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closePreStreamChecklist()" disabled id="checklistCloseBtn">Please Wait...</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(checklistOverlay);
    }
    
    // Update individual checklist item
    function updateChecklistItem(key, item) {
      const checklistItem = document.getElementById(`checklist-${key}`);
      if (!checklistItem) return;
      
      const statusIcon = checklistItem.querySelector('.status-icon');
      const statusText = checklistItem.querySelector('.status-text');
      
      let color, icon;
      switch (item.status) {
        case 'success':
          color = '#22c55e';
          icon = '‚úÖ';
          break;
        case 'warning':
          color = '#fbbf24';
          icon = '‚ö†Ô∏è';
          break;
        case 'failed':
          color = '#ef4444';
          icon = '‚ùå';
          break;
        default:
          color = '#fbbf24';
          icon = '‚è≥';
      }
      
      checklistItem.style.borderLeftColor = color;
      statusIcon.textContent = icon;
      statusText.textContent = item.message;
      
      // Check if all items are complete
      setTimeout(() => {
        const allItems = document.querySelectorAll('.checklist-item .status-icon');
        const allComplete = Array.from(allItems).every(icon => 
          icon.textContent === '‚úÖ' || icon.textContent === '‚ö†Ô∏è' || icon.textContent === '‚ùå'
        );
        
        if (allComplete) {
          const closeBtn = document.getElementById('checklistCloseBtn');
          if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.textContent = 'Continue';
          }
        }
      }, 100);
    }
    
    // Close pre-stream checklist
    function closePreStreamChecklist() {
      const checklistOverlay = document.getElementById('preStreamChecklist');
      if (checklistOverlay) {
        checklistOverlay.remove();
      }
    }
    
    // Auto-assign class ID for students based on their enrollment
    async function autoAssignStudentClass() {
      const userRole = localStorage.getItem('role');
      if (userRole !== 'student') return null;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const userData = await response.json();
          if (userData.user.classId) {
            console.log('üìö Auto-assigned student to class:', userData.user.classId);
            localStorage.setItem('currentClassId', userData.user.classId);
            return userData.user.classId;
          }
        }
      } catch (error) {
        console.error('‚ùå Failed to auto-assign student class:', error);
      }
      
      return null;
    }
    
    function showWaitingMessage() {
      // Update the stream type indicator
      updateStreamTypeIndicator('Waiting for Stream...');
      
      // Create a waiting overlay
      const waitingOverlay = document.createElement('div');
      waitingOverlay.className = 'welcome-modal show';
      waitingOverlay.id = 'waitingOverlay';
      waitingOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ff9800;">‚è≥ Waiting for Stream</h2>
          <div class="welcome-text">
            <p>The instructor hasn't started streaming yet. The page will automatically update when the stream becomes available.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 152, 0, 0.1); border-radius: 10px; border-left: 4px solid #ff9800;">
              <strong>What's happening:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>‚úÖ Connected to class successfully</li>
                <li>‚è≥ Waiting for instructor to start streaming</li>
                <li>üîÑ Automatically checking for updates every 3 seconds</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closeWaitingMessage()">Continue Waiting</button>
            <button class="welcome-close" onclick="goToDashboard()" style="background: #6b7280;">Back to Dashboard</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(waitingOverlay);
    }
    
    function closeWaitingMessage() {
      const waitingOverlay = document.getElementById('waitingOverlay');
      if (waitingOverlay) {
        waitingOverlay.remove();
      }
    }
    
    // Update stream type indicator with class information
    function updateStreamTypeIndicator(streamType = 'Stream') {
      const className = localStorage.getItem('currentClassName');
      if (className) {
        streamTypeIndicator.textContent = `${className} - ${streamType}`;
      } else {
        streamTypeIndicator.textContent = streamType;
      }
    }
    
    // Automatically fetch user's assigned class ID
    async function fetchUserAssignedClass() {
      try {
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          console.log('‚ùå No auth token available');
          return null;
        }
        
        console.log('üì° Fetching user\'s assigned class from server...');
        
        // First, try to get user info which should include their assigned class
        const userResponse = await fetch('/api/auth/verify', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (userResponse.ok) {
          const userData = await userResponse.json();
          console.log('üë§ User data:', userData.user);
          
          // Check if user has a direct class assignment
          if (userData.user.classId) {
            console.log('‚úÖ Found direct class assignment:', userData.user.classId);
            return userData.user.classId;
          }
        }
        
        // If no direct assignment, try to get user's enrolled classes
        const classesResponse = await fetch('/api/classes/my-classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (classesResponse.ok) {
          const userClasses = await classesResponse.json();
          console.log('üìö Found user classes:', userClasses.length);
          
          if (userClasses.length > 0) {
            // Prioritize classes with active streams, then most recent
            const sortedClasses = userClasses.sort((a, b) => {
              // Live streams first
              if (a.streamStatus === 'live' && b.streamStatus !== 'live') return -1;
              if (b.streamStatus === 'live' && a.streamStatus !== 'live') return 1;
              
              // Then by most recent update
              return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            
            const selectedClass = sortedClasses[0];
            console.log('‚úÖ Auto-selected class:', selectedClass.name, selectedClass._id);
            
            // Store class name for display
            localStorage.setItem('currentClassName', selectedClass.name);
            
            return selectedClass._id;
          }
        }
        
        // Fallback: try to get any accessible class for this user
        console.log('‚ö†Ô∏è No enrolled classes found, checking accessible classes...');
        const allClassesResponse = await fetch('/api/classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (allClassesResponse.ok) {
          const allClasses = await allClassesResponse.json();
          if (allClasses.length > 0) {
            // For instructors, they might have access to classes they teach
            const userRole = localStorage.getItem('role');
            if (userRole === 'instructor' || userRole === 'admin') {
              const firstClass = allClasses[0];
              console.log('‚úÖ Instructor/Admin assigned to first available class:', firstClass._id);
              localStorage.setItem('currentClassName', firstClass.name);
              return firstClass._id;
            }
          }
        }
        
        console.log('‚ùå No accessible classes found');
        return null;
        
      } catch (error) {
        console.error('‚ùå Error fetching user assigned class:', error);
        return null;
      }
    }
    

    
    const video = document.getElementById('video');
    const webrtcVideo = document.getElementById('webrtcVideo');
    const streamTypeIndicator = document.getElementById('streamTypeIndicator');
    const playBtn = document.getElementById('playBtn');
    const timeline = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    
    // WebRTC Variables
    let peerConnection = null;
    let webrtcSocket = null;
    let isWebRTCMode = false;
    let classId = null;
    const playhead = document.getElementById('playhead');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const loading = document.getElementById('loading');
    const rateBtn = document.getElementById('rateBtn');
    const liveBtn = document.getElementById('liveBtn');
    const streamMode = document.getElementById('streamMode');
    const fileInput = document.getElementById('fileInput');
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImg = document.getElementById('thumbnailImg');
    const thumbnailTime = document.getElementById('thumbnailTime');
    
    // Skip buttons
    document.getElementById('rewind10').onclick = () => video.currentTime -= 10;
    document.getElementById('rewind30').onclick = () => video.currentTime -= 30;
    document.getElementById('forward10').onclick = () => video.currentTime += 10;
    document.getElementById('forward30').onclick = () => video.currentTime += 30;
    
    let hlsInstance = null;
    
    // Thumbnail generation functionality
    let thumbnailCache = [];
    
    function generateThumbnails() {
      const offscreen = document.createElement('canvas');
      offscreen.width = 120;
      offscreen.height = 70;
      const offCtx = offscreen.getContext('2d');

      let current = 0;
      const end = Math.floor(video.duration);

      function snapNext() {
        if (current > end) return;

        video.currentTime = current;
        video.addEventListener('seeked', function capture() {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
          const img = new Image();
          img.src = offscreen.toDataURL();
          thumbnailCache.push({ time: current, img });

          current++;
          video.removeEventListener('seeked', capture);
          setTimeout(snapNext, 200); // short delay ensures rendering stability
        }, { once: true });
      }

      snapNext();
    }
    
    // Function to get thumbnail for a specific time
    function getThumbnailForTime(time) {
      if (thumbnailCache.length === 0) return null;
      
      // Find the closest thumbnail
      let closest = thumbnailCache[0];
      let minDiff = Math.abs(closest.time - time);
      
      for (let i = 1; i < thumbnailCache.length; i++) {
        const diff = Math.abs(thumbnailCache[i].time - time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = thumbnailCache[i];
        }
      }
      
      return closest;
    }
    
    // WebRTC Functions
    function initializeWebRTCSocket() {
      if (webrtcSocket) return;
      
      webrtcSocket = io();
      
      webrtcSocket.on('connect', () => {
        console.log('üîå WebRTC Socket connected');
        if (classId) {
          webrtcSocket.emit('student-join-class', { classId: classId });
        }
      });
      
      webrtcSocket.on('disconnect', () => {
        console.log('‚ùå WebRTC Socket disconnected');
      });
      
      webrtcSocket.on('instructor-started-webrtc', (data) => {
        console.log('üî¥ Instructor started WebRTC stream:', data.mediaType);
        console.log('üîÑ Current WebRTC video element:', webrtcVideo);
        console.log('üîÑ Current peer connection:', peerConnection);
        
        switchToWebRTCMode();
        updateStreamTypeIndicator(`Live ${data.mediaType}`);
        
        // Show loading while waiting for WebRTC connection
        loading.style.display = 'block';
        loading.textContent = 'Connecting to live stream...';
      });
      
      webrtcSocket.on('instructor-stopped-webrtc', (data) => {
        console.log('‚èπÔ∏è Instructor stopped WebRTC stream');
        switchToFileMode();
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      });
      
      webrtcSocket.on('webrtc-offer', async (data) => {
        console.log('üì° Received WebRTC offer from instructor');
        await handleWebRTCOffer(data.offer);
      });
      
      webrtcSocket.on('webrtc-ice-candidate', async (data) => {
        console.log('üßä Received ICE candidate from instructor');
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    async function handleWebRTCOffer(offer) {
      try {
        console.log('üîó Creating WebRTC peer connection...');
        
        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });
        
        // Handle incoming stream
        peerConnection.ontrack = (event) => {
          console.log('üì∫ Received WebRTC stream:', event.streams[0]);
          console.log('üì∫ Stream tracks:', event.streams[0].getTracks());
          
          webrtcVideo.srcObject = event.streams[0];
          
          // Ensure we're in WebRTC mode
          switchToWebRTCMode();
          
          // Try to play the video
          webrtcVideo.play().then(() => {
            console.log('‚úÖ WebRTC video playing');
            loading.style.display = 'none';
          }).catch(error => {
            console.error('‚ùå WebRTC video play failed:', error);
            // Try to play with user interaction
            webrtcVideo.muted = true;
            webrtcVideo.play().then(() => {
              console.log('‚úÖ WebRTC video playing (muted)');
              loading.style.display = 'none';
            }).catch(e => {
              console.error('‚ùå WebRTC video play failed even muted:', e);
            });
          });
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            webrtcSocket.emit('webrtc-ice-candidate', {
              to: 'instructor',
              candidate: event.candidate
            });
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          console.log('üîó WebRTC connection state:', state);
          
          if (state === 'connected') {
            console.log('‚úÖ WebRTC connection established');
          } else if (state === 'disconnected' || state === 'failed') {
            console.log('‚ùå WebRTC connection lost');
            switchToFileMode();
          }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer back to instructor
        webrtcSocket.emit('webrtc-answer', {
          to: 'instructor',
          answer: answer
        });
        
        console.log('üì§ Sent WebRTC answer to instructor');
      } catch (error) {
        console.error('‚ùå Error handling WebRTC offer:', error);
        switchToFileMode();
      }
    }
    
    function switchToWebRTCMode() {
      console.log('üîÑ Switching to WebRTC mode');
      isWebRTCMode = true;
      
      // Hide regular video and show WebRTC video
      video.style.display = 'none';
      webrtcVideo.style.display = 'block';
      
      // Configure WebRTC video element
      webrtcVideo.autoplay = true;
      webrtcVideo.playsInline = true;
      webrtcVideo.controls = true; // Add controls for debugging
      
      // Hide file-based controls
      document.getElementById('controls').style.display = 'none';
      
      updateStreamTypeIndicator('Live WebRTC Stream');
      
      // Show WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'block';
      }
      
      console.log('‚úÖ Switched to WebRTC mode - video element visible:', webrtcVideo.style.display);
    }
    
    function switchToFileMode() {
      console.log('üîÑ Switching to file mode');
      isWebRTCMode = false;
      
      webrtcVideo.style.display = 'none';
      video.style.display = 'block';
      
      // Show file-based controls
      document.getElementById('controls').style.display = 'flex';
      
      updateStreamTypeIndicator('File Stream');
      
      // Hide WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'none';
      }
      
      if (webrtcVideo.srcObject) {
        webrtcVideo.srcObject = null;
      }
    }

    // Fetch class information from the backend
    async function fetchClassInfo() {
      try {
        // Get classId from URL parameters or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
        
        // If no class ID, automatically fetch user's assigned class
        if (!classId) {
          console.log('üîç No class ID provided, fetching user\'s assigned class...');
          classId = await fetchUserAssignedClass();
          
          if (!classId) {
            console.error('‚ùå No class ID available');
            showErrorMessage('No Class Assignment Found', 'You are not currently enrolled in any classes. Please contact your instructor or check your enrollment status.');
            return;
          }
          
          // Store the fetched class ID for future use
          localStorage.setItem('currentClassId', classId);
          console.log('‚úÖ Auto-assigned to class:', classId);
          
          // Update stream type indicator with class info
          updateStreamTypeIndicator();
        }
        
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('‚ùå Authentication failed');
            showErrorMessage('Authentication Required', 'You need to log in to access this stream. Please log in and try again.');
            return;
          } else if (response.status === 403) {
            console.error('‚ùå Access denied');
            showErrorMessage('Access Denied', 'You do not have permission to access this class stream. Please contact your instructor.');
            return;
          } else if (response.status === 404) {
            console.error('‚ùå Class not found');
            showErrorMessage('Class Not Found', 'The requested class could not be found. Please check the class ID and try again.');
            return;
          }
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('üìä Stream status data:', data);
        
        const streamKey = data.streamKey;
        const streamStatus = data.status;
        const currentSource = data.currentSource;

        console.log('üîë StreamKey:', streamKey);
        console.log('üì° Status:', streamStatus);
        console.log('üìπ Source:', currentSource);

        // Check if stream is active
        if (streamStatus !== 'live') {
          console.log('‚è∏Ô∏è Stream is not live, waiting for instructor...');
          loading.style.display = 'block';
          
          // Show waiting message after 10 seconds
          setTimeout(() => {
            if (loading.style.display === 'block') {
              showWaitingMessage();
            }
          }, 10000);
          
          // Retry after 3 seconds
          setTimeout(() => fetchClassInfo(), 3000);
          return;
        }

        // Handle different stream sources
        if (currentSource === 'upload' && data.session && data.session.uploadFilename) {
          // For uploaded videos, use direct video URL
          const videoUrl = `/api/stream/video/${data.session.uploadFilename}`;
          console.log('üìπ Loading uploaded video:', videoUrl);
          console.log('üìÅ Upload filename:', data.session.uploadFilename);
          
          // Use direct video playback for uploaded files
          video.src = videoUrl;
          video.load();
          
          video.addEventListener('loadstart', () => console.log('üîÑ Video load started'));
          video.addEventListener('loadeddata', () => console.log('‚úÖ Video data loaded'));
          video.addEventListener('canplay', () => console.log('‚ñ∂Ô∏è Video can play'));
          video.addEventListener('error', (e) => console.error('‚ùå Video error:', e));
          
          video.play().catch(e => console.log('üîá Video autoplay prevented:', e));
          
        } else {
          // For live streams, use HLS
          const streamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          console.log('Loading HLS stream:', streamUrl);
          
          // Initialize HLS.js
          if (Hls.isSupported()) {
            hlsInstance = new Hls({
              enableWorker: true,
              lowLatencyMode: true,
              backBufferLength: 90
            });
            hlsInstance.loadSource(streamUrl);
            hlsInstance.attachMedia(video);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
              video.play();
            });
          
          // Generate thumbnails when video metadata is loaded
          video.addEventListener('loadedmetadata', function() {
            generateThumbnails();
          }, { once: true });

            hlsInstance.on(Hls.Events.ERROR, function(event, data) {
              console.error('HLS error:', data);
              if (data.fatal) {
                setTimeout(() => fetchClassInfo(), 5000); // Retry after 5 seconds
              }
            });
          } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = streamUrl;
            video.addEventListener('loadedmetadata', function() {
              video.play();
              generateThumbnails();
            });
          } else {
            console.error('HLS is not supported in this browser');
          }
        }
        
        video.addEventListener('canplay', function() {
          loading.style.display = 'none';
        });
        
        video.addEventListener('waiting', function() {
          loading.style.display = 'block';
        });
        
        video.addEventListener('playing', function() {
          loading.style.display = 'none';
        });
        
        // Initialize WebRTC socket for live streaming
        initializeWebRTCSocket();
        
        // Connect to Socket.IO for real-time updates
        if (streamKey && typeof io !== 'undefined') {
          const socket = io();
          console.log('üîå Connecting to Socket.IO with streamKey:', streamKey);
          socket.emit('join-stream', streamKey);
          
          // Also join WebRTC room for live streaming
          socket.emit('student-join-class', { classId: classId });
          console.log('üéì Joining WebRTC class as student:', classId);
          
          socket.on('connect', () => {
            console.log('‚úÖ Socket.IO connected successfully');
            // Re-join rooms on reconnection
            socket.emit('join-stream', streamKey);
            socket.emit('student-join-class', { classId: classId });
          });
          
          socket.on('disconnect', () => {
            console.log('‚ùå Socket.IO disconnected');
          });
          
          socket.on('streamStatus', (data) => {
            console.log('üì° Stream status update:', data);
            if (data.status === 'offline') {
              // Stream ended
              if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
              }
              video.src = '';
              video.pause();
              loading.style.display = 'block';
            } else if (data.status === 'live') {
              // New stream started
              loading.style.display = 'none';
              
              if (data.source === 'upload' && data.streamUrl) {
                // Switch to uploaded video
                if (hlsInstance) {
                  hlsInstance.destroy();
                  hlsInstance = null;
                }
                video.src = data.streamUrl;
                video.load();
                video.play().catch(e => console.log('Video autoplay prevented:', e));
              } else {
                // Switch to live HLS stream
                const newStreamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
                if (hlsInstance) {
                  hlsInstance.loadSource(newStreamUrl);
                } else if (Hls.isSupported()) {
                  hlsInstance = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                  });
                  hlsInstance.loadSource(newStreamUrl);
                  hlsInstance.attachMedia(video);
                }
              }
            } else if (data.status === 'paused') {
              video.pause();
            }
          });
          
          socket.on('notice', (data) => {
            // Display instructor notice
            console.log('Instructor notice:', data.message);
            // You can add UI to display notices here
          });
        }
        
      } catch (error) {
        console.error('Error fetching class information:', error);
        // Retry after 5 seconds
        setTimeout(() => fetchClassInfo(), 5000);
      }
    }
    
    // Debug information on page load
    console.log('üöÄ SMX Stream page loaded');
    console.log('üîç Checking for class ID and authentication...');
    
    const urlParams = new URLSearchParams(window.location.search);
    const urlClassId = urlParams.get('classId');
    const storedClassId = localStorage.getItem('currentClassId');
    const authToken = localStorage.getItem('token');
    
    console.log('üìã URL Class ID:', urlClassId);
    console.log('üíæ Stored Class ID:', storedClassId);
    console.log('üîê Auth Token:', authToken ? 'Present' : 'Missing');
    
    if (!urlClassId && !storedClassId) {
      console.log('üîç No class ID found - will automatically fetch user\'s assigned class');
    }
    
    if (!authToken) {
      console.warn('‚ö†Ô∏è No authentication token found - this will likely cause issues');
    }
    
    // Call the function to fetch class info and load the stream
    fetchClassInfo();
    
    // Play/pause toggle
    playBtn.addEventListener('click', function() {
      if (video.paused) {
        video.play();
      } else {
        video.pause();
      }
      updatePlayButton();
    });
    
    function updatePlayButton() {
      playBtn.textContent = video.paused ? 'Play' : 'Pause';
    }
    
    // Timeline functionality
    video.addEventListener('timeupdate', function() {
      const percent = (video.currentTime / video.duration) * 100;
      progress.style.width = percent + '%';
      playhead.style.left = percent + '%';
    });
    
    timeline.addEventListener('click', function(e) {
      const rect = timeline.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      video.currentTime = pos * video.duration;
    });
    
    // Timeline hover for thumbnail preview
    timeline.addEventListener('mousemove', function(e) {
      if (!video.duration || thumbnailCache.length === 0) return;
      
      const rect = timeline.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      const hoverTime = pos * video.duration;
      
      const thumbnail = getThumbnailForTime(hoverTime);
      if (thumbnail) {
        thumbnailImg.src = thumbnail.img.src;
        thumbnailTime.textContent = formatTime(hoverTime);
        
        // Position the preview
        const previewX = e.clientX - rect.left;
        thumbnailPreview.style.left = previewX + 'px';
        thumbnailPreview.style.display = 'block';
      }
    });
    
    timeline.addEventListener('mouseleave', function() {
      thumbnailPreview.style.display = 'none';
    });
    
    // Helper function to format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Fullscreen
    fullscreenBtn.addEventListener('click', function() {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.msRequestFullscreen) {
        video.msRequestFullscreen();
      }
    });
    
    // ‚è© Playback rate toggle
    rateBtn.addEventListener('click', function() {
      video.playbackRate = video.playbackRate === 1 ? 2 : video.playbackRate === 2 ? 0.5 : 1;
      rateBtn.textContent = video.playbackRate + 'x';
    });
    
    // üîÑ LIVE button
    liveBtn.addEventListener('click', function() {
      if (video.duration) {
        video.currentTime = video.duration - 0.05;
      }
    });
    
    // Update live status
    setInterval(() => {
      if (video.duration) {
        const live = Math.abs(video.duration - video.currentTime) < 2;
        liveBtn.style.display = live ? 'none' : 'inline-block';
      }
    }, 500);
    
    // üì¶ Stream mode selector
    streamMode.addEventListener('change', function() {
      if (streamMode.value === 'local') {
        fileInput.click();
      } else {
        fetchClassInfo();
      }
    });
    
    fileInput.addEventListener('change', function() {
      const file = fileInput.files[0];
      if (file) {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        const url = URL.createObjectURL(file);
        video.src = url;
        loading.style.display = 'block';
        
        // Generate thumbnails for local file
        video.addEventListener('loadedmetadata', function() {
          generateThumbnails();
        }, { once: true });
      }
    });
    
    // ‚å®Ô∏è Keyboard shortcuts
    window.addEventListener('keydown', function(e) {
      if (e.key === 'k' || e.key === ' ') {
        e.preventDefault();
        playBtn.click();
      }
      else if (e.key === 'j') video.currentTime -= 10;
      else if (e.key === 'l') video.currentTime += 10;
      else if (e.key === 'f') fullscreenBtn.click();
      else if (e.key === 'm') video.muted = !video.muted;
      else if (e.key === 'ArrowLeft') video.currentTime -= 5;
      else if (e.key === 'ArrowRight') video.currentTime += 5;
    });
    
    // Enhanced video event listeners
    video.addEventListener('playing', function() {
      loading.style.display = 'none';
      playBtn.textContent = 'Pause';
    });
    
    video.addEventListener('pause', function() {
      playBtn.textContent = 'Play';
    });

    // Advanced Video Timeline Component
    class VideoTimeline {
      constructor(videoId, timelineId) {
        this.video = document.getElementById(videoId);
        this.timeline = document.getElementById(timelineId);
        this.scrubber = document.getElementById('scrubber');
        this.thumbnails = [];
        this.zoomLevel = 1;
        this.visibleDuration = 60; // seconds visible at zoom level 1
        this.thumbnailInterval = 2; // seconds between thumbnails
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartTime = 0;
        
        this.init();
      }

      init() {
        if (!this.video || !this.timeline) return;
        
        // Wait for video metadata to load
        this.video.addEventListener('loadedmetadata', () => {
          this.generateThumbnails();
          this.setupEventListeners();
        });

        // If metadata is already loaded
        if (this.video.readyState >= 1) {
          this.generateThumbnails();
          this.setupEventListeners();
        }
      }

      async generateThumbnails() {
        const duration = this.video.duration;
        if (!duration) return;

        // Create container for thumbnails
        const container = document.createElement('div');
        container.className = 'timeline-container';
        this.timeline.appendChild(container);

        // Generate thumbnails every 2 seconds
        for (let time = 0; time < duration; time += this.thumbnailInterval) {
          const thumbnail = await this.captureThumbnail(time);
          const frame = this.createThumbnailFrame(thumbnail, time);
          container.appendChild(frame);
          this.thumbnails.push({ element: frame, time: time });
        }

        this.updateTimelineWidth();
      }

      async captureThumbnail(time) {
        return new Promise((resolve) => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          
          // Create a temporary video element for capture
          const tempVideo = this.video.cloneNode();
          tempVideo.muted = true;
          tempVideo.currentTime = time;
          
          tempVideo.addEventListener('seeked', () => {
            canvas.width = 160;
            canvas.height = 90;
            ctx.drawImage(tempVideo, 0, 0, canvas.width, canvas.height);
            resolve(canvas.toDataURL());
          }, { once: true });
        });
      }

      createThumbnailFrame(thumbnailSrc, time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        
        const img = document.createElement('img');
        img.src = thumbnailSrc;
        img.alt = `Frame at ${this.formatTime(time)}`;
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek
        frame.addEventListener('click', () => {
          this.video.currentTime = time;
        });
        
        return frame;
      }

      setupEventListeners() {
        // Update scrubber position on time update (only when not dragging)
        this.video.addEventListener('timeupdate', () => {
          if (!this.isDragging) {
            this.updateScrubberPosition();
          }
        });

        // Zoom with mouse wheel
        this.timeline.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
          this.zoomLevel *= zoomFactor;
          this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
          this.updateTimelineWidth();
        });

        // Scrubber drag functionality
        this.setupScrubberDrag();

        // Click on timeline to seek
        this.timeline.addEventListener('click', (e) => {
          if (e.target === this.timeline || e.target.classList.contains('timeline-container')) {
            this.seekToPosition(e);
          }
        });
      }

      setupScrubberDrag() {
        // Mouse events
        this.scrubber.addEventListener('mousedown', (e) => {
          this.startDrag(e);
        });

        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            this.handleDrag(e);
          }
        });

        document.addEventListener('mouseup', () => {
          this.endDrag();
        });

        // Touch events for mobile
        this.scrubber.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.startDrag(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
          if (this.isDragging) {
            e.preventDefault();
            this.handleDrag(e.touches[0]);
          }
        });

        document.addEventListener('touchend', () => {
          this.endDrag();
        });
      }

      startDrag(event) {
        this.isDragging = true;
        this.dragStartX = event.clientX;
        this.dragStartTime = this.video.currentTime;
        this.scrubber.classList.add('dragging');
        
        // Pause video during drag for smoother scrubbing
        this.wasPlaying = !this.video.paused;
        this.video.pause();
      }

      handleDrag(event) {
        if (!this.isDragging) return;

        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        // Calculate new time based on position
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        // Update video time and scrubber position
        this.video.currentTime = newTime;
        this.updateScrubberPosition();
        
        // Show time tooltip during drag
        this.showTimeTooltip(event.clientX, newTime);
      }

      endDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.scrubber.classList.remove('dragging');
        this.hideTimeTooltip();
        
        // Resume playback if it was playing before drag
        if (this.wasPlaying) {
          this.video.play();
        }
      }

      seekToPosition(event) {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        this.video.currentTime = newTime;
      }

      showTimeTooltip(x, time) {
        let tooltip = document.getElementById('scrubber-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.id = 'scrubber-tooltip';
          tooltip.style.cssText = `
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
          `;
          document.body.appendChild(tooltip);
        }
        
        tooltip.textContent = this.formatTime(time);
        tooltip.style.left = `${x - 25}px`;
        tooltip.style.top = `${this.timeline.getBoundingClientRect().top - 30}px`;
        tooltip.style.display = 'block';
      }

      hideTimeTooltip() {
        const tooltip = document.getElementById('scrubber-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
      }

      updateScrubberPosition() {
        if (!this.video.duration) return;
        
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const progress = this.video.currentTime / this.video.duration;
        const timelineWidth = container.offsetWidth;
        const scrubberPosition = progress * timelineWidth;
        
        this.scrubber.style.left = `${scrubberPosition}px`;
        
        // Auto-scroll to keep scrubber visible (only when not dragging)
        if (!this.isDragging) {
          const timelineScrollLeft = this.timeline.scrollLeft;
          const timelineVisibleWidth = this.timeline.offsetWidth;
          
          if (scrubberPosition < timelineScrollLeft || scrubberPosition > timelineScrollLeft + timelineVisibleWidth) {
            this.timeline.scrollLeft = scrubberPosition - timelineVisibleWidth / 2;
          }
        }
      }

      updateTimelineWidth() {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const frameWidth = 160 * this.zoomLevel;
        const totalFrames = this.thumbnails.length;
        const totalWidth = totalFrames * frameWidth;
        
        container.style.minWidth = `${totalWidth}px`;
        
        // Update frame widths
        this.thumbnails.forEach(({ element }) => {
          element.style.width = `${frameWidth}px`;
        });
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      zoom(factor) {
        this.zoomLevel *= factor;
        this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        this.updateTimelineWidth();
      }
    }

    // Global functions for video controls
    function togglePlayPause() {
      const video = document.getElementById('video');
      const playPauseBtn = document.querySelector('.play-pause-btn');
      
      if (video.paused) {
        video.play();
        playPauseBtn.innerHTML = '<span>‚è∏</span>';
      } else {
        video.pause();
        playPauseBtn.innerHTML = '<span>‚ñ∂</span>';
      }
    }

    function rewindVideo() {
      const video = document.getElementById('video');
      video.currentTime = Math.max(0, video.currentTime - 10);
    }

    function forwardVideo() {
      const video = document.getElementById('video');
      video.currentTime = Math.min(video.duration, video.currentTime + 10);
    }

    function jumpToLive() {
      const video = document.getElementById('video');
      // For recorded videos, jump to end
      // For live streams, this would jump to the live edge
      video.currentTime = video.duration;
    }

    function zoomTimeline(factor) {
      if (window.videoTimeline) {
        window.videoTimeline.zoom(factor);
      }
    }

    // Update time display
    function updateTimeDisplay() {
      const video = document.getElementById('video');
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl) {
        currentTimeEl.textContent = formatTime(video.currentTime);
        totalTimeEl.textContent = formatTime(video.duration || 0);
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Initialize advanced timeline
    setTimeout(() => {
      window.videoTimeline = new VideoTimeline('video', 'timeline');
      
      // Set up video event listeners for time display
      const video = document.getElementById('video');
      if (video) {
        video.addEventListener('timeupdate', updateTimeDisplay);
        video.addEventListener('loadedmetadata', updateTimeDisplay);
        video.addEventListener('play', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>‚è∏</span>';
        });
        video.addEventListener('pause', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>‚ñ∂</span>';
        });
      }
    }, 1000);
  </script>
</body>
</html>