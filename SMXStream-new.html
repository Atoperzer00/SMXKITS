<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMX Stream</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
      --secondary-gradient: linear-gradient(135deg, #333333 0%, #000000 100%);
      --accent-gradient: linear-gradient(135deg, #2a2a2a 0%, #000000 100%);
      --dark-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
      --card-gradient: linear-gradient(145deg, #1a1a1a 0%, #0a0a0a 100%);
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-primary: #ffffff;
      --text-secondary: #b8c5d6;
      --text-accent: #000000;
      --shadow-primary: 0 20px 40px rgba(0, 0, 0, 0.3);
      --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.4);
      --border-radius: 20px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      --bg: #0f172a;
      --fg: #f0f0f0;
      --accent: #000000;
      --track: #1e293b;
      --hover: rgba(255, 255, 255, 0.1);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--dark-gradient);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      line-height: 1.6;
    }

    /* Animated background particles */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(26, 26, 26, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(51, 51, 51, 0.1) 0%, transparent 50%);
      z-index: -1;
      animation: float 20s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      33% { transform: translateY(-20px) rotate(1deg); }
      66% { transform: translateY(10px) rotate(-1deg); }
    }
    
    .navbar {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      margin: 24px;
      padding: 1rem 0;
      flex-shrink: 0;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .navbar-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      display: flex;
      align-items: center;
      color: var(--fg);
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
    }
    
    .logo span {
      margin-right: 10px;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1rem;
    }
    
    .btn {
      font-size: 1rem;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
      padding: 0.75rem 1.5rem;
      border-radius: 15px;
      cursor: pointer;
      text-decoration: none;
      transition: var(--transition);
      font-weight: 500;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: var(--primary-gradient);
      transition: var(--transition);
      z-index: -1;
    }

    .btn:hover::before {
      left: 0;
    }
    
    .btn:hover {
      color: white;
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: rgba(0, 0, 0, 0.5);
    }
    
    .btn-primary {
      background: var(--primary-gradient);
      border-color: var(--accent);
      color: white;
    }
    
    .btn-primary:hover {
      background: var(--secondary-gradient);
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 24px 24px 24px;
    }
    
    .player-wrapper {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .video-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      background: #000;
      border-radius: 24px 24px 0 0;
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 24px 24px 0 0;
    }

    #timeline {
      flex-shrink: 0;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 0 0 24px 24px;
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
    }

    /* Video Overlay Controls */
    .video-controls-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }

    .video-container:hover .video-controls-overlay {
      opacity: 1;
      pointer-events: all;
    }

    .video-control-btn {
      background: var(--primary-gradient);
      border: 2px solid var(--accent);
      color: white;
      font-size: 1.5rem;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .video-control-btn:hover {
      transform: scale(1.2);
      box-shadow: 0 4px 15px rgba(255, 255, 255, 0.3);
    }
    
    .video-control-btn svg {
      transition: all 0.3s ease;
    }
    
    .video-control-btn:hover svg {
      transform: scale(1.1);
    }
    
    /* Global SVG icon styling */
    svg {
      flex-shrink: 0;
    }
    
    .logo svg {
      transition: all 0.3s ease;
    }
    
    .logo:hover svg {
      transform: rotate(5deg) scale(1.1);
    }
    
    /* Live button specific styling */
    .live-btn {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .live-btn svg {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .play-pause-btn {
      width: 80px;
      height: 80px;
      font-size: 1.5rem;
    }

    .live-btn {
      width: auto;
      padding: 0 1rem;
      border-radius: 25px;
      font-size: 0.9rem;
      font-weight: bold;
      gap: 0.5rem;
    }

    .live-btn:hover {
      background: rgba(255, 71, 87, 0.8);
      border-color: rgba(255, 71, 87, 0.8);
    }

    .zoom-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 0.5rem;
    }

    .zoom-btn {
      width: 45px;
      height: 45px;
      font-size: 1rem;
    }

    .time-display {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-family: monospace;
      font-size: 0.9rem;
      color: white;
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
    }

    /* Hide default video controls */
    .video-container video::-webkit-media-controls {
      display: none !important;
    }

    .video-container video::-moz-media-controls {
      display: none !important;
    }

    .video-container video {
      outline: none;
    }
    
    .video-info {
      padding: 1rem 2rem;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    
    .video-title {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .video-description {
      color: rgba(255,255,255,0.7);
    }
    
    .controls {
      display: flex;
      padding: 1.5rem;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 0;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      gap: 1rem;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    #timeline {
      position: relative;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      margin: 1rem 0;
      flex: none;
    }

    .timeline-viewport {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    .timeline-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: stretch;
      min-width: 200%;
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    /* Fixed Scrubber in Center */
    .timeline-scrubber {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, #ff4757 0%, #ff6b7a 100%);
      border-radius: 2px;
      z-index: 20;
      box-shadow: 0 0 10px rgba(255, 71, 87, 0.6);
      pointer-events: none;
    }

    .timeline-scrubber::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .timeline-scrubber::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    /* Live Marker */
    .timeline-live-marker {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      align-items: center;
      gap: 6px;
      background: rgba(255, 71, 87, 0.9);
      color: white;
      padding: 4px 8px;
      border-radius: 12px;
      font-size: 10px;
      font-weight: 600;
      z-index: 15;
      animation: pulse 2s infinite;
    }

    .timeline-live-marker svg {
      width: 8px;
      height: 8px;
    }

    .thumbnail-frame {
      position: relative;
      height: 100%;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
    }

    .thumbnail-frame:hover {
      transform: scale(1.02);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(112, 184, 255, 0.3);
    }

    .thumbnail-frame img {
      width: 100%;
      height: calc(100% - 20px);
      object-fit: cover;
      border-radius: 4px 4px 0 0;
    }

    .time-tick {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      border-radius: 0 0 4px 4px;
    }
    
    #scrubber {
      position: absolute;
      top: 0;
      left: 0;
      width: 3px;
      height: 100%;
      background: var(--primary-gradient);
      z-index: 100;
      cursor: grab;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      transition: left 0.1s ease;
      pointer-events: none; /* Disable dragging */
    }

    #scrubber:active {
      cursor: grabbing;
    }

    #scrubber.dragging {
      transition: none;
    }

    #scrubber::before {
      content: '';
      position: absolute;
      top: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }

    #scrubber::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }
    
    .thumbnail-preview {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 12px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      box-shadow: var(--shadow-primary);
    }
    
    .thumbnail-preview img {
      width: 120px;
      height: 70px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .thumbnail-preview .time-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-family: monospace;
      font-weight: 600;
      background: var(--glass-bg);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid var(--glass-border);
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--accent);
      border-right: 4px solid rgba(0, 0, 0, 0.6);
      border-radius: 50%;
      animation: spin 1s infinite linear;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-primary);
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    .live-badge {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      background: linear-gradient(135deg, #ef4444, #dc2626);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 25px;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 10;
      border: 2px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.4);
      animation: pulse 2s infinite;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .jump-to-live-indicator {
      position: absolute;
      bottom: 140px;
      right: 20px;
      background: linear-gradient(135deg, #ff4757, #ff3742);
      color: white;
      padding: 0.75rem 1.5rem;
      border-radius: 25px;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 100;
      border: 2px solid rgba(255, 255, 255, 0.3);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.4);
      cursor: pointer;
      transition: all 0.3s ease;
      display: none;
      animation: pulse 2s infinite;
    }

    .jump-to-live-indicator:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(255, 71, 87, 0.6);
    }

    .jump-to-live-indicator::before {
      content: '';
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      margin-right: 0.5rem;
      display: inline-block;
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1.05);
      }
    }
    
    .select-enhanced {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .select-enhanced option {
      background: rgba(28, 28, 28, 0.95);
      color: white;
      padding: 8px;
    }


    
    /* Welcome Modal Styles */
    .welcome-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .welcome-modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .welcome-content {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 2.5rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: var(--shadow-primary);
      position: relative;
      animation: modalSlideIn 0.4s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .welcome-title {
      font-size: 2rem;
      font-weight: bold;
      color: var(--text-primary);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .welcome-text {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    
    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }
    
    .welcome-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .welcome-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .welcome-close {
      background: var(--primary-gradient);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow-primary);
    }
    
    .welcome-close:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      background: var(--secondary-gradient);
    }
    
    .welcome-close:active {
      transform: translateY(0);
    }
    
    /* Stream Type Indicator */
    .stream-type-indicator {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* WebRTC Video Styling */
    #webrtcVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      object-fit: cover;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-content">
        <a href="/" class="logo">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 10px;">
            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
            <path d="M2 17l10 5 10-5"></path>
            <path d="M2 12l10 5 10-5"></path>
          </svg>
          SMX Stream
        </a>
        
        <div class="nav-buttons">
          <a href="dashboard.html" class="btn">Dashboard</a>
          <a href="#" class="btn">Settings</a>
        </div>
      </div>
    </div>
  </nav>
  
  <div class="main-content">
    <div class="player-wrapper">
        <div class="video-container">
          <div class="live-badge">LIVE</div>
          <video id="video" autoplay muted style="display:none;"></video>
          <video id="webrtcVideo" autoplay playsinline muted style="display:block; width:100%; height:100%; background:#000;"></video>
          <div class="loading-spinner" id="loading"></div>
          <div class="stream-type-indicator" id="streamTypeIndicator">WebRTC Stream</div>
          <div class="webrtc-status" id="webrtcStatus" style="display:none; position:absolute; top:60px; right:20px; background:rgba(139, 92, 246, 0.9); color:white; padding:8px 12px; border-radius:6px; font-size:12px; font-weight:600; display:flex; align-items:center; gap:6px;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
            LIVE WebRTC
          </div>
          
          <!-- Video Overlay Controls (Hidden by default, show on hover) -->
          <div class="video-controls-overlay">
            <!-- Play/Pause Button -->
            <button class="video-control-btn play-pause-btn" onclick="togglePlayPause()">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="5,3 19,12 5,21"></polygon>
              </svg>
            </button>
            
            <!-- Rewind Button -->
            <button class="video-control-btn rewind-btn" onclick="rewindVideo()">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="11,19 2,12 11,5"></polygon>
                <polygon points="22,19 13,12 22,5"></polygon>
              </svg>
            </button>
            
            <!-- Fast Forward Button -->
            <button class="video-control-btn forward-btn" onclick="forwardVideo()">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polygon points="13,19 22,12 13,5"></polygon>
                <polygon points="2,19 11,12 2,5"></polygon>
              </svg>
            </button>
            
            <!-- Jump to Live Button (for live streams) -->
            <button class="video-control-btn live-btn" onclick="jumpToLive()">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;">
                <circle cx="12" cy="12" r="10"></circle>
              </svg>
              <span>LIVE</span>
            </button>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls">
              <button class="video-control-btn zoom-btn" onclick="zoomTimeline(0.5)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="M21 21l-4.35-4.35"></path>
                  <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
              </button>
              <button class="video-control-btn zoom-btn" onclick="zoomTimeline(2)">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <circle cx="11" cy="11" r="8"></circle>
                  <path d="M21 21l-4.35-4.35"></path>
                  <line x1="11" y1="8" x2="11" y2="14"></line>
                  <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
              </button>
            </div>
            
            <!-- Time Display -->
            <div class="time-display">
              <span id="currentTime">0:00</span> / <span id="totalTime">0:00</span>
            </div>
          </div>
        </div>
        
        <!-- Jump to Live Indicator -->
        <div class="jump-to-live-indicator" id="jumpToLiveIndicator" onclick="jumpToLive()">
          JUMP TO LIVE
        </div>

        
        <div class="controls">
          <div id="timeline">
            <div class="timeline-viewport">
              <div class="timeline-container" id="timelineContainer">
                <!-- Timeline frames will be generated here -->
              </div>
              <div class="timeline-scrubber"></div>
              <div class="timeline-live-marker">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <circle cx="12" cy="12" r="10"></circle>
                </svg>
                LIVE
              </div>
            </div>
          </div>
        </div>
        
        <!-- Thumbnail preview -->
        <div class="thumbnail-preview" id="thumbnailPreview">
          <img id="thumbnailImg" src="" alt="Preview">
          <div class="time-label" id="thumbnailTime">0:00</div>
        </div>
        
        <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
      </div>
  </div>


  
  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-content">
      <h2 class="welcome-title">WELCOME TO SMX STREAM</h2>
      <div class="welcome-text">
        <p>SMX Stream is your live training platform for Security Mission Exercises. Watch live training sessions, access recorded content, and interact with instructors in real-time.</p>
        <br>
        <p><strong>Keyboard Shortcuts:</strong></p>
        <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
          <li><strong>Space/K</strong> - Play/Pause</li>
          <li><strong>J/L</strong> - Skip backward/forward 10s</li>
          <li><strong>Shift+L</strong> - Jump to LIVE</li>
          <li><strong>M</strong> - Mute/Unmute</li>
          <li><strong>F</strong> - Fullscreen</li>
          <li><strong>Arrow Keys</strong> - Skip 5s</li>
        </ul>
        <p><strong>Timeline:</strong> Double-click any time marker to jump to LIVE edge</p>
      </div>
      <div class="welcome-actions">
        <div class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          <label for="dontShowAgain">Don't show this again</label>
        </div>
        <button class="welcome-close" id="closeWelcome">Get Started</button>
      </div>
    </div>
  </div>
  
  <script>
    // Welcome Modal Functionality
    const welcomeModal = document.getElementById('welcomeModal');
    const closeWelcomeBtn = document.getElementById('closeWelcome');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    
    // Check if user has chosen not to show the welcome modal
    function shouldShowWelcome() {
      return localStorage.getItem('smx-stream-hide-welcome') !== 'true';
    }
    
    // Show welcome modal on page load
    function showWelcomeModal() {
      if (shouldShowWelcome()) {
        setTimeout(() => {
          welcomeModal.classList.add('show');
        }, 500); // Small delay for better UX
      }
    }
    
    // Close welcome modal
    function closeWelcomeModal() {
      welcomeModal.classList.remove('show');
      
      // Save preference if checkbox is checked
      if (dontShowAgainCheckbox.checked) {
        localStorage.setItem('smx-stream-hide-welcome', 'true');
      }
    }
    
    // Event listeners for welcome modal
    closeWelcomeBtn.addEventListener('click', closeWelcomeModal);
    
    // Close modal when clicking outside the content
    welcomeModal.addEventListener('click', function(e) {
      if (e.target === welcomeModal) {
        closeWelcomeModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && welcomeModal.classList.contains('show')) {
        closeWelcomeModal();
      }
    });
    
    // Icon utility functions
    const Icons = {
      play: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,3 19,12 5,21"></polygon></svg>`,
      pause: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`,
      rewind: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11,19 2,12 11,5"></polygon><polygon points="22,19 13,12 22,5"></polygon></svg>`,
      fastForward: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13,19 22,12 13,5"></polygon><polygon points="2,19 11,12 2,5"></polygon></svg>`,
      live: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;"><circle cx="12" cy="12" r="10"></circle></svg>`,
      zoomIn: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`,
      zoomOut: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>`
    };

    // Initialize WebRTC interface when page loads
    window.addEventListener('load', function() {
      showWelcomeModal();
      
      // Initialize stream timer for WebRTC
      if (!streamTimer) {
        streamTimer = createStreamTimer();
        console.log('⏱️ Stream timer initialized on page load');
      }
      
      // Start WebRTC timeline updates
      startWebRTCTimelineUpdates();
      
      // Initialize WebRTC timeline
      initializeWebRTCTimeline();
      
      // Show WebRTC status
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'flex';
      }
    });
    
    // Error message display function
    function showErrorMessage(title, message) {
      // Hide loading spinner
      loading.style.display = 'none';
      
      // Create error overlay
      const errorOverlay = document.createElement('div');
      errorOverlay.className = 'welcome-modal show';
      errorOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ef4444; display: flex; align-items: center; gap: 0.5rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
              <line x1="12" y1="9" x2="12" y2="13"></line>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            ${title}
          </h2>
          <div class="welcome-text">
            <p>${message}</p>
            <div style="margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border-left: 4px solid #ef4444;">
              <strong>Quick Fixes:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>Make sure you're logged in to the system</li>
                <li>Access the stream through the dashboard or class page</li>
                <li>Check that the class ID in the URL is correct</li>
                <li>Contact your instructor if the problem persists</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="goToDashboard()">Go to Dashboard</button>
            <button class="welcome-close" onclick="retryConnection()" style="background: #22c55e;">Retry</button>
            <button class="welcome-close" onclick="openDebugTool()" style="background: #ff9800;">Debug Tool</button>
            <button class="welcome-close" onclick="testWebRTCConnection()" style="background: #8b5cf6;">Test WebRTC</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(errorOverlay);
    }
    
    function goToDashboard() {
      window.location.href = '/dashboard.html';
    }
    
    function retryConnection() {
      // Remove error overlay
      const errorOverlay = document.querySelector('.welcome-modal');
      if (errorOverlay) {
        errorOverlay.remove();
      }
      
      // Show loading and retry
      loading.style.display = 'block';
      fetchClassInfo();
    }
    
    function openDebugTool() {
      window.open('/debug-stream.html', '_blank');
    }
    
    // Test WebRTC connection manually
    function testWebRTCConnection() {
      console.log('🧪 Testing WebRTC connection...');
      console.log('📊 Current state:');
      console.log('  - Class ID:', classId);
      console.log('  - WebRTC Socket:', webrtcSocket ? 'Connected' : 'Not connected');
      console.log('  - Peer Connection:', peerConnection ? 'Exists' : 'None');
      console.log('  - WebRTC Video Element:', webrtcVideo);
      console.log('  - Is WebRTC Mode:', isWebRTCMode);
      
      // Force switch to WebRTC mode for testing
      switchToWebRTCMode();
      
      // Test video element
      if (webrtcVideo) {
        console.log('📺 WebRTC Video Element Properties:');
        console.log('  - Display:', webrtcVideo.style.display);
        console.log('  - Source Object:', webrtcVideo.srcObject);
        console.log('  - Autoplay:', webrtcVideo.autoplay);
        console.log('  - Muted:', webrtcVideo.muted);
      }
    }
    
    // Test streaming connection end-to-end
    async function testStreamingConnection() {
      console.log('🧪 Testing streaming connection...');
      
      const results = {
        classId: classId || 'Not set',
        streamKey: streamKey || 'Not set',
        socketConnection: false,
        hlsServer: false,
        streamEndpoint: false,
        streamStatus: 'Unknown'
      };
      
      try {
        // Test 1: Check if we have class ID and stream key
        if (!classId) {
          console.error('❌ No class ID available');
          return results;
        }
        
        if (!streamKey) {
          console.error('❌ No stream key available');
          return results;
        }
        
        // Test 2: Check Socket.IO connection
        if (typeof io !== 'undefined') {
          results.socketConnection = true;
          console.log('✅ Socket.IO is available');
        } else {
          console.error('❌ Socket.IO not available');
        }
        
        // Test 3: Check HLS server
        try {
          const hlsTestUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          const hlsResponse = await fetch(hlsTestUrl, { method: 'HEAD' });
          results.hlsServer = hlsResponse.ok;
          console.log(hlsResponse.ok ? '✅ HLS server responding' : '❌ HLS server not responding');
        } catch (error) {
          console.error('❌ HLS server test failed:', error.message);
        }
        
        // Test 4: Check stream status endpoint
        try {
          const authToken = localStorage.getItem('token');
          const statusResponse = await fetch(`/api/stream/status/${classId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });
          
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            results.streamStatus = statusData.status;
            results.streamEndpoint = true;
            console.log('✅ Stream status endpoint working, status:', statusData.status);
          } else {
            console.error('❌ Stream status endpoint failed:', statusResponse.status);
          }
        } catch (error) {
          console.error('❌ Stream status test failed:', error.message);
        }
        
        // Test 5: Test stream start simulation (for instructors only)
        const userRole = localStorage.getItem('role');
        if (userRole === 'instructor' || userRole === 'admin') {
          console.log('👨‍🏫 Instructor detected - testing stream start capability');
          try {
            const authToken = localStorage.getItem('token');
            const testResponse = await fetch(`/api/streams/start/${classId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ source: 'test' })
            });
            
            if (testResponse.ok) {
              console.log('✅ Stream start endpoint accessible');
              // Immediately stop the test stream
              await fetch(`/api/streams/stop/${classId}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({})
              });
            } else {
              console.error('❌ Stream start endpoint failed:', testResponse.status);
            }
          } catch (error) {
            console.error('❌ Stream start test failed:', error.message);
          }
        }
        
        console.log('🧪 Streaming connection test results:', results);
        return results;
        
      } catch (error) {
        console.error('❌ Streaming connection test failed:', error);
        return results;
      }
    }
    
    // Pre-Stream Checklist System
    async function runPreStreamChecklist() {
      console.log('🔍 Running Pre-Stream Checklist...');
      
      const checklist = {
        authentication: { status: 'pending', message: 'Checking authentication...' },
        classAccess: { status: 'pending', message: 'Verifying class access...' },
        streamKey: { status: 'pending', message: 'Validating stream key...' },
        studentEnrollment: { status: 'pending', message: 'Checking student enrollment...' },
        streamingInfrastructure: { status: 'pending', message: 'Testing streaming infrastructure...' },
        socketConnection: { status: 'pending', message: 'Establishing real-time connection...' },
        streamStatus: { status: 'pending', message: 'Initializing stream status...' }
      };
      
      // Show checklist if instructor
      const userRole = localStorage.getItem('role');
      if (userRole === 'instructor') {
        showPreStreamChecklist(checklist);
      }
      
      try {
        // 1. Authentication Check
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          checklist.authentication = { status: 'failed', message: 'No authentication token found' };
          throw new Error('Authentication required');
        }
        
        // Verify token with server
        const authResponse = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!authResponse.ok) {
          checklist.authentication = { status: 'failed', message: 'Invalid or expired token' };
          throw new Error('Authentication failed');
        }
        
        checklist.authentication = { status: 'success', message: 'Authentication verified' };
        updateChecklistItem('authentication', checklist.authentication);
        
        // 2. Class Access Check
        const classResponse = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!classResponse.ok) {
          if (classResponse.status === 403) {
            checklist.classAccess = { status: 'failed', message: 'Access denied to this class' };
          } else if (classResponse.status === 404) {
            checklist.classAccess = { status: 'failed', message: 'Class not found' };
          } else {
            checklist.classAccess = { status: 'failed', message: `Server error: ${classResponse.status}` };
          }
          throw new Error('Class access failed');
        }
        
        const classData = await classResponse.json();
        checklist.classAccess = { status: 'success', message: `Access granted to "${classData.currentLesson?.title || 'class'}"` };
        updateChecklistItem('classAccess', checklist.classAccess);
        
        // 3. Stream Key Validation
        if (!classData.streamKey) {
          checklist.streamKey = { status: 'warning', message: 'No stream key configured - will generate one' };
          // Auto-generate stream key for the class
          await generateStreamKey(classId);
        } else {
          checklist.streamKey = { status: 'success', message: `Stream key ready: ${classData.streamKey.substring(0, 8)}...` };
        }
        updateChecklistItem('streamKey', checklist.streamKey);
        
        // 4. Student Enrollment Check
        const enrollmentCount = classData.session?.enrolledStudents || 0;
        if (enrollmentCount === 0) {
          checklist.studentEnrollment = { status: 'warning', message: 'No students enrolled yet' };
        } else {
          checklist.studentEnrollment = { status: 'success', message: `${enrollmentCount} students enrolled` };
        }
        updateChecklistItem('studentEnrollment', checklist.studentEnrollment);
        
        // 5. Streaming Infrastructure Check
        const hlsServerUrl = process.env.HLS_SERVER_URL || 'http://127.0.0.1:8888';
        try {
          const infraResponse = await fetch(`${hlsServerUrl}/health`, { method: 'HEAD' });
          if (infraResponse.ok) {
            checklist.streamingInfrastructure = { status: 'success', message: 'Streaming server ready' };
          } else {
            checklist.streamingInfrastructure = { status: 'warning', message: 'Streaming server may not be ready' };
          }
        } catch (error) {
          checklist.streamingInfrastructure = { status: 'warning', message: 'Cannot verify streaming server' };
        }
        updateChecklistItem('streamingInfrastructure', checklist.streamingInfrastructure);
        
        // 6. Socket.IO Connection
        if (typeof io !== 'undefined') {
          checklist.socketConnection = { status: 'success', message: 'Real-time connection ready' };
        } else {
          checklist.socketConnection = { status: 'warning', message: 'Socket.IO not available' };
        }
        updateChecklistItem('socketConnection', checklist.socketConnection);
        
        // 7. Stream Status Initialization
        checklist.streamStatus = { status: 'success', message: `Stream status: ${classData.status}` };
        updateChecklistItem('streamStatus', checklist.streamStatus);
        
        console.log('✅ Pre-Stream Checklist completed successfully');
        return { success: true, checklist };
        
      } catch (error) {
        console.error('❌ Pre-Stream Checklist failed:', error);
        return { success: false, checklist, error: error.message };
      }
    }
    
    // Generate stream key for class
    async function generateStreamKey(classId) {
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/classes/${classId}/generate-stream-key`, {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('✅ Stream key generated:', data.streamKey);
          return data.streamKey;
        }
      } catch (error) {
        console.error('❌ Failed to generate stream key:', error);
      }
      return null;
    }
    
    // Show pre-stream checklist for instructors
    function showPreStreamChecklist(checklist) {
      const checklistOverlay = document.createElement('div');
      checklistOverlay.className = 'welcome-modal show';
      checklistOverlay.id = 'preStreamChecklist';
      checklistOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title">🔍 Pre-Stream Checklist</h2>
          <div class="welcome-text">
            <p>Verifying all systems are ready for streaming...</p>
            <div id="checklistItems" style="margin: 20px 0; text-align: left;">
              ${Object.entries(checklist).map(([key, item]) => `
                <div class="checklist-item" id="checklist-${key}" style="
                  padding: 10px;
                  margin: 8px 0;
                  background: rgba(255, 255, 255, 0.05);
                  border-radius: 8px;
                  border-left: 4px solid #fbbf24;
                  display: flex;
                  align-items: center;
                ">
                  <div class="status-icon" style="margin-right: 10px; font-size: 1.2em;">⏳</div>
                  <div class="status-text">${item.message}</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closePreStreamChecklist()" disabled id="checklistCloseBtn">Please Wait...</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(checklistOverlay);
    }
    
    // Update individual checklist item
    function updateChecklistItem(key, item) {
      const checklistItem = document.getElementById(`checklist-${key}`);
      if (!checklistItem) return;
      
      const statusIcon = checklistItem.querySelector('.status-icon');
      const statusText = checklistItem.querySelector('.status-text');
      
      let color, icon;
      switch (item.status) {
        case 'success':
          color = '#22c55e';
          icon = '✅';
          break;
        case 'warning':
          color = '#fbbf24';
          icon = '⚠️';
          break;
        case 'failed':
          color = '#ef4444';
          icon = '❌';
          break;
        default:
          color = '#fbbf24';
          icon = '⏳';
      }
      
      checklistItem.style.borderLeftColor = color;
      statusIcon.textContent = icon;
      statusText.textContent = item.message;
      
      // Check if all items are complete
      setTimeout(() => {
        const allItems = document.querySelectorAll('.checklist-item .status-icon');
        const allComplete = Array.from(allItems).every(icon => 
          icon.textContent === '✅' || icon.textContent === '⚠️' || icon.textContent === '❌'
        );
        
        if (allComplete) {
          const closeBtn = document.getElementById('checklistCloseBtn');
          if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.textContent = 'Continue';
          }
        }
      }, 100);
    }
    
    // Close pre-stream checklist
    function closePreStreamChecklist() {
      const checklistOverlay = document.getElementById('preStreamChecklist');
      if (checklistOverlay) {
        checklistOverlay.remove();
      }
    }
    
    // Auto-assign class ID for students based on their enrollment
    async function autoAssignStudentClass() {
      const userRole = localStorage.getItem('role');
      if (userRole !== 'student') return null;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const userData = await response.json();
          if (userData.user.classId) {
            console.log('📚 Auto-assigned student to class:', userData.user.classId);
            localStorage.setItem('currentClassId', userData.user.classId);
            return userData.user.classId;
          }
        }
      } catch (error) {
        console.error('❌ Failed to auto-assign student class:', error);
      }
      
      return null;
    }
    
    function showWaitingMessage() {
      // Update the stream type indicator
      updateStreamTypeIndicator('Waiting for Stream...');
      
      // Create a waiting overlay
      const waitingOverlay = document.createElement('div');
      waitingOverlay.className = 'welcome-modal show';
      waitingOverlay.id = 'waitingOverlay';
      waitingOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ff9800;">⏳ Waiting for Stream</h2>
          <div class="welcome-text">
            <p>The instructor hasn't started streaming yet. The page will automatically update when the stream becomes available.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 152, 0, 0.1); border-radius: 10px; border-left: 4px solid #ff9800;">
              <strong>What's happening:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>✅ Connected to class successfully</li>
                <li>⏳ Waiting for instructor to start streaming</li>
                <li>🔄 Automatically checking for updates every 3 seconds</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closeWaitingMessage()">Continue Waiting</button>
            <button class="welcome-close" onclick="goToDashboard()" style="background: #6b7280;">Back to Dashboard</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(waitingOverlay);
    }
    
    function closeWaitingMessage() {
      const waitingOverlay = document.getElementById('waitingOverlay');
      if (waitingOverlay) {
        waitingOverlay.remove();
      }
    }
    
    // Update stream type indicator with class information
    function updateStreamTypeIndicator(streamType = 'Stream') {
      const className = localStorage.getItem('currentClassName');
      if (className) {
        streamTypeIndicator.textContent = `${className} - ${streamType}`;
      } else {
        streamTypeIndicator.textContent = streamType;
      }
    }
    
    // Automatically fetch user's assigned class ID
    async function fetchUserAssignedClass() {
      try {
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          console.log('❌ No auth token available');
          return null;
        }
        
        console.log('📡 Fetching user\'s assigned class from server...');
        
        // First, try to get user info which should include their assigned class
        const userResponse = await fetch('/api/auth/verify', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (userResponse.ok) {
          const userData = await userResponse.json();
          console.log('👤 User data:', userData.user);
          
          // Check if user has a direct class assignment
          if (userData.user.classId) {
            console.log('✅ Found direct class assignment:', userData.user.classId);
            return userData.user.classId;
          }
        }
        
        // If no direct assignment, try to get user's enrolled classes
        const classesResponse = await fetch('/api/classes/my-classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (classesResponse.ok) {
          const userClasses = await classesResponse.json();
          console.log('📚 Found user classes:', userClasses.length);
          
          if (userClasses.length > 0) {
            // Prioritize classes with active streams, then most recent
            const sortedClasses = userClasses.sort((a, b) => {
              // Live streams first
              if (a.streamStatus === 'live' && b.streamStatus !== 'live') return -1;
              if (b.streamStatus === 'live' && a.streamStatus !== 'live') return 1;
              
              // Then by most recent update
              return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            
            const selectedClass = sortedClasses[0];
            console.log('✅ Auto-selected class:', selectedClass.name, selectedClass._id);
            
            // Store class name for display
            localStorage.setItem('currentClassName', selectedClass.name);
            
            return selectedClass._id;
          }
        }
        
        // Fallback: try to get any accessible class for this user
        console.log('⚠️ No enrolled classes found, checking accessible classes...');
        const allClassesResponse = await fetch('/api/classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (allClassesResponse.ok) {
          const allClasses = await allClassesResponse.json();
          if (allClasses.length > 0) {
            // For instructors, they might have access to classes they teach
            const userRole = localStorage.getItem('role');
            if (userRole === 'instructor' || userRole === 'admin') {
              const firstClass = allClasses[0];
              console.log('✅ Instructor/Admin assigned to first available class:', firstClass._id);
              localStorage.setItem('currentClassName', firstClass.name);
              return firstClass._id;
            }
          }
        }
        
        console.log('❌ No accessible classes found');
        return null;
        
      } catch (error) {
        console.error('❌ Error fetching user assigned class:', error);
        return null;
      }
    }
    

    
    const video = document.getElementById('video');
    const webrtcVideo = document.getElementById('webrtcVideo');
    const streamTypeIndicator = document.getElementById('streamTypeIndicator');
    // const playBtn = document.getElementById('playBtn'); // Removed
    const timeline = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    
    // WebRTC Variables
    let peerConnection = null;
    let webrtcSocket = null;
    let isWebRTCMode = false;
    let classId = null;
    
    // Stream Timer for WebRTC (since WebRTC doesn't have reliable currentTime)
    let streamTimer = null;
    let streamStartTime = null;
    let streamDuration = 3600; // Default 1 hour, can be updated from server
    let isStreamPaused = false;
    let pausedAt = 0;
    const playhead = document.getElementById('playhead');
    // const fullscreenBtn = document.getElementById('fullscreenBtn'); // Removed
    const loading = document.getElementById('loading');
    // const rateBtn = document.getElementById('rateBtn'); // Removed
    // const liveBtn = document.getElementById('liveBtn'); // Removed
    // const streamMode = document.getElementById('streamMode'); // Removed
    const fileInput = document.getElementById('fileInput');
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImg = document.getElementById('thumbnailImg');
    const thumbnailTime = document.getElementById('thumbnailTime');
    
    // Skip buttons - Commented out as buttons were removed
    // document.getElementById('rewind10').onclick = () => video.currentTime -= 10;
    // document.getElementById('rewind30').onclick = () => video.currentTime -= 30;
    // document.getElementById('forward10').onclick = () => video.currentTime += 10;
    // document.getElementById('forward30').onclick = () => video.currentTime += 30;
    
    let hlsInstance = null;
    
    // Stream Timer Utility for WebRTC
    function createStreamTimer(startTime = Date.now()) {
      return {
        startTime: startTime,
        isPaused: false,
        pauseAt: 0,
        
        get currentTime() {
          if (this.isPaused) return this.pauseAt;
          return (Date.now() - this.startTime) / 1000;
        },
        
        pause() {
          this.isPaused = true;
          this.pauseAt = (Date.now() - this.startTime) / 1000;
        },
        
        resume() {
          this.isPaused = false;
          this.startTime = Date.now() - this.pauseAt * 1000;
        },
        
        reset() {
          this.startTime = Date.now();
          this.pauseAt = 0;
          this.isPaused = false;
        },
        
        setTime(seconds) {
          if (this.isPaused) {
            this.pauseAt = seconds;
          } else {
            this.startTime = Date.now() - seconds * 1000;
          }
        }
      };
    }
    
    // Get current time for either WebRTC or regular video
    function getCurrentTime() {
      if (isWebRTCMode && streamTimer) {
        return streamTimer.currentTime;
      }
      return video.currentTime || 0;
    }
    
    // Get duration for either WebRTC or regular video
    function getDuration() {
      if (isWebRTCMode) {
        return streamDuration;
      }
      return video.duration || 0;
    }
    
    // Set current time for either WebRTC or regular video
    function setCurrentTime(time) {
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, we can't actually seek, but we can adjust our timer
        // This is mainly for UI purposes
        streamTimer.setTime(time);
      } else {
        video.currentTime = time;
      }
    }

    // Thumbnail generation functionality
    let thumbnailCache = [];
    let webrtcThumbnailCache = [];
    
    function generateThumbnails() {
      const offscreen = document.createElement('canvas');
      offscreen.width = 120;
      offscreen.height = 70;
      const offCtx = offscreen.getContext('2d');

      let current = 0;
      const end = Math.floor(video.duration);

      function snapNext() {
        if (current > end) return;

        video.currentTime = current;
        video.addEventListener('seeked', function capture() {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
          const img = new Image();
          img.src = offscreen.toDataURL();
          thumbnailCache.push({ time: current, img });

          current++;
          video.removeEventListener('seeked', capture);
          setTimeout(snapNext, 200); // short delay ensures rendering stability
        }, { once: true });
      }

      snapNext();
    }
    
    // Function to get thumbnail for a specific time - Updated for both modes
    function getThumbnailForTime(time, cache = null) {
      const targetCache = cache || (isWebRTCMode ? webrtcThumbnailCache : thumbnailCache);
      
      if (targetCache.length === 0) return null;
      
      // Find the closest thumbnail
      let closest = targetCache[0];
      let minDiff = Math.abs(closest.time - time);
      
      for (let i = 1; i < targetCache.length; i++) {
        const diff = Math.abs(targetCache[i].time - time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = targetCache[i];
        }
      }
      
      return closest;
    }
    
    // Function to load WebRTC thumbnails from server
    async function loadWebRTCThumbnails() {
      if (!classId) return;
      
      try {
        console.log('📸 Loading WebRTC thumbnails...');
        webrtcThumbnailCache = [];
        
        // Generate thumbnails for every second up to stream duration
        for (let i = 0; i <= streamDuration; i++) {
          webrtcThumbnailCache.push({
            time: i,
            url: `/api/thumbnails/${classId}/${i}.jpg`, // Adjust URL based on your backend
            img: null // Will be loaded on demand
          });
        }
        
        console.log(`📸 Generated ${webrtcThumbnailCache.length} WebRTC thumbnail placeholders`);
      } catch (error) {
        console.error('❌ Error loading WebRTC thumbnails:', error);
      }
    }
    
    // WebRTC Functions
    function initializeWebRTCSocket() {
      if (webrtcSocket) return;
      
      webrtcSocket = io();
      
      webrtcSocket.on('connect', () => {
        console.log('🔌 WebRTC Socket connected');
        if (classId) {
          webrtcSocket.emit('student-join-class', { classId: classId });
        }
      });
      
      webrtcSocket.on('disconnect', () => {
        console.log('❌ WebRTC Socket disconnected');
      });
      
      webrtcSocket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Instructor started WebRTC stream:', data.mediaType);
        console.log('🔄 Current WebRTC video element:', webrtcVideo);
        console.log('🔄 Current peer connection:', peerConnection);
        
        // Set stream duration if provided
        if (data.duration) {
          streamDuration = data.duration;
        }
        
        switchToWebRTCMode();
        updateStreamTypeIndicator(`Live ${data.mediaType}`);
        
        // Load WebRTC thumbnails
        loadWebRTCThumbnails();
        
        // Show loading while waiting for WebRTC connection
        loading.style.display = 'block';
        loading.textContent = 'Connecting to live stream...';
      });
      
      webrtcSocket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Instructor stopped WebRTC stream');
        switchToFileMode();
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      });
      
      webrtcSocket.on('webrtc-offer', async (data) => {
        console.log('📡 Received WebRTC offer from instructor');
        await handleWebRTCOffer(data.offer);
      });
      
      webrtcSocket.on('webrtc-ice-candidate', async (data) => {
        console.log('🧊 Received ICE candidate from instructor');
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    async function handleWebRTCOffer(offer) {
      try {
        console.log('🔗 Creating WebRTC peer connection...');
        
        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });
        
        // Handle incoming stream
        peerConnection.ontrack = (event) => {
          console.log('📺 Received WebRTC stream:', event.streams[0]);
          console.log('📺 Stream tracks:', event.streams[0].getTracks());
          
          webrtcVideo.srcObject = event.streams[0];
          
          // Ensure we're in WebRTC mode
          switchToWebRTCMode();
          
          // Try to play the video
          webrtcVideo.play().then(() => {
            console.log('✅ WebRTC video playing');
            loading.style.display = 'none';
          }).catch(error => {
            console.error('❌ WebRTC video play failed:', error);
            // Try to play with user interaction
            webrtcVideo.muted = true;
            webrtcVideo.play().then(() => {
              console.log('✅ WebRTC video playing (muted)');
              loading.style.display = 'none';
            }).catch(e => {
              console.error('❌ WebRTC video play failed even muted:', e);
            });
          });
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            webrtcSocket.emit('webrtc-ice-candidate', {
              to: 'instructor',
              candidate: event.candidate
            });
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          console.log('🔗 WebRTC connection state:', state);
          
          if (state === 'connected') {
            console.log('✅ WebRTC connection established');
          } else if (state === 'disconnected' || state === 'failed') {
            console.log('❌ WebRTC connection lost');
            switchToFileMode();
          }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer back to instructor
        webrtcSocket.emit('webrtc-answer', {
          to: 'instructor',
          answer: answer
        });
        
        console.log('📤 Sent WebRTC answer to instructor');
      } catch (error) {
        console.error('❌ Error handling WebRTC offer:', error);
        switchToFileMode();
      }
    }
    
    function switchToWebRTCMode() {
      console.log('🔄 Switching to WebRTC mode');
      isWebRTCMode = true;
      
      // Initialize stream timer
      if (!streamTimer) {
        streamTimer = createStreamTimer();
        console.log('⏱️ Stream timer initialized');
      }
      
      // Hide regular video and show WebRTC video
      video.style.display = 'none';
      webrtcVideo.style.display = 'block';
      
      // Configure WebRTC video element
      webrtcVideo.autoplay = true;
      webrtcVideo.playsInline = true;
      webrtcVideo.controls = false; // Remove controls for custom timeline
      
      // Show timeline for WebRTC mode
      document.getElementById('timeline').style.display = 'block';
      
      updateStreamTypeIndicator('Live WebRTC Stream');
      
      // Show WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'block';
      }
      
      // Start updating WebRTC timeline
      startWebRTCTimelineUpdates();
      
      // Initialize timeline for WebRTC
      initializeWebRTCTimeline();
      
      console.log('✅ Switched to WebRTC mode - video element visible:', webrtcVideo.style.display);
    }
    
    function switchToFileMode() {
      console.log('🔄 Switching to file mode');
      isWebRTCMode = false;
      
      // Stop stream timer
      if (streamTimer) {
        streamTimer = null;
      }
      
      webrtcVideo.style.display = 'none';
      video.style.display = 'block';
      
      // Show file-based controls
      document.getElementById('timeline').style.display = 'block';
      
      updateStreamTypeIndicator('File Stream');
      
      // Hide WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'none';
      }
      
      // Stop WebRTC timeline updates
      stopWebRTCTimelineUpdates();
      
      if (webrtcVideo.srcObject) {
        webrtcVideo.srcObject = null;
      }
    }
    
    // WebRTC Timeline Update Functions
    let webrtcTimelineInterval = null;
    let timelineScrollOffset = 0;
    let isTimelineDragging = false;
    
    function startWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
      }
      
      webrtcTimelineInterval = setInterval(() => {
        if (streamTimer && !isTimelineDragging) {
          updateTimelineScrollForWebRTC();
          updateTimeDisplayForWebRTC();
          updateJumpToLiveIndicatorForWebRTC();
        }
      }, 100); // Update every 100ms for smooth timeline
    }
    
    function stopWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
        webrtcTimelineInterval = null;
      }
    }
    
    function updateTimelineScrollForWebRTC() {
      const currentTime = streamTimer.currentTime;
      const duration = streamDuration;
      const timeline = document.getElementById('timeline');
      const container = document.getElementById('timelineContainer');
      
      if (!timeline || !container || duration <= 0) return;
      
      // Calculate scroll position to keep current time centered
      const timelineWidth = timeline.offsetWidth;
      const containerWidth = container.offsetWidth;
      const timeProgress = currentTime / duration;
      
      // Calculate the scroll offset to center the current time
      const centerOffset = timelineWidth / 2;
      const targetScrollPosition = (timeProgress * containerWidth) - centerOffset;
      
      // Clamp scroll position to valid range
      const maxScroll = containerWidth - timelineWidth;
      const clampedScroll = Math.max(0, Math.min(maxScroll, targetScrollPosition));
      
      // Apply smooth transform
      container.style.transform = `translateX(-${clampedScroll}px)`;
      timelineScrollOffset = clampedScroll;
    }
    
    function updateTimeDisplayForWebRTC() {
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl && streamTimer) {
        currentTimeEl.textContent = formatTime(streamTimer.currentTime);
        totalTimeEl.textContent = formatTime(streamDuration);
      }
    }
    
    function updateJumpToLiveIndicatorForWebRTC() {
      const indicator = document.getElementById('jumpToLiveIndicator');
      
      if (!indicator || !streamTimer) return;
      
      // For WebRTC, we're always "live" unless we've manually adjusted the timer
      // Show indicator if user has scrolled back in time
      const currentTime = streamTimer.currentTime;
      const liveTime = (Date.now() - streamTimer.startTime) / 1000;
      const isAtLive = Math.abs(liveTime - currentTime) < 3;
      
      indicator.style.display = isAtLive ? 'none' : 'block';
    }
    
    function initializeWebRTCTimeline() {
      console.log('🎬 Initializing WebRTC timeline');
      
      // Clear existing timeline content
      const timelineContainer = timeline.querySelector('.timeline-container');
      if (timelineContainer) {
        timelineContainer.innerHTML = '';
      } else {
        // Create timeline container if it doesn't exist
        const container = document.createElement('div');
        container.className = 'timeline-container';
        timeline.appendChild(container);
      }
      
      // Generate timeline frames for WebRTC
      generateWebRTCTimelineFrames();
    }
    
    function generateWebRTCTimelineFrames() {
      const container = timeline.querySelector('.timeline-container');
      if (!container) return;
      
      const frameWidth = 120; // Width of each thumbnail frame
      const totalFrames = Math.ceil(streamDuration);
      const totalWidth = totalFrames * frameWidth;
      
      container.style.minWidth = `${totalWidth}px`;
      
      // Generate frames
      for (let i = 0; i < totalFrames; i++) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = `${frameWidth}px`;
        
        // Create placeholder thumbnail with proper SVG
        const img = document.createElement('div');
        img.className = 'thumbnail-placeholder';
        img.style.cssText = `
          width: 100%;
          height: calc(100% - 20px);
          background: #333;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 4px 4px 0 0;
          color: #fff;
          font-size: 12px;
          font-weight: 600;
        `;
        img.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24"></path>
          </svg>
        `;
        
        // Create time tick
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = formatTime(i);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek (for WebRTC this is just UI feedback)
        frame.addEventListener('click', () => {
          if (streamTimer) {
            streamTimer.setTime(i);
            console.log(`🎯 WebRTC timeline clicked: ${formatTime(i)}`);
          }
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        container.appendChild(frame);
      }
      
      console.log(`🎬 Generated ${totalFrames} WebRTC timeline frames`);
    }

    // Fetch class information from the backend
    async function fetchClassInfo() {
      try {
        // Get classId from URL parameters or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
        
        // If no class ID, automatically fetch user's assigned class
        if (!classId) {
          console.log('🔍 No class ID provided, fetching user\'s assigned class...');
          classId = await fetchUserAssignedClass();
          
          if (!classId) {
            console.error('❌ No class ID available');
            showErrorMessage('No Class Assignment Found', 'You are not currently enrolled in any classes. Please contact your instructor or check your enrollment status.');
            return;
          }
          
          // Store the fetched class ID for future use
          localStorage.setItem('currentClassId', classId);
          console.log('✅ Auto-assigned to class:', classId);
          
          // Update stream type indicator with class info
          updateStreamTypeIndicator();
        }
        
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('❌ Authentication failed');
            showErrorMessage('Authentication Required', 'You need to log in to access this stream. Please log in and try again.');
            return;
          } else if (response.status === 403) {
            console.error('❌ Access denied');
            showErrorMessage('Access Denied', 'You do not have permission to access this class stream. Please contact your instructor.');
            return;
          } else if (response.status === 404) {
            console.error('❌ Class not found');
            showErrorMessage('Class Not Found', 'The requested class could not be found. Please check the class ID and try again.');
            return;
          }
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('📊 Stream status data:', data);
        
        const streamKey = data.streamKey;
        const streamStatus = data.status;
        const currentSource = data.currentSource;

        console.log('🔑 StreamKey:', streamKey);
        console.log('📡 Status:', streamStatus);
        console.log('📹 Source:', currentSource);

        // Check if stream is active
        if (streamStatus !== 'live') {
          console.log('⏸️ Stream is not live, waiting for instructor...');
          loading.style.display = 'block';
          
          // Show waiting message after 10 seconds
          setTimeout(() => {
            if (loading.style.display === 'block') {
              showWaitingMessage();
            }
          }, 10000);
          
          // Retry after 3 seconds
          setTimeout(() => fetchClassInfo(), 3000);
          return;
        }

        // Handle different stream sources
        if (currentSource === 'upload' && data.session && data.session.uploadFilename) {
          // For uploaded videos, use direct video URL
          const videoUrl = `/api/stream/video/${data.session.uploadFilename}`;
          console.log('📹 Loading uploaded video:', videoUrl);
          console.log('📁 Upload filename:', data.session.uploadFilename);
          
          // Use direct video playback for uploaded files
          video.src = videoUrl;
          video.load();
          
          video.addEventListener('loadstart', () => console.log('🔄 Video load started'));
          video.addEventListener('loadeddata', () => console.log('✅ Video data loaded'));
          video.addEventListener('canplay', () => console.log('▶️ Video can play'));
          video.addEventListener('error', (e) => console.error('❌ Video error:', e));
          
          video.play().catch(e => console.log('🔇 Video autoplay prevented:', e));
          
        } else {
          // For live streams, use HLS
          const streamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          console.log('Loading HLS stream:', streamUrl);
          
          // Initialize HLS.js
          if (Hls.isSupported()) {
            hlsInstance = new Hls({
              enableWorker: true,
              lowLatencyMode: true,
              backBufferLength: 90
            });
            hlsInstance.loadSource(streamUrl);
            hlsInstance.attachMedia(video);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
              video.play();
            });
          
          // Generate thumbnails when video metadata is loaded
          video.addEventListener('loadedmetadata', function() {
            generateThumbnails();
          }, { once: true });

            hlsInstance.on(Hls.Events.ERROR, function(event, data) {
              console.error('HLS error:', data);
              if (data.fatal) {
                setTimeout(() => fetchClassInfo(), 5000); // Retry after 5 seconds
              }
            });
          } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = streamUrl;
            video.addEventListener('loadedmetadata', function() {
              video.play();
              generateThumbnails();
            });
          } else {
            console.error('HLS is not supported in this browser');
          }
        }
        
        video.addEventListener('canplay', function() {
          loading.style.display = 'none';
        });
        
        video.addEventListener('waiting', function() {
          loading.style.display = 'block';
        });
        
        video.addEventListener('playing', function() {
          loading.style.display = 'none';
        });
        
        // Initialize WebRTC socket for live streaming
        initializeWebRTCSocket();
        
        // Connect to Socket.IO for real-time updates
        if (streamKey && typeof io !== 'undefined') {
          const socket = io();
          console.log('🔌 Connecting to Socket.IO with streamKey:', streamKey);
          socket.emit('join-stream', streamKey);
          
          // Also join WebRTC room for live streaming
          socket.emit('student-join-class', { classId: classId });
          console.log('🎓 Joining WebRTC class as student:', classId);
          
          socket.on('connect', () => {
            console.log('✅ Socket.IO connected successfully');
            // Re-join rooms on reconnection
            socket.emit('join-stream', streamKey);
            socket.emit('student-join-class', { classId: classId });
          });
          
          socket.on('disconnect', () => {
            console.log('❌ Socket.IO disconnected');
          });
          
          socket.on('streamStatus', (data) => {
            console.log('📡 Stream status update:', data);
            if (data.status === 'offline') {
              // Stream ended
              if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
              }
              video.src = '';
              video.pause();
              loading.style.display = 'block';
            } else if (data.status === 'live') {
              // New stream started
              loading.style.display = 'none';
              

              if (data.source === 'upload' && data.streamUrl) {
                // Switch to uploaded video
                if (hlsInstance) {
                  hlsInstance.destroy();
                  hlsInstance = null;
                }
                video.src = data.streamUrl;
                video.load();
                video.play().catch(e => console.log('Video autoplay prevented:', e));
              } else {
                // Switch to live HLS stream
                const newStreamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
                if (hlsInstance) {
                  hlsInstance.loadSource(newStreamUrl);
                } else if (Hls.isSupported()) {
                  hlsInstance = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                  });
                  hlsInstance.loadSource(newStreamUrl);
                  hlsInstance.attachMedia(video);
                }
              }
            } else if (data.status === 'paused') {
              video.pause();
            }
          });
          
          socket.on('notice', (data) => {
            // Display instructor notice
            console.log('Instructor notice:', data.message);
            // You can add UI to display notices here
          });
        }
        
      } catch (error) {
        console.error('Error fetching class information:', error);
        // Retry after 5 seconds
        setTimeout(() => fetchClassInfo(), 5000);
      }
    }
    
    // Debug information on page load
    console.log('🚀 SMX Stream page loaded');
    console.log('🔍 Checking for class ID and authentication...');
    
    const urlParams = new URLSearchParams(window.location.search);
    const urlClassId = urlParams.get('classId');
    const storedClassId = localStorage.getItem('currentClassId');
    const authToken = localStorage.getItem('token');
    
    console.log('📋 URL Class ID:', urlClassId);
    console.log('💾 Stored Class ID:', storedClassId);
    console.log('🔐 Auth Token:', authToken ? 'Present' : 'Missing');
    
    if (!urlClassId && !storedClassId) {
      console.log('🔍 No class ID found - will automatically fetch user\'s assigned class');
    }
    
    if (!authToken) {
      console.warn('⚠️ No authentication token found - this will likely cause issues');
    }
    
    // Call the function to fetch class info and load the stream
    fetchClassInfo();
    
    // Play/pause toggle - Commented out as button was removed
    // playBtn.addEventListener('click', function() {
    //   if (video.paused) {
    //     video.play();
    //   } else {
    //     video.pause();
    //   }
    //   updatePlayButton();
    // });
    
    // function updatePlayButton() {
    //   playBtn.textContent = video.paused ? 'Play' : 'Pause';
    // }
    // Timeline click functionality is already implemented above
    // WebRTC timeline is handled by the WebRTC timeline update functions
    
    
    // Timeline hover for thumbnail preview - WebRTC only
    timeline.addEventListener('mousemove', function(e) {
      const duration = getDuration();
      
      if (!duration || webrtcThumbnailCache.length === 0) return;
      
      const rect = timeline.getBoundingClientRect();
      const pos = (e.clientX - rect.left) / rect.width;
      const hoverTime = pos * duration;
      
      const thumbnail = getThumbnailForTime(hoverTime);
      if (thumbnail) {
        thumbnailImg.src = thumbnail.img ? thumbnail.img.src : thumbnail.url;
        thumbnailTime.textContent = formatTime(hoverTime);
        
        // Position the preview
        const previewX = e.clientX - rect.left;
        thumbnailPreview.style.left = previewX + 'px';
        thumbnailPreview.style.display = 'block';
      }
    });
    
    timeline.addEventListener('mouseleave', function() {
      thumbnailPreview.style.display = 'none';
    });
    
    // Helper function to format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Fullscreen
    fullscreenBtn.addEventListener('click', function() {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.msRequestFullscreen) {
        video.msRequestFullscreen();
      }
    });
    
    // ⏩ Playback rate toggle - Commented out as button was removed
    // rateBtn.addEventListener('click', function() {
    //   video.playbackRate = video.playbackRate === 1 ? 2 : video.playbackRate === 2 ? 0.5 : 1;
    //   rateBtn.textContent = video.playbackRate + 'x';
    // });
    
    // 🔄 LIVE button - Commented out as button was removed
    // liveBtn.addEventListener('click', function() {
    //   if (video.duration) {
    //     video.currentTime = video.duration - 0.05;
    //   }
    // });
    
    // Update live status - Commented out as button was removed
    // setInterval(() => {
    //   if (video.duration) {
    //     const live = Math.abs(video.duration - video.currentTime) < 2;
    //     liveBtn.style.display = live ? 'none' : 'inline-block';
    //   }
    // }, 500);
    
    // 📦 Stream mode selector - Commented out as selector was removed
    // streamMode.addEventListener('change', function() {
    //   if (streamMode.value === 'local') {
    //     fileInput.click();
    //   } else {
    //     fetchClassInfo();
    //   }
    // });
    
    fileInput.addEventListener('change', function() {
      const file = fileInput.files[0];
      if (file) {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        const url = URL.createObjectURL(file);
        video.src = url;
        loading.style.display = 'block';
        
        // Generate thumbnails for local file
        video.addEventListener('loadedmetadata', function() {
          generateThumbnails();
        }, { once: true });
      }
    });
    
    // ⌨️ Keyboard shortcuts
    window.addEventListener('keydown', function(e) {
      if (e.key === 'k' || e.key === ' ') {
        e.preventDefault();
        // playBtn.click(); // Commented out as button was removed
        // Toggle play/pause directly
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
      else if (e.key === 'j') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'l') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'L') { // Capital L to jump to live
        e.preventDefault();
        jumpToLive();
      }
      else if (e.key === 'f') {
        // fullscreenBtn.click(); // Commented out as button was removed
        // Request fullscreen directly
        if (video.requestFullscreen) {
          video.requestFullscreen();
        } else if (video.webkitRequestFullscreen) {
          video.webkitRequestFullscreen();
        } else if (video.msRequestFullscreen) {
          video.msRequestFullscreen();
        }
      }
      else if (e.key === 'm') {
        webrtcVideo.muted = !webrtcVideo.muted;
      }
      else if (e.key === 'ArrowLeft') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 5);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'ArrowRight') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 5);
          streamTimer.setTime(newTime);
        }
      }
    });
    
    // Enhanced video event listeners
    video.addEventListener('playing', function() {
      loading.style.display = 'none';
      // playBtn.textContent = 'Pause'; // Commented out as button was removed
    });
    
    video.addEventListener('pause', function() {
      // playBtn.textContent = 'Play'; // Commented out as button was removed
    });

    // Advanced Video Timeline Component
    class VideoTimeline {
      constructor(videoId, timelineId) {
        console.log('VideoTimeline constructor called with:', videoId, timelineId);
        this.video = document.getElementById(videoId);
        this.timeline = document.getElementById(timelineId);
        this.scrubber = document.getElementById('scrubber');
        console.log('Elements found:', {
          video: this.video,
          timeline: this.timeline,
          scrubber: this.scrubber
        });
        this.thumbnails = [];
        this.zoomLevel = 1;
        this.visibleDuration = 60; // seconds visible at zoom level 1
        this.thumbnailInterval = 2; // seconds between thumbnails
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartTime = 0;
        
        this.init();
      }

      init() {
        console.log('VideoTimeline init called');
        if (!this.video || !this.timeline) {
          console.log('Missing video or timeline element');
          return;
        }
        
        // Create basic timeline structure immediately
        this.createBasicTimeline();
        
        // Wait for video metadata to load
        this.video.addEventListener('loadedmetadata', () => {
          console.log('Video metadata loaded, generating thumbnails');
          this.generateThumbnails();
          this.setupEventListeners();
        });

        // If metadata is already loaded
        if (this.video.readyState >= 1) {
          console.log('Video metadata already loaded');
          this.generateThumbnails();
          this.setupEventListeners();
        }
      }

      createBasicTimeline() {
        console.log('Creating basic timeline structure');
        // Create a basic timeline with time markers even without video duration
        const container = document.createElement('div');
        container.className = 'timeline-container';
        container.id = 'timeline-container';
        this.timeline.appendChild(container);
        
        // Add some basic time markers (0, 30s, 1min, etc.)
        for (let time = 0; time <= 300; time += 30) { // 5 minutes worth
          const frame = this.createTimeMarker(time);
          container.appendChild(frame);
        }
      }

      createTimeMarker(time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = '80px';
        frame.style.minWidth = '80px';
        
        // Create a simple placeholder
        const placeholder = document.createElement('div');
        placeholder.style.width = '100%';
        placeholder.style.height = 'calc(100% - 20px)';
        placeholder.style.background = 'linear-gradient(135deg, #1e293b, #0f172a)';
        placeholder.style.borderRadius = '4px 4px 0 0';
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
        placeholder.style.color = '#70b8ff';
        placeholder.style.fontSize = '10px';
        placeholder.textContent = this.formatTime(time);
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(placeholder);
        frame.appendChild(tick);
        
        return frame;
      }

      async generateThumbnails() {
        console.log('generateThumbnails called');
        const duration = this.video.duration;
        console.log('Video duration:', duration);
        if (!duration) {
          console.log('No duration available, skipping thumbnail generation');
          return;
        }

        // Clear existing container and create new one for thumbnails
        const existingContainer = this.timeline.querySelector('.timeline-container');
        if (existingContainer) {
          existingContainer.remove();
        }
        
        const container = document.createElement('div');
        container.className = 'timeline-container';
        this.timeline.appendChild(container);
        console.log('Timeline container created and added');

        // Generate thumbnails every 2 seconds
        for (let time = 0; time < duration; time += this.thumbnailInterval) {
          console.log('Generating thumbnail for time:', time);
          const thumbnail = await this.captureThumbnail(time);
          const frame = this.createThumbnailFrame(thumbnail, time);
          container.appendChild(frame);
          this.thumbnails.push({ element: frame, time: time });
        }

        console.log('Generated', this.thumbnails.length, 'thumbnails');
        this.updateTimelineWidth();
      }

      async captureThumbnail(time) {
        return new Promise((resolve) => {
          // For now, create a placeholder thumbnail
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 160;
          canvas.height = 90;
          
          // Create a simple gradient placeholder
          const gradient = ctx.createLinearGradient(0, 0, 160, 90);
          gradient.addColorStop(0, '#1e293b');
          gradient.addColorStop(1, '#0f172a');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 160, 90);
          
          // Add time text
          ctx.fillStyle = '#70b8ff';
          ctx.font = '12px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(this.formatTime(time), 80, 50);
          
          resolve(canvas.toDataURL());
        });
      }

      createThumbnailFrame(thumbnailSrc, time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        
        const img = document.createElement('img');
        img.src = thumbnailSrc;
        img.alt = `Frame at ${this.formatTime(time)}`;
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek
        frame.addEventListener('click', () => {
          this.video.currentTime = time;
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        return frame;
      }

      setupEventListeners() {
        // Update scrubber position on time update (only when not dragging)
        this.video.addEventListener('timeupdate', () => {
          if (!this.isDragging) {
            this.updateScrubberPosition();
          }
        });

        // Zoom with mouse wheel
        this.timeline.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
          this.zoomLevel *= zoomFactor;
          this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
          this.updateTimelineWidth();
        });

        // Scrubber drag functionality
        this.setupScrubberDrag();

        // Click on timeline to seek
        this.timeline.addEventListener('click', (e) => {
          if (e.target === this.timeline || e.target.classList.contains('timeline-container')) {
            this.seekToPosition(e);
          }
        });
      }

      setupScrubberDrag() {
        // Mouse events
        this.scrubber.addEventListener('mousedown', (e) => {
          this.startDrag(e);
        });

        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            this.handleDrag(e);
          }
        });

        document.addEventListener('mouseup', () => {
          this.endDrag();
        });

        // Touch events for mobile
        this.scrubber.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.startDrag(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
          if (this.isDragging) {
            e.preventDefault();
            this.handleDrag(e.touches[0]);
          }
        });

        document.addEventListener('touchend', () => {
          this.endDrag();
        });
      }

      startDrag(event) {
        this.isDragging = true;
        this.dragStartX = event.clientX;
        this.dragStartTime = this.video.currentTime;
        this.scrubber.classList.add('dragging');
        
        // Pause video during drag for smoother scrubbing
        this.wasPlaying = !this.video.paused;
        this.video.pause();
      }

      handleDrag(event) {
        if (!this.isDragging) return;

        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        // Calculate new time based on position
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        // Update video time and scrubber position
        this.video.currentTime = newTime;
        this.updateScrubberPosition();
        
        // Show time tooltip during drag
        this.showTimeTooltip(event.clientX, newTime);
      }

      endDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.scrubber.classList.remove('dragging');
        this.hideTimeTooltip();
        
        // Resume playback if it was playing before drag
        if (this.wasPlaying) {
          this.video.play();
        }
      }

      seekToPosition(event) {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        this.video.currentTime = newTime;
      }

      showTimeTooltip(x, time) {
        let tooltip = document.getElementById('scrubber-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.id = 'scrubber-tooltip';
          tooltip.style.cssText = `
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
          `;
          document.body.appendChild(tooltip);
        }
        
        tooltip.textContent = this.formatTime(time);
        tooltip.style.left = `${x - 25}px`;
        tooltip.style.top = `${this.timeline.getBoundingClientRect().top - 30}px`;
        tooltip.style.display = 'block';
      }

      hideTimeTooltip() {
        const tooltip = document.getElementById('scrubber-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
      }

      updateScrubberPosition() {
        if (!this.video.duration) return;
        
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const progress = this.video.currentTime / this.video.duration;
        const timelineWidth = container.offsetWidth;
        const scrubberPosition = progress * timelineWidth;
        
        this.scrubber.style.left = `${scrubberPosition}px`;
        
        // Auto-scroll to keep scrubber visible (only when not dragging)
        if (!this.isDragging) {
          const timelineScrollLeft = this.timeline.scrollLeft;
          const timelineVisibleWidth = this.timeline.offsetWidth;
          
          if (scrubberPosition < timelineScrollLeft || scrubberPosition > timelineScrollLeft + timelineVisibleWidth) {
            this.timeline.scrollLeft = scrubberPosition - timelineVisibleWidth / 2;
          }
        }
      }

      updateTimelineWidth() {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const frameWidth = 160 * this.zoomLevel;
        const totalFrames = this.thumbnails.length;
        const totalWidth = totalFrames * frameWidth;
        
        container.style.minWidth = `${totalWidth}px`;
        
        // Update frame widths
        this.thumbnails.forEach(({ element }) => {
          element.style.width = `${frameWidth}px`;
        });
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      zoom(factor) {
        this.zoomLevel *= factor;
        this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        this.updateTimelineWidth();
      }
    }

    // Global functions for video controls
    function togglePlayPause() {
      const video = document.getElementById('video');
      const playPauseBtn = document.querySelector('.play-pause-btn');
      
      if (video.paused) {
        video.play();
        playPauseBtn.innerHTML = '<span>⏸</span>';
      } else {
        video.pause();
        playPauseBtn.innerHTML = '<span>▶</span>';
      }
    }

    function rewindVideo() {
      if (streamTimer) {
        // For WebRTC, adjust the timer (UI feedback only)
        const newTime = Math.max(0, streamTimer.currentTime - 10);
        streamTimer.setTime(newTime);
        console.log(`⏪ WebRTC rewind to ${formatTime(newTime)}`);
      }
    }

    function forwardVideo() {
      if (streamTimer) {
        // For WebRTC, adjust the timer (UI feedback only)
        const newTime = Math.min(streamDuration, streamTimer.currentTime + 10);
        streamTimer.setTime(newTime);
        console.log(`⏩ WebRTC forward to ${formatTime(newTime)}`);
      }
    }

    function jumpToLive() {
      if (streamTimer) {
        // For WebRTC, reset timer to current live time
        streamTimer.reset();
        
        // Reset timeline scroll to show live position
        const container = document.getElementById('timelineContainer');
        if (container) {
          container.style.transform = 'translateX(0px)';
          timelineScrollOffset = 0;
        }
        
        // Resume auto-scrolling
        isTimelineDragging = false;
        
        console.log('🔴 Jumped to live WebRTC stream');
      }
      
      // Hide the jump to live indicator
      const indicator = document.getElementById('jumpToLiveIndicator');
      if (indicator) {
        indicator.style.display = 'none';
      }
    }

    // Monitor live status and show/hide jump to live indicator
    function updateLiveStatus() {
      const video = document.getElementById('video');
      const indicator = document.getElementById('jumpToLiveIndicator');
      
      if (!video || !indicator || !video.duration) return;
      
      // Check if user is within 3 seconds of live edge
      const isAtLive = Math.abs(video.duration - video.currentTime) < 3;
      
      // Show indicator if not at live edge, hide if at live edge
      indicator.style.display = isAtLive ? 'none' : 'block';
    }

    // Update live status every 500ms
    setInterval(updateLiveStatus, 500);

    function zoomTimeline(factor) {
      if (window.videoTimeline) {
        window.videoTimeline.zoom(factor);
      }
    }

    // Update time display
    function updateTimeDisplay() {
      const video = document.getElementById('video');
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl) {
        currentTimeEl.textContent = formatTime(video.currentTime);
        totalTimeEl.textContent = formatTime(video.duration || 0);
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Initialize advanced timeline
    setTimeout(() => {
      console.log('Initializing VideoTimeline...');
      window.videoTimeline = new VideoTimeline('video', 'timeline');
      console.log('VideoTimeline initialized:', window.videoTimeline);
      
      // Set up video event listeners for time display
      const video = document.getElementById('video');
      if (video) {
        video.addEventListener('timeupdate', updateTimeDisplay);
        video.addEventListener('loadedmetadata', updateTimeDisplay);
        video.addEventListener('play', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>⏸</span>';
        });
        video.addEventListener('pause', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>▶</span>';
        });
      }
    }, 1000);

    const videoElement = document.getElementById('video');
    const currentTimeDisplay = document.getElementById('currentTime');
    const totalTimeDisplay = document.getElementById('totalTime');

    // Play/Pause functionality for WebRTC
    function togglePlayPause() {
      const playPauseBtn = document.querySelector('.play-pause-btn');
      
      if (streamTimer) {
        // For WebRTC, we can't actually pause the stream, but we can pause our timer
        if (!streamTimer.isPaused) {
          streamTimer.pause();
          playPauseBtn.innerHTML = Icons.play;
          console.log('⏸️ WebRTC stream timer paused');
        } else {
          streamTimer.resume();
          playPauseBtn.innerHTML = Icons.pause;
          console.log('▶️ WebRTC stream timer resumed');
        }
      }
    }

    // WebRTC stream uses its own timer-based time display updates
    // Time display is handled by updateTimeDisplayForWebRTC() function

    // Rewind functionality
    function rewindVideo() {
      videoElement.currentTime -= 10;
    }

    // Fast forward functionality
    function forwardVideo() {
      videoElement.currentTime += 10;
    }

    // Jump to live functionality
    function jumpToLive() {
      videoElement.currentTime = videoElement.duration;
    }
  </script>
</body>
</html>