<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SMX Stream</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="/socket.io/socket.io.js"></script>
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      --secondary-gradient: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      --accent-gradient: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
      --dark-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a202c 100%);
      --card-gradient: linear-gradient(145deg, #2d3748 0%, #1a202c 100%);
      --steel-gradient: linear-gradient(135deg, #4a5568 0%, #718096 100%);
      --glass-bg: rgba(74, 85, 104, 0.1);
      --glass-border: rgba(74, 85, 104, 0.2);
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
      --text-accent: #2d3748;
      --shadow-primary: 0 20px 40px rgba(0, 0, 0, 0.4);
      --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.6);
      --shadow-glow: 0 0 30px rgba(74, 85, 104, 0.3);
      --shadow-glow-accent: 0 0 40px rgba(229, 62, 62, 0.4);
      --border-radius: 20px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      --bg: #0f172a;
      --fg: #f0f0f0;
      --accent: #000000;
      --track: #1e293b;
      --hover: rgba(255, 255, 255, 0.1);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--dark-gradient);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      line-height: 1.6;
    }

    /* Animated background particles */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(26, 26, 26, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(51, 51, 51, 0.1) 0%, transparent 50%);
      z-index: -1;
      animation: float 20s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      33% { transform: translateY(-20px) rotate(1deg); }
      66% { transform: translateY(10px) rotate(-1deg); }
    }
    
    .navbar {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      margin: 24px;
      padding: 1rem 0;
      flex-shrink: 0;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .navbar-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      display: flex;
      align-items: center;
      color: var(--fg);
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
    }
    
    .logo span {
      margin-right: 10px;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1rem;
    }
    
    .btn {
      font-size: 1rem;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
      padding: 0.75rem 1.5rem;
      border-radius: 15px;
      cursor: pointer;
      text-decoration: none;
      transition: var(--transition);
      font-weight: 500;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: var(--primary-gradient);
      transition: var(--transition);
      z-index: -1;
    }

    .btn:hover::before {
      left: 0;
    }
    
    .btn:hover {
      color: white;
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: rgba(0, 0, 0, 0.5);
    }
    
    .btn-primary {
      background: var(--primary-gradient);
      border-color: var(--accent);
      color: white;
    }
    
    .btn-primary:hover {
      background: var(--secondary-gradient);
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 24px 24px 24px;
    }
    
    .player-wrapper {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .video-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      border-radius: 24px 24px 0 0;
      box-shadow: var(--shadow-glow), inset 0 0 50px rgba(74, 85, 104, 0.1);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
    }
    
    .video-container:hover {
      box-shadow: var(--shadow-glow), inset 0 0 50px rgba(74, 85, 104, 0.2);
      border-color: rgba(74, 85, 104, 0.4);
    }
    
    .video-container.screenshot-mode {
      border-color: rgba(56, 161, 105, 0.8);
      box-shadow: 
        0 0 30px rgba(56, 161, 105, 0.6),
        inset 0 0 50px rgba(56, 161, 105, 0.1);
      animation: screenshotPulse 0.5s ease-in-out infinite alternate;
    }
    
    @keyframes screenshotPulse {
      0% { border-color: rgba(56, 161, 105, 0.8); }
      100% { border-color: rgba(56, 161, 105, 1); }
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 24px 24px 0 0;
    }

    #timeline {
      flex-shrink: 0;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 0 0 24px 24px;
      position: relative;
      overflow: hidden;
    }
    
    #timelineCanvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
      border-radius: 0 0 24px 24px;
    }
    
    .timeline-hover-label {
      position: fixed;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      font-family: monospace;
      pointer-events: none;
      z-index: 1000;
      display: none;
      transform: translateX(-50%) translateY(-30px);
    }
    
    .timeline-zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      gap: 5px;
      z-index: 10;
    }
    
    .timeline-zoom-btn {
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    
    .timeline-zoom-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: rgba(255, 255, 255, 0.4);
    }
    
    /* Instructor Controls */
    .instructor-controls {
      position: absolute;
      top: 20px;
      left: 20px;
      display: flex;
      align-items: center;
      gap: 15px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
      padding: 10px 15px;
      border-radius: 12px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .instructor-btn {
      background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
      border: none;
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .instructor-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(34, 197, 94, 0.3);
    }
    
    .instructor-btn:active {
      transform: translateY(0);
    }
    
    #stopStreamBtn {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }
    
    #stopStreamBtn:hover {
      box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
    }
    
    .viewer-count {
      color: white;
      font-size: 14px;
      font-weight: 600;
      background: rgba(255, 255, 255, 0.1);
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Role Indicator */
    .role-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 12px;
      font-weight: 600;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 100;
    }
    
    .role-indicator.instructor {
      background: rgba(34, 197, 94, 0.8);
      border-color: rgba(34, 197, 94, 0.3);
    }
    
    .role-indicator.student {
      background: rgba(59, 130, 246, 0.8);
      border-color: rgba(59, 130, 246, 0.3);
    }

    /* Video Overlay Controls - Bottom Center */
    .video-controls-overlay {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 30;
    }

    .video-container:hover .video-controls-overlay {
      opacity: 1;
      pointer-events: all;
    }

    .video-control-btn {
      background: var(--card-gradient);
      border: 2px solid var(--glass-border);
      color: white;
      font-size: 1.5rem;
      transition: var(--transition);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    .video-control-btn:hover {
      background: var(--steel-gradient);
      border-color: rgba(74, 85, 104, 0.6);
      transform: scale(1.1) translateY(-2px);
      box-shadow: var(--shadow-glow), 0 12px 30px rgba(0, 0, 0, 0.5);
    }
    
    .video-control-btn:active {
      transform: scale(1.05) translateY(0);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .video-control-btn svg {
      transition: all 0.3s ease;
    }
    
    .video-control-btn:hover svg {
      transform: scale(1.1);
    }
    
    /* Global SVG icon styling */
    svg {
      flex-shrink: 0;
    }
    
    /* Sync Status Styling */
    .sync-status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      transition: all 0.3s ease;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .sync-status.live {
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.2), rgba(22, 163, 74, 0.3));
      border-color: rgba(34, 197, 94, 0.4);
      color: #22c55e;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.3);
    }
    
    .sync-status.behind {
      background: linear-gradient(135deg, rgba(251, 146, 60, 0.2), rgba(249, 115, 22, 0.3));
      border-color: rgba(251, 146, 60, 0.4);
      color: #fb923c;
      box-shadow: 0 0 20px rgba(251, 146, 60, 0.3);
    }
    
    .sync-status .sync-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      animation: pulse 2s infinite;
    }
    
    .sync-status.live .sync-indicator {
      background: #22c55e;
    }
    
    .sync-status.behind .sync-indicator {
      background: #fb923c;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.2); }
    }
    
    .logo svg {
      transition: all 0.3s ease;
    }
    
    .logo:hover svg {
      transform: rotate(5deg) scale(1.1);
    }
    

    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .play-pause-btn {
      width: 80px;
      height: 80px;
      font-size: 1.5rem;
    }



    /* Zoom Toggle and Fullscreen Controls - Bottom Right */
    .video-utility-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 0.75rem;
      align-items: center;
      z-index: 30;
    }

    .zoom-toggle-btn {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .zoom-toggle-btn.active {
      background: var(--primary-gradient);
      border-color: var(--accent);
    }

    .zoom-toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .fullscreen-btn {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fullscreen-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    /* Clock Time Display - Bottom Left */
    .clock-display {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-family: monospace;
      font-size: 0.9rem;
      color: white;
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      z-index: 30;
    }

    .clock-display.not-live {
      color: rgba(255, 255, 255, 0.7);
    }

    /* Hide default video controls */
    .video-container video::-webkit-media-controls {
      display: none !important;
    }

    .video-container video::-moz-media-controls {
      display: none !important;
    }

    .video-container video {
      outline: none;
    }
    
    .video-info {
      padding: 1rem 2rem;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    
    .video-title {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .video-description {
      color: rgba(255,255,255,0.7);
    }
    
    .controls {
      display: flex;
      padding: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 0;
      border-top: none;
      gap: 0;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    #timeline {
      position: relative;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      margin: 1rem 0;
      flex: none;
    }

    .timeline-viewport {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #timeline-track {
      position: absolute;
      top: 24px;
      left: 0;
      height: calc(100% - 24px);
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    .timeline-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: stretch;
      min-width: 200%;
    }

    /* Time Hash Styles */
    #time-hashes {
      position: absolute;
      top: 0;
      height: 24px;
      width: 100%;
      display: flex;
      align-items: end;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
      font-family: monospace;
      z-index: 10;
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    .time-tick {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
    }

    .time-tick-line {
      width: 1px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      margin-bottom: 2px;
    }

    .time-tick-label {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    /* Fixed Scrubber in Center */
    .timeline-scrubber {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, #ff4757 0%, #e53e3e 100%);
      border-radius: 2px;
      z-index: 20;
      box-shadow: 
        0 0 20px rgba(255, 71, 87, 0.8),
        0 0 40px rgba(255, 71, 87, 0.4),
        0 0 60px rgba(255, 71, 87, 0.2);
      pointer-events: none;
      animation: scrubberPulse 2s ease-in-out infinite alternate;
    }
    
    @keyframes scrubberPulse {
      0% {
        box-shadow: 
          0 0 20px rgba(255, 71, 87, 0.8),
          0 0 40px rgba(255, 71, 87, 0.4),
          0 0 60px rgba(255, 71, 87, 0.2);
      }
      100% {
        box-shadow: 
          0 0 30px rgba(255, 71, 87, 1),
          0 0 60px rgba(255, 71, 87, 0.6),
          0 0 90px rgba(255, 71, 87, 0.3);
      }
    }

    .timeline-scrubber::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .timeline-scrubber::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }



    .thumbnail-frame {
      position: relative;
      height: 100%;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
    }

    .thumbnail-frame:hover {
      transform: scale(1.02);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(112, 184, 255, 0.3);
    }

    .thumbnail-frame img {
      width: 100%;
      height: calc(100% - 20px);
      object-fit: cover;
      border-radius: 4px 4px 0 0;
    }

    .time-tick {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      border-radius: 0 0 4px 4px;
    }
    
    #scrubber {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 100%;
      background: var(--primary-gradient);
      z-index: 100;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      pointer-events: none; /* Disable dragging */
    }

    #scrubber::before {
      content: '';
      position: absolute;
      top: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }

    #scrubber::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }
    
    .thumbnail-preview {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 12px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      box-shadow: var(--shadow-primary);
    }
    
    .thumbnail-preview img {
      width: 120px;
      height: 70px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .thumbnail-preview .time-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-family: monospace;
      font-weight: 600;
      background: var(--glass-bg);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid var(--glass-border);
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--accent);
      border-right: 4px solid rgba(0, 0, 0, 0.6);
      border-radius: 50%;
      animation: spin 1s infinite linear;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-primary);
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    

    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1.05);
      }
    }
    
    .select-enhanced {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .select-enhanced option {
      background: rgba(28, 28, 28, 0.95);
      color: white;
      padding: 8px;
    }


    
    /* Welcome Modal Styles */
    .welcome-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .welcome-modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .welcome-content {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 2.5rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: var(--shadow-primary);
      position: relative;
      animation: modalSlideIn 0.4s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .welcome-title {
      font-size: 2rem;
      font-weight: bold;
      color: var(--text-primary);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .welcome-text {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    
    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }
    
    .welcome-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .welcome-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .welcome-close {
      background: var(--primary-gradient);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow-primary);
    }
    
    .welcome-close:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      background: var(--secondary-gradient);
    }
    
    .welcome-close:active {
      transform: translateY(0);
    }
    
    /* Stream Type Indicator */
    .stream-type-indicator {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* WebRTC Video Styling */
    #webrtcVideo {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 0;
      object-fit: cover;
    }
    
    /* Notification Animations */
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    /* Enhanced Clock Display */
    .clock-display {
      font-family: 'Courier New', monospace;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .clock-display.not-live {
      background: rgba(107, 114, 128, 0.8);
    }
    
    /* Behind Live Indicator */
    .behind-live-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      z-index: 1000;
      animation: pulse-warning 2s infinite;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }
    
    @keyframes pulse-warning {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 0.6; }
    }
    
    /* LIVE Button Pulse Animation */
    .live-button-pulse {
      animation: pulse-live 1.5s infinite !important;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.6) !important;
    }
    
    @keyframes pulse-live {
      0%, 100% { 
        background: #22c55e !important;
        transform: scale(1);
      }
      50% { 
        background: #16a34a !important;
        transform: scale(1.05);
      }
    }
    
    /* Enhanced Timeline Canvas */
    #timelineCanvas {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }
    
    #timelineCanvas:hover {
      cursor: crosshair;
    }
    
    #timelineCanvas.dragging {
      cursor: grabbing !important;
    }
    
    /* Stream Status Overlay */
    .stream-status-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.8);
      font-size: 1.2rem;
      font-weight: 500;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      letter-spacing: 0.5px;
      user-select: none;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .stream-status-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }
    
    .stream-status-overlay.paused {
      color: rgba(255, 71, 87, 0.9);
      animation: pulse-warning 2s infinite;
    }
    
    /* Sync Status Indicator */
    .sync-status {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--card-gradient);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      z-index: 25;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .sync-status.live {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
      border-color: rgba(56, 161, 105, 0.5);
      box-shadow: 
        var(--shadow-glow-accent),
        0 0 20px rgba(56, 161, 105, 0.6),
        0 4px 15px rgba(0, 0, 0, 0.3);
      animation: livePulse 2s ease-in-out infinite alternate;
    }
    
    .sync-status.behind {
      background: linear-gradient(135deg, #d69e2e 0%, #b7791f 100%);
      border-color: rgba(214, 158, 46, 0.5);
      box-shadow: 
        0 0 20px rgba(214, 158, 46, 0.4),
        0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes livePulse {
      0% {
        box-shadow: 
          0 0 20px rgba(56, 161, 105, 0.6),
          0 4px 15px rgba(0, 0, 0, 0.3);
      }
      100% {
        box-shadow: 
          0 0 30px rgba(56, 161, 105, 0.8),
          0 0 50px rgba(56, 161, 105, 0.4),
          0 4px 15px rgba(0, 0, 0, 0.3);
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-content">
        <a href="/" class="logo">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 10px;">
            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
            <path d="M2 17l10 5 10-5"></path>
            <path d="M2 12l10 5 10-5"></path>
          </svg>
          SMX Stream
        </a>
        
        <div class="nav-buttons">
          <a href="dashboard.html" class="btn">Dashboard</a>
          <a href="#" class="btn">Settings</a>
        </div>
      </div>
    </div>
  </nav>
  
  <div class="main-content">
    <div class="player-wrapper">
        <div class="video-container">

          
          <!-- Video Elements -->
          <video id="video" autoplay muted style="display:none;"></video>
          <video id="webrtcVideo" autoplay playsinline muted style="display:block; width:100%; height:100%; background:#000;"></video>
          
          <!-- Stream Status Overlay -->
          <div id="streamStatusText" class="stream-status-overlay">
            Instructor Will Start Stream Soon
          </div>
          
          <div class="loading-spinner" id="loading"></div>
          <div class="stream-type-indicator" id="streamTypeIndicator">WebRTC Stream</div>
          <div class="webrtc-status" id="webrtcStatus" style="display:none; position:absolute; top:60px; right:20px; background:rgba(139, 92, 246, 0.9); color:white; padding:8px 12px; border-radius:6px; font-size:12px; font-weight:600; display:flex; align-items:center; gap:6px;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
            LIVE WebRTC
          </div>
          
          <!-- Sync Status Indicator -->
          <div class="sync-status" id="syncStatus" style="display:none;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
            <span id="syncStatusText">SYNCED</span>
          </div>
          
          <!-- Video Overlay Controls - Bottom Center -->
          <div class="video-controls-overlay">
            <!-- Rewind Button -->
            <button class="video-control-btn rewind-btn" onclick="rewindVideo()" title="Rewind 10s">
              ⏪
            </button>
            
            <!-- Play/Pause Button -->
            <button class="video-control-btn play-pause-btn" id="playPauseBtn" onclick="togglePlayPause()" title="Play/Pause">
              ⏸
            </button>
            
            <!-- Fast Forward Button -->
            <button class="video-control-btn forward-btn" onclick="forwardVideo()" title="Forward 10s">
              ⏩
            </button>
          </div>
          
          <!-- Zoom Toggle and Fullscreen - Bottom Right -->
          <div class="video-utility-controls">
            <button class="zoom-toggle-btn" id="jumpToLiveBtn" onclick="jumpToLive()" title="Jump to Live" style="display:none; background: #22c55e; border-color: #16a34a;">
              GO LIVE
            </button>
            <button class="zoom-toggle-btn" id="zoomToggleBtn" onclick="toggleZoomMode()" title="Toggle Timeline Zoom">
              Zoom
            </button>
            <button class="fullscreen-btn" onclick="toggleFullscreen()" title="Fullscreen">
              ⛶
            </button>
          </div>
          
          <!-- Clock Time Display - Bottom Left -->
          <div class="clock-display" id="clockDisplay">
            --:--:--
          </div>
          
          <!-- Role Indicator - Bottom Right -->
          <div class="role-indicator" id="roleIndicator">
            🔍 Detecting role...
          </div>
          
          <!-- Behind Live Indicator - Top Right -->
          <div class="behind-live-indicator" id="behindLiveIndicator" style="display:none;">
            📡 You are <span id="behindLiveSeconds">0</span> seconds behind live
          </div>
          
          <!-- Instructor Controls - Top Left -->
          <div class="instructor-controls" id="instructorControls" style="display:none;">
            <button class="instructor-btn" id="startStreamBtn" onclick="startScreenShare()">
              📺 Go Live
            </button>
            <button class="instructor-btn" id="stopStreamBtn" onclick="stopScreenShare()" style="display:none;">
              ⏹️ Stop Stream
            </button>
            <div class="viewer-count">
              👥 <span id="viewerCount">0</span> viewers
            </div>
          </div>
        </div>
        


        
        <!-- Timeline (flush with video, no spacing) -->
        <div class="controls">
          <div id="timeline">
            <div class="timeline-viewport">
              <!-- Time Hash Ticks -->
              <div id="time-hashes" class="absolute top-0 h-6 w-full flex items-end text-xs text-gray-400 font-mono z-10">
                <!-- Time hash ticks will be generated here -->
              </div>
              
              <!-- Timeline Track -->
              <div id="timeline-track" class="absolute top-6 left-0 h-26 flex">
                <div class="timeline-container" id="timelineContainer">
                  <!-- Timeline frames will be generated here -->
                </div>
              </div>
              
              <!-- Enhanced Canvas Timeline -->
              <canvas id="timelineCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; cursor: pointer;"></canvas>
              
              <!-- Timeline Zoom Controls -->
              <div class="timeline-zoom-controls">
                <button class="timeline-zoom-btn" id="zoomOut" title="Zoom Out">-</button>
                <button class="timeline-zoom-btn" id="zoomIn" title="Zoom In">+</button>
              </div>
              
              <!-- Draggable Scrubber -->
              <div id="scrubber"></div>
              

            </div>
          </div>
        </div>
        
        <!-- Thumbnail preview -->
        <div class="thumbnail-preview" id="thumbnailPreview">
          <img id="thumbnailImg" src="" alt="Preview">
          <div class="time-label" id="thumbnailTime">0:00</div>
        </div>
        
        <!-- Timeline hover label -->
        <div class="timeline-hover-label" id="timelineHoverLabel">00:00</div>
        
        <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
      </div>
  </div>


  
  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-content">
      <h2 class="welcome-title">WELCOME TO SMX STREAM</h2>
      <div class="welcome-text">
        <p>SMX Stream is your live training platform for Security Mission Exercises. Watch live training sessions, access recorded content, and interact with instructors in real-time.</p>
        <br>
        <p><strong>Keyboard Shortcuts:</strong></p>
        <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
          <li><strong>Space/K</strong> - Play/Pause</li>
          <li><strong>J/L</strong> - Skip backward/forward 10s</li>
          <li><strong>Shift+L</strong> - Jump to LIVE</li>
          <li><strong>M</strong> - Mute/Unmute</li>
          <li><strong>F</strong> - Fullscreen</li>
          <li><strong>Arrow Keys</strong> - Skip 5s</li>
        </ul>
        <p><strong>Timeline:</strong> Double-click any time marker to jump to LIVE edge</p>
      </div>
      <div class="welcome-actions">
        <div class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          <label for="dontShowAgain">Don't show this again</label>
        </div>
        <button class="welcome-close" id="closeWelcome">Get Started</button>
      </div>
    </div>
  </div>
  
  <script>
    // ===== REAL-TIME SYNCHRONIZATION VARIABLES =====
    let socket = null;
    let classId = null;
    let instructorTime = 0;
    
    // Extract classId from URL parameters
    function getClassIdFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const classIdFromURL = urlParams.get('classId');
      if (classIdFromURL) {
        console.log('🆔 Class ID from URL:', classIdFromURL);
        return classIdFromURL;
      }
      
      // Fallback: try to get from localStorage (set by Stream Mode)
      const classIdFromStorage = localStorage.getItem('currentStreamClass');
      if (classIdFromStorage) {
        console.log('🆔 Class ID from localStorage:', classIdFromStorage);
        return classIdFromStorage;
      }
      
      console.warn('⚠️ No class ID found in URL or localStorage');
      return null;
    }
    
    // Initialize classId
    classId = getClassIdFromURL();
    let instructorPlaying = false;
    let streamStartTime = null; // When the stream started (actual time)
    let isLiveSynced = true; // Whether student is at live edge
    let liveEdgeTime = 0; // Current live edge time
    let behindLiveSeconds = 0; // How many seconds behind live
    let lastSyncTime = 0; // Last time we synced with instructor
    let isLive = false;
    let canSeekAhead = false; // Students cannot seek ahead of instructor
    let isInstructor = false; // Track if current user is instructor
    
    // ===== ENHANCED TIMELINE VARIABLES =====
    let timelineCanvas = null;
    let timelineCtx = null;
    let zoomLevel = 1; // 1 = 30 seconds visible, higher = more zoomed in
    let viewportStart = 0; // Start time of visible timeline range
    let visibleDuration = 30; // Seconds visible in timeline
    let thumbnailCache = new Map(); // Cache for video thumbnails at specific times
    let isDragging = false;
    let lastThumbnailTime = -1; // Track last time we captured a thumbnail
    let dragStartX = 0;
    let dragStartViewport = 0;
    let tooltipVisible = false;
    let tooltipX = 0;
    let tooltipTime = 0;
    
    // ===== SCREENSHOT FUNCTIONALITY VARIABLES =====
    let isScreenshotMode = false;
    let screenshotStartTime = 0;
    let screenshotCanvas = null;
    let screenshotContext = null;
    
    // ===== WELCOME MODAL FUNCTIONALITY =====
    const welcomeModal = document.getElementById('welcomeModal');
    const closeWelcomeBtn = document.getElementById('closeWelcome');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    
    // Check if user has chosen not to show the welcome modal
    function shouldShowWelcome() {
      return localStorage.getItem('smx-stream-hide-welcome') !== 'true';
    }
    
    // Show welcome modal on page load
    function showWelcomeModal() {
      if (shouldShowWelcome()) {
        setTimeout(() => {
          welcomeModal.classList.add('show');
        }, 500); // Small delay for better UX
      }
    }
    
    // Close welcome modal
    function closeWelcomeModal() {
      welcomeModal.classList.remove('show');
      
      // Save preference if checkbox is checked
      if (dontShowAgainCheckbox.checked) {
        localStorage.setItem('smx-stream-hide-welcome', 'true');
      }
    }
    
    // Event listeners for welcome modal
    closeWelcomeBtn.addEventListener('click', closeWelcomeModal);
    
    // Close modal when clicking outside the content
    welcomeModal.addEventListener('click', function(e) {
      if (e.target === welcomeModal) {
        closeWelcomeModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && welcomeModal.classList.contains('show')) {
        closeWelcomeModal();
      }
    });
    
    // Icon utility functions
    const Icons = {
      play: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,3 19,12 5,21"></polygon></svg>`,
      pause: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`,
      rewind: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11,19 2,12 11,5"></polygon><polygon points="22,19 13,12 22,5"></polygon></svg>`,
      fastForward: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13,19 22,12 13,5"></polygon><polygon points="2,19 11,12 2,5"></polygon></svg>`,
      live: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;"><circle cx="12" cy="12" r="10"></circle></svg>`,
      zoomIn: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`,
      zoomOut: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>`
    };

    // ===== SOCKET.IO INITIALIZATION =====
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('❌ Socket.IO not available');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('🔌 Connected to server');
        if (classId) {
          // Join class as student - automatic streaming
          socket.emit('student-join-class', { classId });
          console.log(`🎓 Joined class: ${classId}`);
          
          // Recover stream state for late joiners
          recoverStreamState();
        } else {
          console.warn('⚠️ No classId available for socket connection');
        }
      });
      
      socket.on('disconnect', () => {
        console.log('🔌 Disconnected from server');
        showStreamStatusOverlay('Connection lost - Reconnecting...');
        isStreamActive = false;
      });
      
      // Stream synchronization events
      socket.on('stream:init', (data) => {
        console.log('🎬 Stream initialized:', data);
        handleStreamInit(data);
        hideStreamStatusOverlay();
        isStreamActive = true;
      });
      
      socket.on('stream:play', (data) => {
        console.log('▶️ Instructor played video at:', data.time);
        handleInstructorPlay(data);
        hideStreamStatusOverlay();
        clearPauseTimeout();
        isStreamActive = true;
      });
      
      socket.on('stream:pause', (data) => {
        console.log('⏸️ Instructor paused video at:', data.time);
        handleInstructorPause(data);
        if (isStreamActive) {
          startPauseTimeout();
        }
      });
      
      socket.on('stream:seek', (data) => {
        console.log('⏭️ Instructor seeked to:', data.time);
        handleInstructorSeek(data);
      });
      
      socket.on('stream:time', (data) => {
        // Regular time updates from instructor
        const previousInstructorTime = instructorTime;
        instructorTime = data.time;
        instructorPlaying = data.playing;
        
        // Capture thumbnail at instructor's current time for timeline
        if (instructorPlaying) {
          captureThumbnailAtTime(instructorTime);
        }
      });
      
      // ===== INSTRUCTOR WEBRTC EVENTS =====
      socket.on('student:joined', (data) => {
        console.log('👨‍🎓 Student joined room:', data.studentId);
        if (isInstructor && localStream) {
          handleStudentJoined(data.studentId);
        }
        // Update viewer count
        updateViewerCount();
      });
      
      socket.on('student:left', (data) => {
        console.log('👋 Student left room:', data.studentId);
        if (isInstructor) {
          const peerConnection = peerConnections.get(data.studentId);
          if (peerConnection) {
            peerConnection.close();
            peerConnections.delete(data.studentId);
          }
        }
        // Update viewer count
        updateViewerCount();
      });
      
      socket.on('webrtc-answer', (data) => {
        if (isInstructor) {
          handleWebRTCAnswer(data);
        }
      });
      
      socket.on('webrtc-ice-candidate', (data) => {
        if (isInstructor) {
          handleICECandidate(data);
        }
      });
      
      socket.on('viewer:count', (data) => {
        updateViewerCount(data.count);
      });
      
      // ===== ROOM JOINING EVENTS =====
      socket.on('stream:instructor-ready', (data) => {
        console.log('✅ Instructor ready to broadcast:', data);
        isInstructor = true;
        checkInstructorRole();
        currentRoom = `class:${data.classId}`;
      });
      
      socket.on('viewerCount', (data) => {
        console.log('👥 Viewer count update:', data.count);
        updateViewerCount(data.count);
      });
      
      socket.on('stream:student-ready', (data) => {
        console.log('✅ Student ready to receive stream:', data);
        isInstructor = false;
        currentRoom = `class:${data.classId}`;
      });
        
        // Check if student is still in sync with live stream
        const video = document.getElementById('video');
        if (video && !video.paused) {
          const timeDifference = Math.abs(instructorTime - video.currentTime);
          
          // If student is significantly behind or ahead, show appropriate UI
          if (timeDifference > 5) { // More than 5 seconds difference
            if (video.currentTime < instructorTime - 3) {
              // Student is behind live
              showJumpToLiveButton();
              updateLiveStatus(false);
            } else if (video.currentTime > instructorTime + 1) {
              // Student somehow got ahead (shouldn't happen, but handle it)
              video.currentTime = instructorTime;
              showNotification('Synced back to live stream', 'info');
            }
          } else {
            // Student is in sync
            hideJumpToLiveButton();
            updateLiveStatus(true);
          }
        }
        
        // Update timeline live edge
        if (window.enhancedTimeline) {
          window.enhancedTimeline.render();
        }
        
        // Update live edge time for timeline
        liveEdgeTime = instructorTime;
      });
      
      // ===== NATIVE VIDEO EVENT LISTENERS (STUDENT SIDE) =====
      socket.on('stream:play', (data) => {
        console.log('📹 Instructor played video');
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
        
        if (activeVideo && activeVideo.paused) {
          activeVideo.play().catch(e => console.log('Autoplay prevented:', e));
        }
        
        if (data.time !== undefined) {
          activeVideo.currentTime = data.time;
        }
        
        instructorPlaying = true;
        updateLiveStatus();
      });
      
      socket.on('stream:pause', (data) => {
        console.log('⏸️ Instructor paused video');
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
        
        if (activeVideo && !activeVideo.paused) {
          activeVideo.pause();
        }
        
        if (data.time !== undefined) {
          activeVideo.currentTime = data.time;
        }
        
        instructorPlaying = false;
        updateLiveStatus();
      });
      
      socket.on('stream:seek', (data) => {
        console.log('⏭️ Instructor seeked video to:', data.time);
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
        
        if (activeVideo && data.time !== undefined) {
          activeVideo.currentTime = data.time;
        }
        
        instructorTime = data.time;
        updateLiveStatus();
      });
      
      socket.on('streamStatus', (data) => {
        console.log('📡 Stream status update:', data);
        handleStreamStatusUpdate(data);
        
        // Convert streamStatus to stream:init format for compatibility
        if (data.status === 'live' && data.streamUrl) {
          console.log('🔄 Converting streamStatus to stream:init');
          handleStreamInit({
            streamUrl: data.streamUrl,
            startTime: new Date().toISOString(),
            currentTime: 0,
            playing: true,
            filename: data.filename
          });
          hideStreamStatusOverlay();
          isStreamActive = true;
        } else if (data.status === 'offline') {
          handleStreamEnd();
        }
      });
      
      // Handle instructor WebRTC streaming notifications
      socket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Instructor started WebRTC streaming:', data);
        updateStreamTypeIndicator(`Live ${data.mediaType || 'WebRTC'}`);
        hideStreamStatusOverlay();
        isStreamActive = true;
      });
      
      socket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Instructor stopped WebRTC streaming');
        showStreamStatusOverlay('Stream ended');
        isStreamActive = false;
      });
      
      // Handle current stream state for late joiners
      socket.on('stream:current-state', (data) => {
        console.log('📥 Received current stream state:', data);
        handleCurrentStreamState(data);
      });
      
      socket.on('stream:no-state', (data) => {
        console.log('ℹ️ No active stream state available');
        showWaitingMessage();
        isStreamActive = false;
      });
    }
    
    // ===== STREAM SYNCHRONIZATION HANDLERS =====
    function handleStreamInit(data) {
      console.log('🎬 Handling stream initialization:', data);
      
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      if (!data.streamUrl) {
        console.warn('⚠️ No stream URL provided in stream:init');
        return;
      }
      
      // Hide WebRTC video and show regular video
      if (webrtcVideo) webrtcVideo.style.display = 'none';
      video.style.display = 'block';
      video.src = data.streamUrl;
      
      // Set up load event listener
      video.addEventListener('loadeddata', () => {
        console.log('✅ Stream video loaded successfully');
        
        // Sync to instructor's position
        if (data.currentTime) {
          video.currentTime = data.currentTime;
        }
        
        // Play if instructor is playing
        if (data.playing) {
          video.play().catch(e => {
            console.log('🔇 Autoplay prevented, user interaction required:', e);
            showNotification('Click to start the stream', 'info');
          });
        }
        
        // Hide waiting overlay
        hideStreamStatusOverlay();
        isStreamActive = true;
        
        // Initialize enhanced timeline when video loads
        if (!window.enhancedTimeline) {
          try {
            window.enhancedTimeline = new EnhancedTimeline('timelineCanvas', 'video');
            startThumbnailCapture();
            console.log('✅ Enhanced Timeline and thumbnail capture initialized after video load');
          } catch (error) {
            console.warn('⚠️ Timeline initialization failed:', error);
          }
        }
        
      }, { once: true });
      
      // Handle load errors
      video.addEventListener('error', (e) => {
        console.error('❌ Error loading stream video:', e);
        showStreamStatusOverlay('Error loading stream - Please refresh');
      }, { once: true });
      
      // Load the video
      video.load();
      
      // Update state variables
      streamStartTime = new Date(data.startTime);
      instructorTime = data.currentTime || 0;
      instructorPlaying = data.playing || false;
      
      // Update UI
      updateStreamTypeIndicator(data.filename ? `Live: ${data.filename}` : 'Live Stream');
      updateLiveStatus();
      updateClockDisplay();
      
      console.log('✅ Stream initialization completed');
    }
    
    // ===== VIEWER COUNT AND UI UPDATES =====
    function updateViewerCount(count) {
      const viewerCountElement = document.getElementById('viewerCount');
      if (viewerCountElement) {
        if (count !== undefined) {
          viewerCountElement.textContent = count;
        } else {
          // Request current viewer count from server
          socket.emit('get:viewer-count', { room: currentRoom });
        }
      }
    }
    
    // Check if user is instructor and show controls
    function checkInstructorRole() {
      // This will be called after authentication
      if (isInstructor) {
        document.getElementById('instructorControls').style.display = 'flex';
        updateViewerCount();
        console.log('🎛️ Instructor controls enabled');
      }
    }
    
    // Join the streaming room based on user role
    function joinStreamingRoom() {
      // Get class ID from URL or use default
      const urlParams = new URLSearchParams(window.location.search);
      const classId = urlParams.get('class') || 'default-class';
      
      // Get role from URL parameter first, then check authentication
      const urlRole = urlParams.get('role');
      let userRole = 'student'; // Default to student
      
      // Check URL parameter first
      if (urlRole === 'instructor' || urlRole === 'admin') {
        userRole = 'instructor';
        isInstructor = true;
      } else if (urlRole === 'student') {
        userRole = 'student';
        isInstructor = false;
      } else {
        // Fallback to checking authentication (if available)
        userRole = isInstructor ? 'instructor' : 'student';
      }
      
      console.log(`🚪 Joining streaming room as ${userRole} for class: ${classId}`);
      console.log(`🔍 Role detection: URL=${urlRole}, Final=${userRole}, isInstructor=${isInstructor}`);
      console.log(`🌐 Current URL: ${window.location.href}`);
      console.log(`📋 URL Parameters:`, Object.fromEntries(urlParams));
      
      if (userRole === 'instructor') {
        socket.emit('instructor-join-class', { classId });
        currentRoom = `class:${classId}`;
        console.log('👨‍🏫 Instructor joining class:', classId);
        
        // Show instructor controls immediately
        document.getElementById('instructorControls').style.display = 'flex';
        
        // Update role indicator
        const roleIndicator = document.getElementById('roleIndicator');
        roleIndicator.textContent = '👨‍🏫 Instructor';
        roleIndicator.className = 'role-indicator instructor';
      } else {
        socket.emit('student-join-class', { classId });
        currentRoom = `class:${classId}`;
        console.log('👨‍🎓 Student joining class:', classId);
        
        // Hide instructor controls for students
        document.getElementById('instructorControls').style.display = 'none';
        
        // Update role indicator
        const roleIndicator = document.getElementById('roleIndicator');
        roleIndicator.textContent = '👨‍🎓 Student';
        roleIndicator.className = 'role-indicator student';
      }
    }
    
    function handleInstructorPlay(data) {
      const video = document.getElementById('video');
      instructorTime = data.time;
      instructorPlaying = true;
      
      // Only auto-sync if student is close to live or hasn't manually paused
      const timeDifference = Math.abs(video.currentTime - instructorTime);
      const studentManuallyPaused = video.paused && timeDifference > 5;
      
      if (!studentManuallyPaused) {
        // Student is following live stream - sync them
        if (timeDifference > 1) {
          video.currentTime = instructorTime;
        }
        
        if (video.paused) {
          video.play().catch(e => console.log('Autoplay prevented:', e));
        }
        
        hideJumpToLiveButton();
        updateLiveStatus(true);
      } else {
        // Student has manually paused and is behind - don't force play
        showJumpToLiveButton();
        updateLiveStatus(false);
        showNotification('Instructor resumed - Click Jump to Live to catch up', 'info');
      }
      
      updatePlayPauseButton(video.paused);
    }
    
    function handleInstructorPause(data) {
      const video = document.getElementById('video');
      instructorTime = data.time;
      instructorPlaying = false;
      
      // Only auto-pause students who are following live stream
      const timeDifference = Math.abs(video.currentTime - instructorTime);
      const studentIsLive = timeDifference < 3;
      
      if (studentIsLive && !video.paused) {
        // Student is live - sync them with instructor pause
        if (timeDifference > 1) {
          video.currentTime = instructorTime;
        }
        video.pause();
        updateLiveStatus(true);
        showNotification('Instructor paused the stream', 'info');
      } else if (!studentIsLive) {
        // Student is already behind - don't force pause, just update status
        updateLiveStatus(false);
        showJumpToLiveButton();
      }
      
      updatePlayPauseButton(video.paused);
    }
    
    function handleInstructorSeek(data) {
      const video = document.getElementById('video');
      instructorTime = data.time;
      
      // Force sync student to instructor time
      video.currentTime = instructorTime;
    }
    
    function handleStreamEnd() {
      console.log('⏹️ Stream ended');
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Pause and reset videos
      if (video) {
        video.pause();
        video.src = '';
      }
      if (webrtcVideo) {
        webrtcVideo.pause();
        webrtcVideo.srcObject = null;
        webrtcVideo.style.display = 'none';
      }
      
      // Update state
      isStreamActive = false;
      instructorPlaying = false;
      
      // Show status overlay
      showStreamStatusOverlay('Stream ended');
      updateStreamTypeIndicator('Offline');
    }
    
    function handleStreamStatusUpdate(data) {
      console.log('📡 Handling stream status update:', data);
      
      if (data.status === 'live') {
        if (data.streamUrl) {
          // File/Upload stream
          const video = document.getElementById('video');
          const webrtcVideo = document.getElementById('webrtcVideo');
          
          // Switch to uploaded video stream
          if (webrtcVideo) webrtcVideo.style.display = 'none';
          video.style.display = 'block';
          video.src = data.streamUrl;
          video.load();
          
          updateStreamTypeIndicator('Live Stream');
          
          // Auto-play if instructor is playing
          video.addEventListener('loadeddata', () => {
            if (instructorPlaying) {
              video.play().catch(e => console.log('Autoplay prevented:', e));
            }
          }, { once: true });
        } else if (data.source === 'webrtc' || data.mediaType) {
          // WebRTC stream - this should be handled by WebRTC socket events
          console.log('🔴 WebRTC stream detected, waiting for WebRTC connection...');
          updateStreamTypeIndicator(`Live ${data.mediaType || 'WebRTC'}`);
        }
      } else if (data.status === 'offline') {
        // Stream ended
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        
        if (video) {
          video.pause();
          video.src = '';
        }
        if (webrtcVideo) {
          webrtcVideo.style.display = 'none';
          webrtcVideo.srcObject = null;
        }
        
        updateStreamTypeIndicator('Stream Offline');
        showStreamStatusOverlay('Stream has ended');
      }
    }
    
    function handleCurrentStreamState(data) {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Set up the video source
      if (data.streamUrl) {
        if (webrtcVideo) webrtcVideo.style.display = 'none';
        video.style.display = 'block';
        video.src = data.streamUrl;
        
        video.addEventListener('loadeddata', () => {
          // Sync to instructor's current position
          const currentTime = data.currentTime + (data.timeSinceStart / 1000);
          video.currentTime = Math.max(0, currentTime);
          
          // Play if instructor is playing
          if (data.playing) {
            video.play().catch(e => console.log('Autoplay prevented:', e));
          }
          
          // Update state variables
          instructorTime = currentTime;
          instructorPlaying = data.playing;
          streamStartTime = new Date(data.startTime);
          
          updateLiveStatus();
          updateStreamTypeIndicator('Live Stream (Joined)');
          
          console.log('✅ Synced to current stream state');
        }, { once: true });
        
        video.load();
      }
    }
    
    // ===== TIMELINE ENFORCEMENT FOR STUDENTS =====
    function enforceTimelineRestrictions() {
      const video = document.getElementById('video');
      const timeline = document.getElementById('timeline');
      
      // Prevent seeking ahead of instructor (LIVE EDGE ENFORCEMENT)
      video.addEventListener('seeking', (e) => {
        if (!isInstructor) {
          if (video.currentTime > instructorTime) {
            console.log('🚫 Cannot seek ahead of instructor');
            video.currentTime = instructorTime;
            showNotification('Cannot seek ahead of live stream', 'warning');
          }
        }
      });
      
      // Prevent fast-forwarding beyond instructor time (LIVE EDGE ENFORCEMENT)
      video.addEventListener('timeupdate', (e) => {
        if (!isInstructor) {
          // Enforce live edge lock - students cannot watch past instructor time
          if (video.currentTime > instructorTime + 0.25) {
            console.log('🚫 Live edge enforced: snapping back to instructor time');
            video.currentTime = instructorTime;
          }
        }
      });
      
      // Enforce timeline scrubbing restrictions
      if (timeline) {
        timeline.addEventListener('click', (e) => {
          const timelineRect = timeline.getBoundingClientRect();
          const clickX = e.clientX - timelineRect.left;
          const timelineWidth = timelineRect.width;
          const clickProgress = clickX / timelineWidth;
          const clickTime = clickProgress * video.duration;
          
          if (!isInstructor && clickTime > instructorTime) {
            e.preventDefault();
            e.stopPropagation();
            showNotification('Cannot scrub ahead of live stream', 'warning');
            return false;
          }
        }, true);
      }
    }
    
    // ===== USER ROLE DETECTION =====
    function detectUserRole() {
      // Check if user is instructor based on token or URL params
      const token = localStorage.getItem('token');
      if (token) {
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          isInstructor = payload.role === 'instructor' || payload.role === 'admin';
          console.log('👤 User role detected:', isInstructor ? 'Instructor' : 'Student');
        } catch (e) {
          console.log('⚠️ Could not decode token, assuming student role');
          isInstructor = false;
        }
      } else {
        isInstructor = false;
      }
    }
    
    // ===== LIVE EDGE ENFORCEMENT INITIALIZATION =====
    function initializeLiveEdgeEnforcement() {
      console.log('🔒 Initializing live edge enforcement for student');
      
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Apply enforcement to both video elements
      [video, webrtcVideo].forEach(videoElement => {
        if (videoElement) {
          // Prevent playback past live edge
          videoElement.addEventListener('timeupdate', () => {
            if (videoElement.currentTime > instructorTime + 0.25) {
              console.log('🚫 Live edge enforced: snapping back to instructor time');
              videoElement.currentTime = instructorTime;
            }
          });
          
          // Prevent seeking past live edge
          videoElement.addEventListener('seeking', () => {
            if (videoElement.currentTime > instructorTime) {
              console.log('🚫 Cannot seek ahead of instructor');
              videoElement.currentTime = instructorTime;
              showNotification('Cannot seek ahead of live stream', 'warning');
            }
          });
        }
      });
      
      // Enforce timeline scrubbing restrictions
      const timeline = document.getElementById('timeline');
      if (timeline) {
        timeline.addEventListener('click', (e) => {
          const timelineRect = timeline.getBoundingClientRect();
          const clickX = e.clientX - timelineRect.left;
          const timelineWidth = timelineRect.width;
          const clickProgress = clickX / timelineWidth;
          const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
          
          if (activeVideo && activeVideo.duration) {
            const clickTime = clickProgress * activeVideo.duration;
            
            if (clickTime > instructorTime) {
              e.preventDefault();
              e.stopPropagation();
              showNotification('Cannot scrub ahead of live stream', 'warning');
              return false;
            }
          }
        }, true);
      }
      
      console.log('✅ Live edge enforcement initialized');
    }
    
    // ===== UTILITY FUNCTIONS =====
    function showStreamStatusOverlay(message) {
      const overlay = document.getElementById('streamStatusText');
      if (overlay) {
        overlay.textContent = message;
        overlay.classList.remove('hidden');
      }
    }
    
    function hideStreamStatusOverlay() {
      const overlay = document.getElementById('streamStatusText');
      if (overlay) {
        overlay.classList.add('hidden');
      }
    }
    
    function updateStreamTypeIndicator(type) {
      const indicator = document.getElementById('streamTypeIndicator');
      if (indicator) {
        indicator.textContent = type;
      }
    }
    
    function showWaitingMessage() {
      showStreamStatusOverlay('Waiting for instructor to start stream...');
      updateStreamTypeIndicator('Waiting...');
      
      // Hide video elements while waiting
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      if (video) {
        video.style.display = 'none';
        video.src = '';
      }
      if (webrtcVideo) {
        webrtcVideo.style.display = 'none';
        webrtcVideo.srcObject = null;
      }
    }
    
    function updateLiveStatus(isLive = null) {
      // Update sync status and other live indicators
      const syncStatus = document.getElementById('syncStatus');
      const clockDisplay = document.getElementById('clockDisplay');
      const video = document.getElementById('video');
      
      // Determine if we're live (either passed as parameter or calculated)
      let actuallyLive = isLive;
      if (actuallyLive === null && video) {
        const timeDifference = Math.abs(instructorTime - video.currentTime);
        actuallyLive = timeDifference < 3; // Within 3 seconds is considered live
      }
      
      if (instructorPlaying && actuallyLive) {
        // Student is live and instructor is playing
        if (syncStatus) {
          syncStatus.style.display = 'flex';
          syncStatus.classList.add('live');
          syncStatus.classList.remove('behind');
          const statusText = document.getElementById('syncStatusText');
          if (statusText) statusText.textContent = 'LIVE';
        }
        
        if (clockDisplay) {
          clockDisplay.classList.remove('not-live');
        }
        
        isLiveSynced = true;
        
      } else if (instructorPlaying && !actuallyLive) {
        // Student is behind live stream
        if (syncStatus) {
          syncStatus.style.display = 'flex';
          syncStatus.classList.remove('live');
          syncStatus.classList.add('behind');
          const statusText = document.getElementById('syncStatusText');
          if (statusText && video) {
            const secondsBehind = Math.round(instructorTime - video.currentTime);
            statusText.textContent = `${secondsBehind}s BEHIND`;
          }
        }
        
        if (clockDisplay) {
          clockDisplay.classList.add('not-live');
        }
        
        isLiveSynced = false;
        
      } else {
        // Instructor is paused or stream is offline
        if (syncStatus) {
          syncStatus.classList.remove('live', 'behind');
        }
        
        if (clockDisplay) {
          clockDisplay.classList.add('not-live');
        }
      }
    }
    
    function updateClockDisplay() {
      const clockDisplay = document.getElementById('clockDisplay');
      if (clockDisplay) {
        const now = new Date();
        const timeString = now.toLocaleTimeString();
        clockDisplay.textContent = timeString;
      }
    }
    
    // Update clock every second
    setInterval(updateClockDisplay, 1000);
    
    function showNotification(message, type = 'info') {
      console.log(`📢 ${type.toUpperCase()}: ${message}`);
      // You can implement a toast notification system here if needed
    }
    
    // ===== STREAM RECOVERY FOR LATE JOINERS =====
    async function recoverStreamState() {
      if (!classId) return;
      
      try {
        console.log('🔄 Recovering stream state for late joiner...');
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/state/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.success && data.state) {
            console.log('✅ Stream state recovered:', data.state);
            
            // Update instructor time
            instructorTime = data.state.currentLiveTime || data.state.currentTime;
            instructorPlaying = data.state.playing;
            
            // Load video if available
            if (data.state.streamUrl) {
              const video = document.getElementById('video');
              if (video) {
                video.src = data.state.streamUrl;
                
                video.addEventListener('loadeddata', () => {
                  // Sync to current live time
                  video.currentTime = instructorTime;
                  
                  if (instructorPlaying) {
                    video.play().catch(e => {
                      console.log('Autoplay prevented, user interaction required');
                      showNotification('Click to resume live stream', 'info');
                    });
                  }
                }, { once: true });
                
                video.load();
              }
            }
          } else {
            console.log('📭 No active stream to recover');
          }
        }
      } catch (error) {
        console.error('❌ Failed to recover stream state:', error);
      }
    }
    
    // ===== ENHANCED CANVAS TIMELINE IMPLEMENTATION =====
    class EnhancedTimeline {
      constructor(canvasId, videoId) {
        this.canvas = document.getElementById(canvasId);
        this.video = document.getElementById(videoId);
        this.ctx = this.canvas.getContext('2d');
        
        if (!this.canvas || !this.video) {
          console.error('❌ Timeline canvas or video element not found');
          return;
        }
        
        this.setupCanvas();
        this.setupEventListeners();
        this.startRenderLoop();
        
        console.log('✅ Enhanced Timeline initialized');
      }
      
      setupCanvas() {
        // Set canvas size to match container
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // Store references globally
        timelineCanvas = this.canvas;
        timelineCtx = this.ctx;
      }
      
      setupEventListeners() {
        // Mouse wheel for zooming
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          this.handleZoom(e);
        });
        
        // Mouse events for panning and clicking
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave(e));
        
        // Video events
        this.video.addEventListener('loadedmetadata', () => this.render());
        this.video.addEventListener('timeupdate', () => this.render());
        
        // Window resize
        window.addEventListener('resize', () => {
          this.setupCanvas();
          this.render();
        });
      }
      
      handleZoom(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseTimeRatio = mouseX / rect.width;
        const mouseTime = viewportStart + (mouseTimeRatio * visibleDuration);
        
        // Zoom in/out
        const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8;
        const newVisibleDuration = Math.max(5, Math.min(this.video.duration || 300, visibleDuration * zoomFactor));
        
        // Adjust viewport to keep mouse position stable
        const newViewportStart = mouseTime - (mouseTimeRatio * newVisibleDuration);
        
        visibleDuration = newVisibleDuration;
        viewportStart = Math.max(0, Math.min(this.video.duration - visibleDuration, newViewportStart));
        zoomLevel = 30 / visibleDuration; // Normalize zoom level
        
        this.render();
      }
      
      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        if (e.shiftKey) {
          // Start panning
          isDragging = true;
          dragStartX = mouseX;
          dragStartViewport = viewportStart;
          this.canvas.style.cursor = 'grabbing';
        } else {
          // Jump to time (if allowed)
          this.jumpToTime(mouseX);
        }
      }
      
      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        if (isDragging) {
          // Pan timeline
          const deltaX = mouseX - dragStartX;
          const deltaTime = -(deltaX / rect.width) * visibleDuration;
          const newViewportStart = dragStartViewport + deltaTime;
          
          viewportStart = Math.max(0, Math.min(this.video.duration - visibleDuration, newViewportStart));
          this.render();
        } else {
          // Show tooltip
          this.showTooltip(mouseX);
        }
      }
      
      handleMouseUp(e) {
        isDragging = false;
        this.canvas.style.cursor = 'pointer';
      }
      
      handleMouseLeave(e) {
        isDragging = false;
        tooltipVisible = false;
        this.canvas.style.cursor = 'pointer';
        this.render();
      }
      
      jumpToTime(mouseX) {
        const rect = this.canvas.getBoundingClientRect();
        const timeRatio = mouseX / rect.width;
        const targetTime = viewportStart + (timeRatio * visibleDuration);
        
        // Apply live edge enforcement for students
        if (!isInstructor && targetTime > instructorTime) {
          showNotification('Cannot jump ahead of live stream', 'warning');
          return;
        }
        
        if (this.video && targetTime >= 0 && targetTime <= this.video.duration) {
          this.video.currentTime = targetTime;
          console.log(`⏭️ Jumped to time: ${targetTime.toFixed(2)}s`);
        }
      }
      
      showTooltip(mouseX) {
        const rect = this.canvas.getBoundingClientRect();
        const timeRatio = mouseX / rect.width;
        const time = viewportStart + (timeRatio * visibleDuration);
        
        tooltipVisible = true;
        tooltipX = mouseX;
        tooltipTime = time;
        this.render();
      }
      
      startRenderLoop() {
        // Render at 30fps when active
        setInterval(() => {
          if (this.video && !this.video.paused) {
            this.render();
          }
        }, 33);
      }
      
      render() {
        if (!this.ctx || !this.video) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, width, height);
        
        // Draw background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(0, 0, width, height);
        
        // Draw timeline components
        this.drawTicks();
        this.drawThumbnails();
        this.drawPlayhead();
        this.drawLiveEdge();
        this.drawTooltip();
      }
      
      drawTicks() {
        if (!this.video.duration) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Calculate tick intervals based on zoom
        let majorInterval, minorInterval;
        if (visibleDuration <= 10) {
          majorInterval = 1; minorInterval = 0.2;
        } else if (visibleDuration <= 30) {
          majorInterval = 5; minorInterval = 1;
        } else if (visibleDuration <= 120) {
          majorInterval = 10; minorInterval = 2;
        } else {
          majorInterval = 30; minorInterval = 5;
        }
        
        const viewportEnd = viewportStart + visibleDuration;
        
        // Draw minor ticks
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 1;
        
        for (let time = Math.floor(viewportStart / minorInterval) * minorInterval; time <= viewportEnd; time += minorInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          const tickHeight = height * 0.2;
          
          this.ctx.beginPath();
          this.ctx.moveTo(x, height - tickHeight);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
        }
        
        // Draw major ticks with labels
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        this.ctx.font = '10px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.lineWidth = 2;
        
        for (let time = Math.floor(viewportStart / majorInterval) * majorInterval; time <= viewportEnd; time += majorInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          const tickHeight = height * 0.4;
          
          // Draw tick
          this.ctx.beginPath();
          this.ctx.moveTo(x, height - tickHeight);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
          
          // Draw label
          const minutes = Math.floor(time / 60);
          const seconds = Math.floor(time % 60);
          const label = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.ctx.fillText(label, x, height - tickHeight - 5);
        }
      }
      
      drawThumbnails() {
        if (!this.video.duration) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        const thumbnailHeight = height * 0.6;
        const thumbnailWidth = thumbnailHeight * (16/9); // Assume 16:9 aspect ratio
        
        // Calculate thumbnail interval based on zoom
        let thumbnailInterval;
        if (visibleDuration <= 30) {
          thumbnailInterval = 5;
        } else if (visibleDuration <= 120) {
          thumbnailInterval = 10;
        } else {
          thumbnailInterval = 30;
        }
        
        const viewportEnd = viewportStart + visibleDuration;
        
        for (let time = Math.floor(viewportStart / thumbnailInterval) * thumbnailInterval; time <= viewportEnd; time += thumbnailInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          
          // Get or create thumbnail
          const thumbnail = this.getThumbnail(time);
          if (thumbnail) {
            const thumbX = x - thumbnailWidth / 2;
            const thumbY = 5;
            
            this.ctx.drawImage(thumbnail, thumbX, thumbY, thumbnailWidth, thumbnailHeight);
            
            // Draw border
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(thumbX, thumbY, thumbnailWidth, thumbnailHeight);
          }
        }
      }
      
      getThumbnail(time) {
        const key = Math.floor(time);
        
        if (thumbnailCache.has(key)) {
          return thumbnailCache.get(key);
        }
        
        // Create thumbnail asynchronously
        this.createThumbnail(time, key);
        return null;
      }
      
      async createThumbnail(time, key) {
        if (!this.video.videoWidth || !this.video.videoHeight) return;
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 160;
        canvas.height = 90;
        
        // Temporarily seek to capture frame
        const originalTime = this.video.currentTime;
        this.video.currentTime = time;
        
        await new Promise(resolve => {
          const onSeeked = () => {
            ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);
            thumbnailCache.set(key, canvas);
            this.video.removeEventListener('seeked', onSeeked);
            this.video.currentTime = originalTime;
            resolve();
          };
          this.video.addEventListener('seeked', onSeeked);
        });
      }
      
      drawPlayhead() {
        if (!this.video.duration) return;
        
        const currentTime = this.video.currentTime;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        if (currentTime >= viewportStart && currentTime <= viewportStart + visibleDuration) {
          const x = ((currentTime - viewportStart) / visibleDuration) * width;
          
          // Draw playhead line
          this.ctx.strokeStyle = '#ff4757';
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
          
          // Draw playhead indicator
          this.ctx.fillStyle = '#ff4757';
          this.ctx.beginPath();
          this.ctx.arc(x, 10, 6, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }
      
      drawLiveEdge() {
        if (!isInstructor && instructorTime > 0) {
          const width = this.canvas.width;
          const height = this.canvas.height;
          
          if (instructorTime >= viewportStart && instructorTime <= viewportStart + visibleDuration) {
            const x = ((instructorTime - viewportStart) / visibleDuration) * width;
            
            // Draw live edge line
            this.ctx.strokeStyle = '#22c55e';
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 5]);
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            
            // Draw "LIVE" label
            this.ctx.fillStyle = '#22c55e';
            this.ctx.font = 'bold 10px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('LIVE', x, height - 5);
          }
        }
      }
      
      drawTooltip() {
        if (!tooltipVisible) return;
        
        const minutes = Math.floor(tooltipTime / 60);
        const seconds = Math.floor(tooltipTime % 60);
        const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Draw tooltip background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(tooltipX - 25, 5, 50, 20);
        
        // Draw tooltip text
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(timeText, tooltipX, 18);
      }
    }
    
    // ===== TIMELINE UTILITY FUNCTIONS =====
    function updateTimelineViewport() {
      if (!window.enhancedTimeline || !window.enhancedTimeline.video) return;
      
      const video = window.enhancedTimeline.video;
      const currentTime = video.currentTime;
      
      // Auto-follow playhead if it goes outside viewport
      if (currentTime < viewportStart || currentTime > viewportStart + visibleDuration) {
        viewportStart = Math.max(0, currentTime - visibleDuration / 2);
        if (window.enhancedTimeline) {
          window.enhancedTimeline.render();
        }
      }
    }
    
    function resetTimelineZoom() {
      visibleDuration = 30;
      viewportStart = 0;
      zoomLevel = 1;
      if (window.enhancedTimeline) {
        window.enhancedTimeline.render();
      }
    }
    
    function centerTimelineOnTime(time) {
      if (!window.enhancedTimeline || !window.enhancedTimeline.video) return;
      
      viewportStart = Math.max(0, Math.min(
        window.enhancedTimeline.video.duration - visibleDuration,
        time - visibleDuration / 2
      ));
      
      if (window.enhancedTimeline) {
        window.enhancedTimeline.render();
      }
    }
    
    // ===== TIMELINE VIDEO SOURCE SWITCHING =====
    function switchTimelineVideoSource(videoId) {
      if (window.enhancedTimeline) {
        const newVideo = document.getElementById(videoId);
        if (newVideo) {
          window.enhancedTimeline.video = newVideo;
          
          // Clear thumbnail cache when switching sources
          thumbnailCache.clear();
          
          // Reset timeline view
          resetTimelineZoom();
          
          console.log(`🔄 Timeline switched to video source: ${videoId}`);
        }
      }
    }
    
    // ===== STREAM STATUS OVERLAY MANAGEMENT =====
    let streamStatusOverlay = null;
    let pauseTimeout = null;
    let isStreamActive = false;
    
    function initializeStreamStatusOverlay() {
      streamStatusOverlay = document.getElementById('streamStatusText');
      
      if (!streamStatusOverlay) {
        console.error('❌ Stream status overlay not found');
        return;
      }
      
      console.log('✅ Stream status overlay initialized');
      
      // Initially show the overlay
      showStreamStatusOverlay('Instructor Will Start Stream Soon');
      
      // Set up video event listeners
      setupStreamStatusListeners();
    }
    
    function setupStreamStatusListeners() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Regular video events
      if (video) {
        video.addEventListener('loadeddata', () => {
          console.log('📹 Video loaded - hiding status overlay');
          hideStreamStatusOverlay();
          isStreamActive = true;
        });
        
        video.addEventListener('play', () => {
          hideStreamStatusOverlay();
          clearPauseTimeout();
          isStreamActive = true;
        });
        
        video.addEventListener('pause', () => {
          if (isStreamActive) {
            startPauseTimeout();
          }
        });
        
        video.addEventListener('ended', () => {
          showStreamStatusOverlay('Stream has ended');
          isStreamActive = false;
        });
        
        video.addEventListener('error', () => {
          showStreamStatusOverlay('Stream connection error');
          isStreamActive = false;
        });
      }
      
      // WebRTC video events
      if (webrtcVideo) {
        webrtcVideo.addEventListener('loadeddata', () => {
          console.log('📹 WebRTC video loaded - hiding status overlay');
          hideStreamStatusOverlay();
          isStreamActive = true;
        });
        
        webrtcVideo.addEventListener('play', () => {
          hideStreamStatusOverlay();
          clearPauseTimeout();
          isStreamActive = true;
        });
        
        webrtcVideo.addEventListener('pause', () => {
          if (isStreamActive) {
            startPauseTimeout();
          }
        });
      }
    }
    
    function showStreamStatusOverlay(message, isPaused = false) {
      if (!streamStatusOverlay) return;
      
      streamStatusOverlay.textContent = message;
      streamStatusOverlay.classList.remove('hidden');
      
      if (isPaused) {
        streamStatusOverlay.classList.add('paused');
      } else {
        streamStatusOverlay.classList.remove('paused');
      }
      
      console.log('👁️ Stream status overlay shown:', message);
    }
    
    function hideStreamStatusOverlay() {
      if (!streamStatusOverlay) return;
      
      streamStatusOverlay.classList.add('hidden');
      streamStatusOverlay.classList.remove('paused');
      
      console.log('🙈 Stream status overlay hidden');
    }
    
    function startPauseTimeout() {
      clearPauseTimeout();
      
      // Show pause message after 10 seconds of being paused
      pauseTimeout = setTimeout(() => {
        if (isStreamActive) {
          showStreamStatusOverlay('🔴 Instructor has paused the stream', true);
        }
      }, 10000); // 10 seconds
    }
    
    function clearPauseTimeout() {
      if (pauseTimeout) {
        clearTimeout(pauseTimeout);
        pauseTimeout = null;
      }
    }
    
    // Check stream state from server
    async function checkStreamState() {
      if (!classId) return;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/state/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.success && data.state && data.state.streamUrl) {
            console.log('✅ Active stream detected from server');
            isStreamActive = true;
            hideStreamStatusOverlay();
          } else {
            console.log('📭 No active stream from server');
            isStreamActive = false;
            showStreamStatusOverlay('Instructor Will Start Stream Soon');
          }
        }
      } catch (error) {
        console.error('❌ Failed to check stream state:', error);
        showStreamStatusOverlay('Checking stream status...');
      }
    }
    
    // ===== SCREENSHOT FUNCTIONALITY =====
    function initializeScreenshotFeature() {
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      // Create hidden canvas for screenshots
      screenshotCanvas = document.createElement('canvas');
      screenshotContext = screenshotCanvas.getContext('2d');
      
      let mouseDownTime = 0;
      let isMouseDown = false;
      
      videoContainer.addEventListener('mousedown', (e) => {
        // Only trigger on areas outside the video controls
        if (e.target.closest('.video-controls-overlay') || 
            e.target.closest('.video-utility-controls') ||
            e.target.tagName === 'VIDEO') {
          return;
        }
        
        isMouseDown = true;
        mouseDownTime = Date.now();
        screenshotStartTime = mouseDownTime;
        
        // Add visual feedback
        videoContainer.style.cursor = 'crosshair';
        videoContainer.classList.add('screenshot-mode');
      });
      
      videoContainer.addEventListener('mouseup', (e) => {
        if (!isMouseDown) return;
        
        const holdDuration = Date.now() - mouseDownTime;
        isMouseDown = false;
        
        // Remove visual feedback
        videoContainer.style.cursor = '';
        videoContainer.classList.remove('screenshot-mode');
        
        // If held for at least 100ms, take screenshot
        if (holdDuration >= 100) {
          takeVideoScreenshot();
        }
      });
      
      videoContainer.addEventListener('mouseleave', (e) => {
        if (isMouseDown) {
          isMouseDown = false;
          videoContainer.style.cursor = '';
          videoContainer.classList.remove('screenshot-mode');
        }
      });
    }
    
    async function takeVideoScreenshot() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
      
      if (!activeVideo || activeVideo.videoWidth === 0) {
        showNotification('No video to capture', 'error');
        return;
      }
      
      try {
        // Set canvas dimensions to match video
        screenshotCanvas.width = activeVideo.videoWidth;
        screenshotCanvas.height = activeVideo.videoHeight;
        
        // Draw video frame to canvas
        screenshotContext.drawImage(activeVideo, 0, 0);
        
        // Add timestamp overlay
        const currentTime = formatTime(activeVideo.currentTime);
        const actualTime = streamStartTime ? 
          new Date(streamStartTime.getTime() + (activeVideo.currentTime * 1000)).toLocaleTimeString() : 
          new Date().toLocaleTimeString();
        
        // Add semi-transparent overlay for timestamp
        screenshotContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
        screenshotContext.fillRect(10, 10, 200, 60);
        
        // Add timestamp text
        screenshotContext.fillStyle = 'white';
        screenshotContext.font = '16px Arial';
        screenshotContext.fillText(`Video: ${currentTime}`, 20, 35);
        screenshotContext.fillText(`Time: ${actualTime}`, 20, 55);
        
        // Convert to blob and copy to clipboard
        screenshotCanvas.toBlob(async (blob) => {
          try {
            await navigator.clipboard.write([
              new ClipboardItem({ 'image/png': blob })
            ]);
            
            showNotification('Screenshot copied to clipboard! 📸', 'success');
            
            // Auto-paste if possible (requires user gesture)
            setTimeout(() => {
              document.execCommand('paste');
            }, 100);
            
          } catch (error) {
            console.error('Failed to copy screenshot:', error);
            showNotification('Failed to copy screenshot', 'error');
          }
        }, 'image/png');
        
      } catch (error) {
        console.error('Screenshot error:', error);
        showNotification('Screenshot failed', 'error');
      }
    }
    
    // ===== LIVE STATUS AND CLOCK DISPLAY =====
    function updateLiveStatus() {
      const video = document.getElementById('video');
      const timeDiff = Math.abs(video.currentTime - instructorTime);
      isLive = timeDiff < 3; // Within 3 seconds is considered "live"
      
      updateClockDisplay();
      updateSyncStatus();
      updateTimelineRestrictions();
    }
    
    function updateTimelineRestrictions() {
      const timeline = document.getElementById('timeline');
      if (!timeline || !instructorTime) return;
      
      // Add visual indicator of allowed scrub area
      const container = timeline.querySelector('.timeline-container');
      if (!container) return;
      
      // Remove existing restriction overlay
      const existingOverlay = timeline.querySelector('.timeline-restriction-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      // Create restriction overlay for areas beyond instructor time
      const video = document.getElementById('video');
      if (!video.duration) return;
      
      const restrictionOverlay = document.createElement('div');
      restrictionOverlay.className = 'timeline-restriction-overlay';
      
      const instructorProgress = instructorTime / video.duration;
      const restrictionStart = (instructorProgress * 100) + 2; // 2% buffer
      
      restrictionOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: ${restrictionStart}%;
        right: 0;
        height: 100%;
        background: linear-gradient(90deg, transparent 0%, rgba(229, 62, 62, 0.3) 20%, rgba(229, 62, 62, 0.5) 100%);
        pointer-events: none;
        z-index: 15;
        border-left: 2px solid rgba(229, 62, 62, 0.8);
      `;
      
      timeline.appendChild(restrictionOverlay);
    }
    
    function updateSyncStatus() {
      const syncStatus = document.getElementById('syncStatus');
      const syncStatusText = document.getElementById('syncStatusText');
      const jumpToLiveBtn = document.getElementById('jumpToLiveBtn');
      
      if (!syncStatus || !syncStatusText) return;
      
      syncStatus.style.display = 'flex';
      
      if (isLive) {
        syncStatus.className = 'sync-status live';
        syncStatusText.textContent = 'LIVE';
        if (jumpToLiveBtn) jumpToLiveBtn.style.display = 'none';
      } else {
        syncStatus.className = 'sync-status behind';
        syncStatusText.textContent = 'BEHIND';
        if (jumpToLiveBtn) jumpToLiveBtn.style.display = 'block';
      }
    }
    
    function updateClockDisplay() {
      const clockDisplay = document.getElementById('clockDisplay');
      if (!clockDisplay) return;
      
      const video = document.getElementById('video');
      const currentVideoTime = video.currentTime || 0;
      
      // Calculate actual time based on stream start time and video position
      let displayTime = '--:--:--';
      let liveStatus = '-';
      
      if (streamStartTime) {
        const actualTime = new Date(streamStartTime.getTime() + (currentVideoTime * 1000));
        displayTime = actualTime.toLocaleTimeString();
        liveStatus = isLive ? 'LIVE' : '-';
      }
      
      clockDisplay.innerHTML = `${displayTime} <span style="margin-left: 10px; font-weight: bold; color: ${isLive ? '#22c55e' : '#6b7280'}">${liveStatus}</span>`;
      
      // Update clock display styling based on live status
      clockDisplay.className = `clock-display ${isLive ? '' : 'not-live'}`;
      
      // Update timeline visual state
      updateTimelineVisualState();
    }
    
    function updateTimelineVisualState() {
      const timeline = document.getElementById('timeline');
      if (!timeline) return;
      
      const video = document.getElementById('video');
      if (!video.duration) return;
      
      // Update timeline progress indicators
      updateTimelineProgress();
      
      // Update time display
      updateTimeDisplay();
      
      // Generate dynamic tick marks
      updateTimelineTicks();
    }
    
    function updateTimelineProgress() {
      const timeline = document.getElementById('timeline');
      const video = document.getElementById('video');
      
      if (!timeline || !video.duration) return;
      
      // Remove existing progress indicators
      const existingProgress = timeline.querySelectorAll('.timeline-progress-indicator');
      existingProgress.forEach(el => el.remove());
      
      // Add student progress indicator
      const studentProgress = (video.currentTime / video.duration) * 100;
      const studentIndicator = document.createElement('div');
      studentIndicator.className = 'timeline-progress-indicator student-progress';
      studentIndicator.style.cssText = `
        position: absolute;
        top: 0;
        left: ${studentProgress}%;
        width: 2px;
        height: 100%;
        background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
        z-index: 18;
        box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
      `;
      timeline.appendChild(studentIndicator);
      
      // Add instructor progress indicator if different
      if (instructorTime && video.duration) {
        const instructorProgress = (instructorTime / video.duration) * 100;
        if (Math.abs(instructorProgress - studentProgress) > 1) {
          const instructorIndicator = document.createElement('div');
          instructorIndicator.className = 'timeline-progress-indicator instructor-progress';
          instructorIndicator.style.cssText = `
            position: absolute;
            top: 0;
            left: ${instructorProgress}%;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            z-index: 19;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
            border-radius: 1px;
          `;
          timeline.appendChild(instructorIndicator);
        }
      }
    }
    
    function updateTimeDisplay() {
      // Update or create time display
      let timeDisplay = document.getElementById('timelineTimeDisplay');
      if (!timeDisplay) {
        timeDisplay = document.createElement('div');
        timeDisplay.id = 'timelineTimeDisplay';
        timeDisplay.style.cssText = `
          position: absolute;
          bottom: -30px;
          left: 20px;
          color: var(--text-secondary);
          font-size: 12px;
          font-family: 'Courier New', monospace;
          background: rgba(0, 0, 0, 0.7);
          padding: 4px 8px;
          border-radius: 4px;
          backdrop-filter: blur(5px);
        `;
        document.getElementById('timeline').appendChild(timeDisplay);
      }
      
      const video = document.getElementById('video');
      const currentTime = formatTime(video.currentTime || 0);
      const duration = formatTime(video.duration || 0);
      const instructorTimeStr = formatTime(instructorTime || 0);
      
      timeDisplay.innerHTML = `
        Student: ${currentTime} / ${duration}<br>
        Instructor: ${instructorTimeStr} ${isLive ? '🔴 LIVE' : '⏸️'}
      `;
    }
    
    function updateTimelineTicks() {
      const timeline = document.getElementById('timeline');
      const video = document.getElementById('video');
      
      if (!timeline || !video.duration) return;
      
      // Remove existing ticks
      const existingTicks = timeline.querySelectorAll('.dynamic-time-tick');
      existingTicks.forEach(el => el.remove());
      
      // Add major ticks every 30 seconds, minor ticks every 10 seconds
      const duration = video.duration;
      const timelineWidth = timeline.offsetWidth;
      
      for (let time = 0; time <= duration; time += 10) {
        const isMajor = time % 30 === 0;
        const position = (time / duration) * 100;
        
        const tick = document.createElement('div');
        tick.className = `dynamic-time-tick ${isMajor ? 'major' : 'minor'}`;
        tick.style.cssText = `
          position: absolute;
          top: ${isMajor ? '0' : '10px'};
          left: ${position}%;
          width: 1px;
          height: ${isMajor ? '100%' : '50%'};
          background: ${isMajor ? 'rgba(255, 255, 255, 0.6)' : 'rgba(255, 255, 255, 0.3)'};
          z-index: 10;
          pointer-events: none;
        `;
        
        if (isMajor && time > 0) {
          const label = document.createElement('div');
          label.style.cssText = `
            position: absolute;
            top: -20px;
            left: -15px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            width: 30px;
            text-align: center;
            pointer-events: none;
          `;
          label.textContent = formatTime(time);
          tick.appendChild(label);
        }
        
        timeline.appendChild(tick);
      }
    }
    
    // ===== MODIFIED CONTROL FUNCTIONS =====
    function togglePlayPause() {
      // Students can pause/play but will fall behind live stream
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
      
      if (!activeVideo) return;
      
      if (activeVideo.paused) {
        // Student wants to resume
        activeVideo.play().catch(e => console.log('Play prevented:', e));
        showNotification('Resumed - You may be behind live stream', 'info');
        
        // Check if they're behind and show jump to live button
        setTimeout(() => {
          const timeDifference = instructorTime - activeVideo.currentTime;
          if (timeDifference > 3) {
            showJumpToLiveButton();
            updateLiveStatus(false);
          }
        }, 1000);
        
      } else {
        // Student wants to pause
        activeVideo.pause();
        showNotification('Paused - Use Jump to Live to catch up', 'info');
        showJumpToLiveButton();
        updateLiveStatus(false);
      }
      
      updatePlayPauseButton(activeVideo.paused);
    }
    
    function rewindVideo() {
      // Students can rewind within the streamed content (DVR functionality)
      const video = document.getElementById('video');
      const newTime = Math.max(0, video.currentTime - 10);
      // Allow rewinding to any point that has been streamed
      video.currentTime = newTime;
      
      // Update live status - student is now behind live if not at instructor time
      const timeDifference = instructorTime - video.currentTime;
      if (timeDifference > 3) { // More than 3 seconds behind
        showJumpToLiveButton();
        updateLiveStatus(false); // Not live anymore
        showNotification(`You are ${Math.round(timeDifference)}s behind live`, 'info');
      }
      
      console.log(`⏪ Rewound to ${formatTime(newTime)}, instructor at ${formatTime(instructorTime)}`);
      
    }
    
    function forwardVideo() {
      // Students cannot fast-forward ahead of instructor
      showNotification('Cannot skip ahead of instructor', 'warning');
    }
    
    // ===== STUDENT VIDEO EVENT HANDLERS =====
    function setupStudentVideoHandlers() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Allow students to pause but prevent seeking ahead
      [video, webrtcVideo].forEach(vid => {
        if (!vid) return;
        
        vid.addEventListener('play', (e) => {
          // Students can play/resume, but check if they're behind live
          console.log('▶️ Student resumed playback');
          setTimeout(() => {
            const timeDifference = instructorTime - vid.currentTime;
            if (timeDifference > 3) {
              showJumpToLiveButton();
              updateLiveStatus(false);
              showNotification(`You are ${Math.round(timeDifference)}s behind live`, 'info');
            }
          }, 500);
        });
        
        vid.addEventListener('pause', (e) => {
          // Students can pause - they'll fall behind live
          console.log('⏸️ Student paused playback');
          showJumpToLiveButton();
          updateLiveStatus(false);
        });
        
        vid.addEventListener('seeking', (e) => {
          // Prevent seeking ahead of instructor, but allow seeking backward
          if (vid.currentTime > instructorTime + 2) {
            console.log('🚫 Student tried to seek ahead - correcting');
            vid.currentTime = instructorTime;
            showNotification('Cannot seek ahead of instructor', 'warning');
          } else {
            // Allow seeking backward - check if they're now behind live
            const timeDifference = instructorTime - vid.currentTime;
            if (timeDifference > 3) {
              showJumpToLiveButton();
              updateLiveStatus(false);
            } else {
              hideJumpToLiveButton();
              updateLiveStatus(true);
            }
          }
        });
        
        vid.addEventListener('timeupdate', (e) => {
          // Continuously check if student is in sync with live stream
          if (instructorPlaying) {
            const timeDifference = instructorTime - vid.currentTime;
            if (timeDifference > 5) {
              // Student is significantly behind
              if (!document.getElementById('jumpToLiveBtn').style.display || 
                  document.getElementById('jumpToLiveBtn').style.display === 'none') {
                showJumpToLiveButton();
                updateLiveStatus(false);
              }
            } else if (timeDifference < 2) {
              // Student is close to live
              hideJumpToLiveButton();
              updateLiveStatus(true);
            }
          }
        });
      });
      
      console.log('✅ Student video event handlers set up');
    }
    
    function jumpToLive() {
      const video = document.getElementById('video');
      video.currentTime = instructorTime;
      updateLiveStatus(true); // Back to live
      hideJumpToLiveButton();
      showNotification('Jumped to live stream', 'success');
      console.log(`🔴 Jumped to live: ${formatTime(instructorTime)}`);
    }
    
    function showJumpToLiveButton() {
      const jumpToLiveBtn = document.getElementById('jumpToLiveBtn');
      if (jumpToLiveBtn) {
        jumpToLiveBtn.style.display = 'block';
      }
    }
    
    function hideJumpToLiveButton() {
      const jumpToLiveBtn = document.getElementById('jumpToLiveBtn');
      if (jumpToLiveBtn) {
        jumpToLiveBtn.style.display = 'none';
      }
    }
    
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // ===== UTILITY FUNCTIONS =====
    function updatePlayPauseButton(showPlay) {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) {
        playPauseBtn.innerHTML = showPlay ? '▶' : '⏸';
      }
    }
    
    function showNotification(message, type = 'info') {
      // Create a simple notification
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: ${type === 'warning' ? '#f59e0b' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 1000;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideIn 0.3s ease-out;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
    
    // ===== THUMBNAIL CAPTURE SYSTEM =====
    function captureVideoThumbnail(video, time) {
      try {
        if (!video || video.readyState < 2) return null;
        
        const canvas = document.createElement('canvas');
        canvas.width = 50;
        canvas.height = 28;
        const ctx = canvas.getContext('2d');
        
        // Draw the current video frame
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        return canvas;
      } catch (e) {
        console.log('Thumbnail capture failed:', e);
        return null;
      }
    }
    
    function updateThumbnailCache() {
      const video = document.getElementById('video');
      if (!video || !video.currentTime) return;
      
      const currentTime = Math.floor(video.currentTime);
      
      // Capture thumbnail every second if we don't have one for this time
      if (currentTime !== lastThumbnailTime && !thumbnailCache.has(currentTime)) {
        const thumbnail = captureVideoThumbnail(video, currentTime);
        if (thumbnail) {
          thumbnailCache.set(currentTime, thumbnail);
          console.log(`📸 Captured thumbnail for time: ${currentTime}s`);
        }
        lastThumbnailTime = currentTime;
      }
    }
    
    // Start thumbnail capture system
    function startThumbnailCapture() {
      // Capture thumbnails every 500ms during playback
      setInterval(() => {
        const video = document.getElementById('video');
        if (video && !video.paused && video.currentTime > 0) {
          updateThumbnailCache();
          
          // Clean up old thumbnails to prevent memory issues
          // Keep only thumbnails from the last 10 minutes (600 seconds)
          const currentTime = Math.floor(video.currentTime);
          const cutoffTime = currentTime - 600;
          
          for (let [time, thumbnail] of thumbnailCache.entries()) {
            if (time < cutoffTime) {
              thumbnailCache.delete(time);
            }
          }
        }
      }, 500);
    }
    
    // Function to manually capture thumbnail at specific time (for instructor sync)
    function captureThumbnailAtTime(time) {
      const video = document.getElementById('video');
      if (!video) return;
      
      const timeKey = Math.floor(time);
      if (!thumbnailCache.has(timeKey)) {
        const thumbnail = captureVideoThumbnail(video, time);
        if (thumbnail) {
          thumbnailCache.set(timeKey, thumbnail);
          console.log(`📸 Manually captured thumbnail for time: ${timeKey}s`);
        }
      }
    }
    
    // ===== ENHANCED TIMELINE CLASS =====
    class EnhancedTimeline {
      constructor(canvasId, videoId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.video = document.getElementById(videoId);
        
        // Timeline configuration
        this.zoomLevels = [1, 2, 5, 10, 30]; // seconds per 50px
        this.zoomIndex = 2; // Default zoom level
        this.tickPx = 50; // Pixels between ticks
        this.dragging = false;
        this.dragOffset = 0;
        
        // Thumbnail cache
        this.thumbnailCache = new Map();
        
        this.setupEventListeners();
        this.startRenderLoop();
      }
      
      setupEventListeners() {
        // Mouse drag for seeking
        this.canvas.addEventListener('mousedown', (e) => {
          this.dragging = true;
          const rect = this.canvas.getBoundingClientRect();
          this.dragOffset = e.clientX - rect.width / 2;
        });
        
        window.addEventListener('mousemove', (e) => {
          if (!this.dragging) return;
          const rect = this.canvas.getBoundingClientRect();
          const delta = e.clientX - rect.width / 2;
          const scale = this.zoomLevels[this.zoomIndex];
          const deltaTime = (delta / this.tickPx) * scale;
          
          // For students, prevent seeking ahead of instructor
          const newTime = Math.min(this.video.duration || instructorTime, 
                                 Math.max(0, this.video.currentTime + deltaTime));
          
          if (newTime <= instructorTime + 2) { // Allow small buffer
            this.video.currentTime = newTime;
          }
        });
        
        window.addEventListener('mouseup', () => {
          this.dragging = false;
          this.dragOffset = 0;
        });
        
        // Hover time display
        this.canvas.addEventListener('mousemove', (e) => {
          const rect = this.canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const centerX = rect.width / 2;
          const deltaX = x - centerX;
          const scale = this.zoomLevels[this.zoomIndex];
          const hoverTime = this.video.currentTime + (deltaX / this.tickPx) * scale;
          
          const hoverLabel = document.getElementById('timelineHoverLabel');
          if (hoverLabel) {
            hoverLabel.style.left = `${e.clientX}px`;
            hoverLabel.style.top = `${e.clientY}px`;
            hoverLabel.textContent = this.formatTime(hoverTime);
            hoverLabel.style.display = 'block';
          }
        });
        
        this.canvas.addEventListener('mouseleave', () => {
          const hoverLabel = document.getElementById('timelineHoverLabel');
          if (hoverLabel) hoverLabel.style.display = 'none';
        });
        
        // Mouse wheel zoom
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          this.zoomIndex += Math.sign(e.deltaY);
          this.zoomIndex = Math.max(0, Math.min(this.zoomLevels.length - 1, this.zoomIndex));
        }, { passive: false });
        
        // Zoom buttons
        const zoomIn = document.getElementById('zoomIn');
        const zoomOut = document.getElementById('zoomOut');
        if (zoomIn) zoomIn.addEventListener('click', () => this.zoomIn());
        if (zoomOut) zoomOut.addEventListener('click', () => this.zoomOut());
      }
      
      zoomIn() {
        this.zoomIndex = Math.max(0, this.zoomIndex - 1);
      }
      
      zoomOut() {
        this.zoomIndex = Math.min(this.zoomLevels.length - 1, this.zoomIndex + 1);
      }
      
      formatTime(sec) {
        sec = Math.max(0, sec);
        const h = Math.floor(sec / 3600);
        const m = Math.floor((sec % 3600) / 60);
        const s = Math.floor(sec % 60);
        return h ? `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}` : 
                  `${m}:${s.toString().padStart(2, '0')}`;
      }
      
      generateThumbnail(time) {
        try {
          if (!this.video || this.video.readyState < 2) return null;
          
          const canvas = document.createElement('canvas');
          canvas.width = 50;
          canvas.height = 28;
          const ctx = canvas.getContext('2d');
          
          // Draw current frame (don't change video time during playback)
          ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);
          
          return canvas;
        } catch (e) {
          return null;
        }
      }
      
      render() {
        const w = this.canvas.width = this.canvas.offsetWidth;
        const h = this.canvas.height = this.canvas.offsetHeight;
        this.ctx.clearRect(0, 0, w, h);
        
        const centerX = w / 2;
        const now = this.video.currentTime;
        const scale = this.zoomLevels[this.zoomIndex];
        const totalTicks = Math.ceil(w / this.tickPx) + 4;
        
        // Draw thumbnail strip from cached frames at specific times
        try {
          const thumbCount = Math.floor(w / 50);
          for (let i = 0; i < thumbCount; i++) {
            const t = now - ((thumbCount / 2 - i) * scale);
            if (t >= 0 && t <= (this.video.duration || instructorTime)) {
              // Look for cached thumbnail at this time (rounded to nearest second)
              const timeKey = Math.floor(t);
              const cachedThumbnail = thumbnailCache.get(timeKey);
              
              if (cachedThumbnail) {
                // Draw the cached thumbnail from that specific time
                this.ctx.drawImage(cachedThumbnail, i * 50, h - 30, 50, 30);
              } else {
                // No cached thumbnail - draw a placeholder or try to capture current frame
                this.ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
                this.ctx.fillRect(i * 50, h - 30, 50, 30);
                
                // Draw time label on placeholder
                this.ctx.fillStyle = "#666";
                this.ctx.font = "8px monospace";
                this.ctx.textAlign = "center";
                this.ctx.fillText(this.formatTime(t), i * 50 + 25, h - 15);
              }
            }
          }
        } catch (e) {
          // Thumbnail generation failed, continue without thumbnails
          console.log('Thumbnail rendering skipped:', e.message);
        }
        
        // Draw background (matching the dark theme)
        this.ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        this.ctx.fillRect(0, 0, w, h - 30);
        
        // Draw time ticks and labels
        this.ctx.strokeStyle = "#888";
        this.ctx.fillStyle = "#aaa";
        this.ctx.font = "11px monospace";
        this.ctx.textAlign = "center";
        
        for (let i = -totalTicks / 2; i < totalTicks / 2; i++) {
          const t = now + i * scale;
          if (t < 0 || t > (this.video.duration || instructorTime)) continue;
          
          const x = centerX + i * this.tickPx;
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, h * 0.2);
          this.ctx.stroke();
          this.ctx.fillText(this.formatTime(t), x, h * 0.25);
        }
        
        // Draw live edge indicator (for students)
        if (instructorTime > now && !isInstructor) {
          const liveX = centerX + ((instructorTime - now) / scale) * this.tickPx;
          if (liveX >= 0 && liveX <= w) {
            // Live edge line with glow effect
            this.ctx.strokeStyle = "#22c55e";
            this.ctx.lineWidth = 3;
            this.ctx.shadowColor = "#22c55e";
            this.ctx.shadowBlur = 10;
            this.ctx.beginPath();
            this.ctx.moveTo(liveX, 0);
            this.ctx.lineTo(liveX, h - 30);
            this.ctx.stroke();
            
            // Reset shadow
            this.ctx.shadowBlur = 0;
            
            // Live label with background
            this.ctx.fillStyle = "#22c55e";
            this.ctx.fillRect(liveX - 15, 2, 30, 12);
            this.ctx.fillStyle = "#000";
            this.ctx.font = "9px sans-serif";
            this.ctx.textAlign = "center";
            this.ctx.fillText("LIVE", liveX, 11);
          }
        }
        
        // Draw current playhead (red line with glow)
        this.ctx.strokeStyle = "#e91e63";
        this.ctx.lineWidth = 3;
        this.ctx.shadowColor = "#e91e63";
        this.ctx.shadowBlur = 8;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX + this.dragOffset, 0);
        this.ctx.lineTo(centerX + this.dragOffset, h);
        this.ctx.stroke();
        
        // Reset shadow
        this.ctx.shadowBlur = 0;
        
        // Draw zoom level indicator
        this.ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        this.ctx.font = "10px sans-serif";
        this.ctx.textAlign = "left";
        this.ctx.fillText(`${scale}s/tick`, 10, h - 10);
      }
      
      startRenderLoop() {
        const renderFrame = () => {
          this.render();
          requestAnimationFrame(renderFrame);
        };
        renderFrame();
      }
    }
    
    // ===== INSTRUCTOR SCREEN SHARING =====
    let localStream = null;
    let peerConnections = new Map(); // Map of student socket IDs to peer connections
    
    async function startScreenShare() {
      try {
        console.log('🎥 Starting screen share...');
        
        // Get screen share stream
        localStream = await navigator.mediaDevices.getDisplayMedia({
          video: {
            mediaSource: 'screen',
            width: { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 30 }
          },
          audio: true
        });
        
        console.log('✅ Screen capture started');
        
        // Update UI
        document.getElementById('startStreamBtn').style.display = 'none';
        document.getElementById('stopStreamBtn').style.display = 'block';
        
        // Show local preview
        const video = document.getElementById('video');
        video.srcObject = localStream;
        video.play();
        
        // Notify server that stream started
        socket.emit('stream:started', {
          room: currentRoom
        });
        
        // Also notify via the existing WebRTC system
        const urlParams = new URLSearchParams(window.location.search);
        const classId = urlParams.get('class') || 'default-class';
        
        socket.emit('instructor-start-webrtc', {
          classId: classId,
          mediaType: 'Screen Share'
        });
        
        // Handle stream end (user clicks stop sharing in browser)
        localStream.getVideoTracks()[0].addEventListener('ended', () => {
          console.log('📺 Screen sharing ended by user');
          stopScreenShare();
        });
        
        // Request list of current students to create connections
        socket.emit('get:room-members', { room: currentRoom });
        
        console.log('🚀 Stream is now live!');
        
      } catch (error) {
        console.error('❌ Error starting screen share:', error);
        showNotification('Failed to start screen sharing. Please allow screen access.', 'error');
      }
    }
    
    function stopScreenShare() {
      console.log('⏹️ Stopping screen share...');
      
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      
      // Close all peer connections
      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();
      
      // Update UI
      document.getElementById('startStreamBtn').style.display = 'block';
      document.getElementById('stopStreamBtn').style.display = 'none';
      
      // Clear video
      const video = document.getElementById('video');
      video.srcObject = null;
      
      // Notify server that stream stopped
      socket.emit('stream:stopped', {
        room: currentRoom
      });
      
      console.log('✅ Stream stopped');
    }
    
    // Handle new student joining (create peer connection)
    async function handleStudentJoined(studentSocketId) {
      if (!localStream || !isInstructor) return;
      
      console.log('👨‍🎓 New student joined:', studentSocketId);
      
      try {
        // Create peer connection for this student
        const peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });
        
        // Add local stream to peer connection
        localStream.getTracks().forEach(track => {
          peerConnection.addTrack(track, localStream);
        });
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            socket.emit('webrtc-ice-candidate', {
              room: currentRoom,
              candidate: event.candidate,
              targetStudent: studentSocketId
            });
          }
        };
        
        // Create offer for student
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        
        // Store peer connection
        peerConnections.set(studentSocketId, peerConnection);
        
        // Send offer to student
        socket.emit('webrtc-offer', {
          room: currentRoom,
          offer: offer,
          targetStudent: studentSocketId
        });
        
        console.log('📤 Sent WebRTC offer to student:', studentSocketId);
        
      } catch (error) {
        console.error('❌ Error creating peer connection for student:', error);
      }
    }
    
    // Handle WebRTC answer from student
    async function handleWebRTCAnswer(data) {
      const peerConnection = peerConnections.get(data.fromStudent);
      if (peerConnection) {
        try {
          await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
          console.log('✅ WebRTC connection established with student:', data.fromStudent);
        } catch (error) {
          console.error('❌ Error handling WebRTC answer:', error);
        }
      }
    }
    
    // Handle ICE candidate from student
    async function handleICECandidate(data) {
      const peerConnection = peerConnections.get(data.fromStudent);
      if (peerConnection) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        } catch (error) {
          console.error('❌ Error adding ICE candidate:', error);
        }
      }
    }
    
    // ===== INITIALIZATION =====
    function initializeStreamViewer() {
      console.log('📚 Initializing stream viewer for class:', classId);
      
      if (!classId) {
        console.error('❌ No class ID available');
        showStreamStatusOverlay('Class Not Found - No class ID specified');
        return;
      }
      
      // Show waiting message by default
      showWaitingMessage();
      
      // Initialize Socket.IO
      initializeSocket();
      
      // Detect user role
      detectUserRole();
      
      // Enforce timeline restrictions for students
      if (!isInstructor) {
        initializeLiveEdgeEnforcement();
      }
      
      // Set up student video event handlers
      setupStudentVideoHandlers();
      
      // Initialize enhanced timeline and thumbnail capture
      try {
        window.enhancedTimeline = new EnhancedTimeline('timelineCanvas', 'video');
        startThumbnailCapture();
        console.log('✅ Enhanced Timeline and thumbnail capture initialized');
      } catch (error) {
        console.warn('⚠️ Timeline initialization failed:', error);
      }
      
      // Join the appropriate room based on role
      joinStreamingRoom();
      
      // Start regular updates
      setInterval(updateLiveStatus, 1000);
      setInterval(updateClockDisplay, 1000);
    }
    
    function showErrorMessage(title, message) {
      showStreamStatusOverlay(`${title}: ${message}`);
    }
    
    async function fetchClassInfo() {
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('✅ Class info loaded:', data);
          
          // If socket is connected, join the class
          if (socket && socket.connected) {
            socket.emit('student-join-class', { classId });
          }
        } else {
          throw new Error(`Failed to fetch class info: ${response.status}`);
        }
      } catch (error) {
        console.error('❌ Error fetching class info:', error);
        showErrorMessage('Connection Error', 'Failed to connect to the class stream.');
      }
    }

    // Initialize when page loads
    window.addEventListener('DOMContentLoaded', function() {
      console.log('🚀 SMXStream-new page loaded');
      
      // Show welcome modal
      showWelcomeModal();
      
      // Initialize stream viewer functionality
      initializeStreamViewer();
      
      // Initialize enhanced canvas timeline
      setTimeout(() => {
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        const activeVideoId = (video && video.style.display !== 'none') ? 'video' : 'webrtcVideo';
        
        try {
          window.enhancedTimeline = new EnhancedTimeline('timelineCanvas', 'video');
          console.log('✅ Enhanced Timeline initialized with:', activeVideoId);
        } catch (error) {
          console.warn('⚠️ Timeline initialization failed:', error);
        }
      }, 500);
    });

    // Check for live stream video from localStorage and autoplay
    function checkForLiveStreamVideo() {
      try {
        const liveStreamVideoData = localStorage.getItem('liveStreamVideo');
        if (liveStreamVideoData) {
          const videoData = JSON.parse(liveStreamVideoData);
          console.log('🎬 Found live stream video in localStorage:', videoData.name);
          
          // Load and autoplay the video
          loadLiveStreamVideo(videoData);
          
          // Clear the localStorage entry after loading
          localStorage.removeItem('liveStreamVideo');
          console.log('🧹 Cleared live stream video from localStorage');
        } else {
          console.log('📭 No live stream video found in localStorage');
        }
      } catch (error) {
        console.error('❌ Error checking for live stream video:', error);
      }
    }

    // Load and autoplay the live stream video
    function loadLiveStreamVideo(videoData) {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      if (!video) {
        console.error('❌ Video element not found');
        return;
      }
      
      console.log('🚀 Loading live stream video:', videoData.name);
      
      // Hide WebRTC video and show regular video
      if (webrtcVideo) {
        webrtcVideo.style.display = 'none';
      }
      video.style.display = 'block';
      
      // Set video source
      video.src = videoData.url;
      
      // Set up event listeners for autoplay
      video.addEventListener('loadeddata', function() {
        console.log('✅ Live stream video data loaded');
        
        // Hide stream status overlay when video loads
        hideStreamStatusOverlay();
        isStreamActive = true;
        
        // Attempt to autoplay
        video.play().then(() => {
          console.log('▶️ Live stream video started playing automatically');
          
          // Update UI to show live status
          updateLiveStatus(true);
          
          // Update video title
          updateVideoTitle(videoData.name);
          
        }).catch(error => {
          console.log('🔇 Autoplay prevented, user interaction required:', error);
          
          // Show play button overlay or notification
          showPlayPrompt(videoData.name);
        });
      }, { once: true });
      
      video.addEventListener('error', function(e) {
        console.error('❌ Error loading live stream video:', e);
        showErrorMessage('Video Load Error', 'Failed to load the live stream video. Please try again.');
      }, { once: true });
      
      // Load the video
      video.load();
    }

    // Update live status indicator
    function updateLiveStatus(isLive) {
      const liveBadge = document.querySelector('.live-badge');
      if (liveBadge) {
        if (isLive) {
          liveBadge.classList.remove('hidden');
          liveBadge.textContent = 'LIVE';
        } else {
          liveBadge.classList.add('hidden');
        }
      }
    }

    // Update video title
    function updateVideoTitle(title) {
      const videoTitle = document.querySelector('.video-title');
      if (videoTitle) {
        videoTitle.textContent = title || 'Live Stream';
      }
    }

    // Show play prompt when autoplay is prevented
    function showPlayPrompt(videoName) {
      // Create a play prompt overlay
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      const playPrompt = document.createElement('div');
      playPrompt.className = 'play-prompt-overlay';
      playPrompt.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        color: white;
        text-align: center;
        padding: 2rem;
      `;
      
      playPrompt.innerHTML = `
        <div style="font-size: 1.5rem; margin-bottom: 1rem;">🎬 ${videoName}</div>
        <div style="font-size: 1rem; margin-bottom: 2rem; opacity: 0.8;">Click to start the live stream</div>
        <button style="
          background: var(--primary-gradient);
          border: 2px solid var(--accent);
          color: white;
          font-size: 1.2rem;
          padding: 1rem 2rem;
          border-radius: 50px;
          cursor: pointer;
          transition: all 0.3s ease;
        ">▶️ Play Live Stream</button>
      `;
      
      const playButton = playPrompt.querySelector('button');
      playButton.addEventListener('click', () => {
        const video = document.getElementById('video');
        video.play().then(() => {
          console.log('▶️ Live stream started after user interaction');
          updateLiveStatus(true);
          videoContainer.removeChild(playPrompt);
        }).catch(error => {
          console.error('❌ Failed to play video after user interaction:', error);
        });
      });
      
      videoContainer.appendChild(playPrompt);
    }
    
    // Error message display function
    function showErrorMessage(title, message) {
      // Hide loading spinner
      loading.style.display = 'none';
      
      // Create error overlay
      const errorOverlay = document.createElement('div');
      errorOverlay.className = 'welcome-modal show';
      errorOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ef4444; display: flex; align-items: center; gap: 0.5rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
              <line x1="12" y1="9" x2="12" y2="13"></line>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            ${title}
          </h2>
          <div class="welcome-text">
            <p>${message}</p>
            <div style="margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border-left: 4px solid #ef4444;">
              <strong>Quick Fixes:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>Make sure you're logged in to the system</li>
                <li>Access the stream through the dashboard or class page</li>
                <li>Check that the class ID in the URL is correct</li>
                <li>Contact your instructor if the problem persists</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="goToDashboard()">Go to Dashboard</button>
            <button class="welcome-close" onclick="retryConnection()" style="background: #22c55e;">Retry</button>
            <button class="welcome-close" onclick="openDebugTool()" style="background: #ff9800;">Debug Tool</button>
            <button class="welcome-close" onclick="testWebRTCConnection()" style="background: #8b5cf6;">Test WebRTC</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(errorOverlay);
    }
    
    function goToDashboard() {
      window.location.href = '/dashboard.html';
    }
    
    function retryConnection() {
      // Remove error overlay
      const errorOverlay = document.querySelector('.welcome-modal');
      if (errorOverlay) {
        errorOverlay.remove();
      }
      
      // Show loading and retry
      loading.style.display = 'block';
      fetchClassInfo();
    }
    
    function openDebugTool() {
      window.open('/debug-stream.html', '_blank');
    }
    
    // Test WebRTC connection manually
    function testWebRTCConnection() {
      console.log('🧪 Testing WebRTC connection...');
      console.log('📊 Current state:');
      console.log('  - Class ID:', classId);
      console.log('  - WebRTC Socket:', webrtcSocket ? 'Connected' : 'Not connected');
      console.log('  - Peer Connection:', peerConnection ? 'Exists' : 'None');
      console.log('  - WebRTC Video Element:', webrtcVideo);
      console.log('  - Is WebRTC Mode:', isWebRTCMode);
      
      // Force switch to WebRTC mode for testing
      switchToWebRTCMode();
      
      // Test video element
      if (webrtcVideo) {
        console.log('📺 WebRTC Video Element Properties:');
        console.log('  - Display:', webrtcVideo.style.display);
        console.log('  - Source Object:', webrtcVideo.srcObject);
        console.log('  - Autoplay:', webrtcVideo.autoplay);
        console.log('  - Muted:', webrtcVideo.muted);
      }
    }
    
    // Test streaming connection end-to-end
    async function testStreamingConnection() {
      console.log('🧪 Testing streaming connection...');
      
      const results = {
        classId: classId || 'Not set',
        streamKey: streamKey || 'Not set',
        socketConnection: false,
        hlsServer: false,
        streamEndpoint: false,
        streamStatus: 'Unknown'
      };
      
      try {
        // Test 1: Check if we have class ID
        if (!classId) {
          console.error('❌ No class ID available');
          return results;
        }
        
        // Test 2: Check Socket.IO connection
        if (typeof io !== 'undefined') {
          results.socketConnection = true;
          console.log('✅ Socket.IO is available');
        } else {
          console.error('❌ Socket.IO not available');
        }
        
        // Test 3: Check HLS server
        try {
          const hlsTestUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          const hlsResponse = await fetch(hlsTestUrl, { method: 'HEAD' });
          results.hlsServer = hlsResponse.ok;
          console.log(hlsResponse.ok ? '✅ HLS server responding' : '❌ HLS server not responding');
        } catch (error) {
          console.error('❌ HLS server test failed:', error.message);
        }
        
        // Test 4: Check stream status endpoint
        try {
          const authToken = localStorage.getItem('token');
          const statusResponse = await fetch(`/api/stream/status/${classId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });
          
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            results.streamStatus = statusData.status;
            results.streamEndpoint = true;
            console.log('✅ Stream status endpoint working, status:', statusData.status);
          } else {
            console.error('❌ Stream status endpoint failed:', statusResponse.status);
          }
        } catch (error) {
          console.error('❌ Stream status test failed:', error.message);
        }
        
        // Test 5: Test stream start simulation (for instructors only)
        const userRole = localStorage.getItem('role');
        if (userRole === 'instructor' || userRole === 'admin') {
          console.log('👨‍🏫 Instructor detected - testing stream start capability');
          try {
            const authToken = localStorage.getItem('token');
            const testResponse = await fetch(`/api/streams/start/${classId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ source: 'test' })
            });
            
            if (testResponse.ok) {
              console.log('✅ Stream start endpoint accessible');
              // Immediately stop the test stream
              await fetch(`/api/streams/stop/${classId}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({})
              });
            } else {
              console.error('❌ Stream start endpoint failed:', testResponse.status);
            }
          } catch (error) {
            console.error('❌ Stream start test failed:', error.message);
          }
        }
        
        console.log('🧪 Streaming connection test results:', results);
        return results;
        
      } catch (error) {
        console.error('❌ Streaming connection test failed:', error);
        return results;
      }
    }
    
    // Pre-Stream Checklist System
    async function runPreStreamChecklist() {
      console.log('🔍 Running Pre-Stream Checklist...');
      
      const checklist = {
        authentication: { status: 'pending', message: 'Checking authentication...' },
        classAccess: { status: 'pending', message: 'Verifying class access...' },

        studentEnrollment: { status: 'pending', message: 'Checking student enrollment...' },
        streamingInfrastructure: { status: 'pending', message: 'Testing streaming infrastructure...' },
        socketConnection: { status: 'pending', message: 'Establishing real-time connection...' },
        streamStatus: { status: 'pending', message: 'Initializing stream status...' }
      };
      
      // Show checklist if instructor
      const userRole = localStorage.getItem('role');
      if (userRole === 'instructor') {
        showPreStreamChecklist(checklist);
      }
      
      try {
        // 1. Authentication Check
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          checklist.authentication = { status: 'failed', message: 'No authentication token found' };
          throw new Error('Authentication required');
        }
        
        // Verify token with server
        const authResponse = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!authResponse.ok) {
          checklist.authentication = { status: 'failed', message: 'Invalid or expired token' };
          throw new Error('Authentication failed');
        }
        
        checklist.authentication = { status: 'success', message: 'Authentication verified' };
        updateChecklistItem('authentication', checklist.authentication);
        
        // 2. Class Access Check
        const classResponse = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!classResponse.ok) {
          if (classResponse.status === 403) {
            checklist.classAccess = { status: 'failed', message: 'Access denied to this class' };
          } else if (classResponse.status === 404) {
            checklist.classAccess = { status: 'failed', message: 'Class not found' };
          } else {
            checklist.classAccess = { status: 'failed', message: `Server error: ${classResponse.status}` };
          }
          throw new Error('Class access failed');
        }
        
        const classData = await classResponse.json();
        checklist.classAccess = { status: 'success', message: `Access granted to "${classData.currentLesson?.title || 'class'}"` };
        updateChecklistItem('classAccess', checklist.classAccess);
        
        // 3. Student Enrollment Check
        const enrollmentCount = classData.session?.enrolledStudents || 0;
        if (enrollmentCount === 0) {
          checklist.studentEnrollment = { status: 'warning', message: 'No students enrolled yet' };
        } else {
          checklist.studentEnrollment = { status: 'success', message: `${enrollmentCount} students enrolled` };
        }
        updateChecklistItem('studentEnrollment', checklist.studentEnrollment);
        
        // 5. Streaming Infrastructure Check
        const hlsServerUrl = process.env.HLS_SERVER_URL || 'http://127.0.0.1:8888';
        try {
          const infraResponse = await fetch(`${hlsServerUrl}/health`, { method: 'HEAD' });
          if (infraResponse.ok) {
            checklist.streamingInfrastructure = { status: 'success', message: 'Streaming server ready' };
          } else {
            checklist.streamingInfrastructure = { status: 'warning', message: 'Streaming server may not be ready' };
          }
        } catch (error) {
          checklist.streamingInfrastructure = { status: 'warning', message: 'Cannot verify streaming server' };
        }
        updateChecklistItem('streamingInfrastructure', checklist.streamingInfrastructure);
        
        // 6. Socket.IO Connection
        if (typeof io !== 'undefined') {
          checklist.socketConnection = { status: 'success', message: 'Real-time connection ready' };
        } else {
          checklist.socketConnection = { status: 'warning', message: 'Socket.IO not available' };
        }
        updateChecklistItem('socketConnection', checklist.socketConnection);
        
        // 7. Stream Status Initialization
        checklist.streamStatus = { status: 'success', message: `Stream status: ${classData.status}` };
        updateChecklistItem('streamStatus', checklist.streamStatus);
        
        console.log('✅ Pre-Stream Checklist completed successfully');
        return { success: true, checklist };
        
      } catch (error) {
        console.error('❌ Pre-Stream Checklist failed:', error);
        return { success: false, checklist, error: error.message };
      }
    }
    

    
    // Show pre-stream checklist for instructors
    function showPreStreamChecklist(checklist) {
      const checklistOverlay = document.createElement('div');
      checklistOverlay.className = 'welcome-modal show';
      checklistOverlay.id = 'preStreamChecklist';
      checklistOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title">🔍 Pre-Stream Checklist</h2>
          <div class="welcome-text">
            <p>Verifying all systems are ready for streaming...</p>
            <div id="checklistItems" style="margin: 20px 0; text-align: left;">
              ${Object.entries(checklist).map(([key, item]) => `
                <div class="checklist-item" id="checklist-${key}" style="
                  padding: 10px;
                  margin: 8px 0;
                  background: rgba(255, 255, 255, 0.05);
                  border-radius: 8px;
                  border-left: 4px solid #fbbf24;
                  display: flex;
                  align-items: center;
                ">
                  <div class="status-icon" style="margin-right: 10px; font-size: 1.2em;">⏳</div>
                  <div class="status-text">${item.message}</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closePreStreamChecklist()" disabled id="checklistCloseBtn">Please Wait...</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(checklistOverlay);
    }
    
    // Update individual checklist item
    function updateChecklistItem(key, item) {
      const checklistItem = document.getElementById(`checklist-${key}`);
      if (!checklistItem) return;
      
      const statusIcon = checklistItem.querySelector('.status-icon');
      const statusText = checklistItem.querySelector('.status-text');
      
      let color, icon;
      switch (item.status) {
        case 'success':
          color = '#22c55e';
          icon = '✅';
          break;
        case 'warning':
          color = '#fbbf24';
          icon = '⚠️';
          break;
        case 'failed':
          color = '#ef4444';
          icon = '❌';
          break;
        default:
          color = '#fbbf24';
          icon = '⏳';
      }
      
      checklistItem.style.borderLeftColor = color;
      statusIcon.textContent = icon;
      statusText.textContent = item.message;
      
      // Check if all items are complete
      setTimeout(() => {
        const allItems = document.querySelectorAll('.checklist-item .status-icon');
        const allComplete = Array.from(allItems).every(icon => 
          icon.textContent === '✅' || icon.textContent === '⚠️' || icon.textContent === '❌'
        );
        
        if (allComplete) {
          const closeBtn = document.getElementById('checklistCloseBtn');
          if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.textContent = 'Continue';
          }
        }
      }, 100);
    }
    
    // Close pre-stream checklist
    function closePreStreamChecklist() {
      const checklistOverlay = document.getElementById('preStreamChecklist');
      if (checklistOverlay) {
        checklistOverlay.remove();
      }
    }
    
    // Auto-assign class ID for students based on their enrollment
    async function autoAssignStudentClass() {
      const userRole = localStorage.getItem('role');
      if (userRole !== 'student') return null;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const userData = await response.json();
          if (userData.user.classId) {
            console.log('📚 Auto-assigned student to class:', userData.user.classId);
            localStorage.setItem('currentClassId', userData.user.classId);
            return userData.user.classId;
          }
        }
      } catch (error) {
        console.error('❌ Failed to auto-assign student class:', error);
      }
      
      return null;
    }
    
    function showWaitingMessage() {
      // Update the stream type indicator
      updateStreamTypeIndicator('Waiting for Stream...');
      
      // Create a waiting overlay
      const waitingOverlay = document.createElement('div');
      waitingOverlay.className = 'welcome-modal show';
      waitingOverlay.id = 'waitingOverlay';
      waitingOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ff9800;">⏳ Waiting for Stream</h2>
          <div class="welcome-text">
            <p>The instructor hasn't started streaming yet. The page will automatically update when the stream becomes available.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 152, 0, 0.1); border-radius: 10px; border-left: 4px solid #ff9800;">
              <strong>What's happening:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>✅ Connected to class successfully</li>
                <li>⏳ Waiting for instructor to start streaming</li>
                <li>🔄 Automatically checking for updates every 3 seconds</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closeWaitingMessage()">Continue Waiting</button>
            <button class="welcome-close" onclick="goToDashboard()" style="background: #6b7280;">Back to Dashboard</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(waitingOverlay);
    }
    
    function closeWaitingMessage() {
      const waitingOverlay = document.getElementById('waitingOverlay');
      if (waitingOverlay) {
        waitingOverlay.remove();
      }
    }
    
    // Update stream type indicator with class information
    function updateStreamTypeIndicator(streamType = 'Stream') {
      const className = localStorage.getItem('currentClassName');
      if (className) {
        streamTypeIndicator.textContent = `${className} - ${streamType}`;
      } else {
        streamTypeIndicator.textContent = streamType;
      }
    }
    
    // ===== NOTIFICATION SYSTEM =====
    function showNotification(message, type = 'info') {
      // Remove existing notification
      const existingNotification = document.querySelector('.stream-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Create notification element
      const notification = document.createElement('div');
      notification.className = `stream-notification ${type}`;
      notification.textContent = message;
      
      // Style the notification
      const colors = {
        info: { bg: 'rgba(59, 130, 246, 0.9)', border: '#3b82f6' },
        warning: { bg: 'rgba(245, 158, 11, 0.9)', border: '#f59e0b' },
        error: { bg: 'rgba(239, 68, 68, 0.9)', border: '#ef4444' },
        success: { bg: 'rgba(34, 197, 94, 0.9)', border: '#22c55e' }
      };
      
      const color = colors[type] || colors.info;
      
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color.bg};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        border-left: 4px solid ${color.border};
        font-size: 14px;
        font-weight: 500;
        z-index: 1000;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        animation: slideInRight 0.3s ease-out;
      `;
      
      // Add animation keyframes if not already added
      if (!document.querySelector('#notification-styles')) {
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
          @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
          @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 300);
        }
      }, 3000);
    }
    
    // Automatically fetch user's assigned class ID
    async function fetchUserAssignedClass() {
      try {
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          console.log('❌ No auth token available');
          return null;
        }
        
        console.log('📡 Fetching user\'s assigned class from server...');
        
        // First, try to get user info which should include their assigned class
        const userResponse = await fetch('/api/auth/verify', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (userResponse.ok) {
          const userData = await userResponse.json();
          console.log('👤 User data:', userData.user);
          
          // Check if user has a direct class assignment
          if (userData.user.classId) {
            console.log('✅ Found direct class assignment:', userData.user.classId);
            return userData.user.classId;
          }
        }
        
        // If no direct assignment, try to get user's enrolled classes
        const classesResponse = await fetch('/api/classes/my-classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (classesResponse.ok) {
          const userClasses = await classesResponse.json();
          console.log('📚 Found user classes:', userClasses.length);
          
          if (userClasses.length > 0) {
            // Prioritize classes with active streams, then most recent
            const sortedClasses = userClasses.sort((a, b) => {
              // Live streams first
              if (a.streamStatus === 'live' && b.streamStatus !== 'live') return -1;
              if (b.streamStatus === 'live' && a.streamStatus !== 'live') return 1;
              
              // Then by most recent update
              return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            
            const selectedClass = sortedClasses[0];
            console.log('✅ Auto-selected class:', selectedClass.name, selectedClass._id);
            
            // Store class name for display
            localStorage.setItem('currentClassName', selectedClass.name);
            
            return selectedClass._id;
          }
        }
        
        // Fallback: try to get any accessible class for this user
        console.log('⚠️ No enrolled classes found, checking accessible classes...');
        const allClassesResponse = await fetch('/api/classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (allClassesResponse.ok) {
          const allClasses = await allClassesResponse.json();
          if (allClasses.length > 0) {
            // For instructors, they might have access to classes they teach
            const userRole = localStorage.getItem('role');
            if (userRole === 'instructor' || userRole === 'admin') {
              const firstClass = allClasses[0];
              console.log('✅ Instructor/Admin assigned to first available class:', firstClass._id);
              localStorage.setItem('currentClassName', firstClass.name);
              return firstClass._id;
            }
          }
        }
        
        console.log('❌ No accessible classes found');
        return null;
        
      } catch (error) {
        console.error('❌ Error fetching user assigned class:', error);
        return null;
      }
    }
    

    
    const video = document.getElementById('video');
    const webrtcVideo = document.getElementById('webrtcVideo');
    const streamTypeIndicator = document.getElementById('streamTypeIndicator');
    // const playBtn = document.getElementById('playBtn'); // Removed
    const timeline = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    
    // WebRTC Variables
    let peerConnection = null;
    let webrtcSocket = null;
    let isWebRTCMode = false;
    let classId = null;
    
    // Stream Timer for WebRTC (since WebRTC doesn't have reliable currentTime)
    let streamTimer = null;
    let streamStartTime = null;
    let streamDuration = 3600; // Default 1 hour, can be updated from server
    let isStreamPaused = false;
    let pausedAt = 0;
    const playhead = document.getElementById('playhead');
    // const fullscreenBtn = document.getElementById('fullscreenBtn'); // Removed
    const loading = document.getElementById('loading');
    // const rateBtn = document.getElementById('rateBtn'); // Removed
    // const liveBtn = document.getElementById('liveBtn'); // Removed
    // const streamMode = document.getElementById('streamMode'); // Removed
    const fileInput = document.getElementById('fileInput');
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImg = document.getElementById('thumbnailImg');
    const thumbnailTime = document.getElementById('thumbnailTime');
    
    // Skip buttons - Commented out as buttons were removed
    // document.getElementById('rewind10').onclick = () => video.currentTime -= 10;
    // document.getElementById('rewind30').onclick = () => video.currentTime -= 30;
    // document.getElementById('forward10').onclick = () => video.currentTime += 10;
    // document.getElementById('forward30').onclick = () => video.currentTime += 30;
    
    let hlsInstance = null;
    
    // Stream Timer Utility for WebRTC
    function createStreamTimer(startTime = Date.now()) {
      return {
        startTime: startTime,
        isPaused: false,
        pauseAt: 0,
        
        get currentTime() {
          if (this.isPaused) return this.pauseAt;
          return (Date.now() - this.startTime) / 1000;
        },
        
        pause() {
          this.isPaused = true;
          this.pauseAt = (Date.now() - this.startTime) / 1000;
        },
        
        resume() {
          this.isPaused = false;
          this.startTime = Date.now() - this.pauseAt * 1000;
        },
        
        reset() {
          this.startTime = Date.now();
          this.pauseAt = 0;
          this.isPaused = false;
        },
        
        setTime(seconds) {
          if (this.isPaused) {
            this.pauseAt = seconds;
          } else {
            this.startTime = Date.now() - seconds * 1000;
          }
        }
      };
    }
    
    // Get current time for either WebRTC or regular video
    function getCurrentTime() {
      if (isWebRTCMode && streamTimer) {
        return streamTimer.currentTime;
      }
      return video.currentTime || 0;
    }
    
    // Get duration for either WebRTC or regular video
    function getDuration() {
      if (isWebRTCMode) {
        return streamDuration;
      }
      return video.duration || 0;
    }
    
    // Set current time for either WebRTC or regular video
    function setCurrentTime(time) {
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, we can't actually seek, but we can adjust our timer
        // This is mainly for UI purposes
        streamTimer.setTime(time);
      } else {
        video.currentTime = time;
      }
    }

    // Thumbnail generation functionality
    let thumbnailCache = [];
    let webrtcThumbnailCache = [];
    
    function generateThumbnails() {
      const offscreen = document.createElement('canvas');
      offscreen.width = 120;
      offscreen.height = 70;
      const offCtx = offscreen.getContext('2d');

      let current = 0;
      const end = Math.floor(video.duration);

      function snapNext() {
        if (current > end) return;

        video.currentTime = current;
        video.addEventListener('seeked', function capture() {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
          const img = new Image();
          img.src = offscreen.toDataURL();
          thumbnailCache.push({ time: current, img });

          current++;
          video.removeEventListener('seeked', capture);
          setTimeout(snapNext, 200); // short delay ensures rendering stability
        }, { once: true });
      }

      snapNext();
    }
    
    // Function to get thumbnail for a specific time - Updated for both modes
    function getThumbnailForTime(time, cache = null) {
      const targetCache = cache || (isWebRTCMode ? webrtcThumbnailCache : thumbnailCache);
      
      if (targetCache.length === 0) return null;
      
      // Find the closest thumbnail
      let closest = targetCache[0];
      let minDiff = Math.abs(closest.time - time);
      
      for (let i = 1; i < targetCache.length; i++) {
        const diff = Math.abs(targetCache[i].time - time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = targetCache[i];
        }
      }
      
      return closest;
    }
    
    // Function to load WebRTC thumbnails from server
    async function loadWebRTCThumbnails() {
      if (!classId) return;
      
      try {
        console.log('📸 Loading WebRTC thumbnails...');
        webrtcThumbnailCache = [];
        
        // Generate thumbnails for every second up to stream duration
        for (let i = 0; i <= streamDuration; i++) {
          webrtcThumbnailCache.push({
            time: i,
            url: `/api/thumbnails/${classId}/${i}.jpg`, // Adjust URL based on your backend
            img: null // Will be loaded on demand
          });
        }
        
        console.log(`📸 Generated ${webrtcThumbnailCache.length} WebRTC thumbnail placeholders`);
      } catch (error) {
        console.error('❌ Error loading WebRTC thumbnails:', error);
      }
    }
    
    // WebRTC Functions
    function initializeWebRTCSocket() {
      if (webrtcSocket) return;
      
      // Reuse the main socket instead of creating a new connection
      webrtcSocket = socket;
      
      if (!webrtcSocket) {
        console.error('❌ Main socket not available for WebRTC');
        return;
      }
      
      console.log('🔌 WebRTC using main socket connection');
      
      webrtcSocket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Instructor started WebRTC stream:', data.mediaType);
        console.log('🔄 Current WebRTC video element:', webrtcVideo);
        console.log('🔄 Current peer connection:', peerConnection);
        
        // Set stream duration if provided
        if (data.duration) {
          streamDuration = data.duration;
        }
        
        switchToWebRTCMode();
        updateStreamTypeIndicator(`Live ${data.mediaType}`);
        
        // Load WebRTC thumbnails
        loadWebRTCThumbnails();
        
        // Show loading while waiting for WebRTC connection
        loading.style.display = 'block';
        loading.textContent = 'Connecting to live stream...';
      });
      
      webrtcSocket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Instructor stopped WebRTC stream');
        switchToFileMode();
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      });
      
      webrtcSocket.on('webrtc-offer', async (data) => {
        console.log('📡 Received WebRTC offer from instructor');
        await handleWebRTCOffer(data.offer);
      });
      
      webrtcSocket.on('webrtc-ice-candidate', async (data) => {
        console.log('🧊 Received ICE candidate from instructor');
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    async function handleWebRTCOffer(offer) {
      try {
        console.log('🔗 Creating WebRTC peer connection...');
        
        peerConnection = new RTCPeerConnection({
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        });
        
        // Handle incoming stream
        peerConnection.ontrack = (event) => {
          console.log('📺 Received WebRTC stream:', event.streams[0]);
          console.log('📺 Stream tracks:', event.streams[0].getTracks());
          
          webrtcVideo.srcObject = event.streams[0];
          
          // Ensure we're in WebRTC mode
          switchToWebRTCMode();
          
          // Try to play the video
          webrtcVideo.play().then(() => {
            console.log('✅ WebRTC video playing');
            loading.style.display = 'none';
          }).catch(error => {
            console.error('❌ WebRTC video play failed:', error);
            // Try to play with user interaction
            webrtcVideo.muted = true;
            webrtcVideo.play().then(() => {
              console.log('✅ WebRTC video playing (muted)');
              loading.style.display = 'none';
            }).catch(e => {
              console.error('❌ WebRTC video play failed even muted:', e);
            });
          });
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            webrtcSocket.emit('webrtc-ice-candidate', {
              to: 'instructor',
              candidate: event.candidate
            });
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          console.log('🔗 WebRTC connection state:', state);
          
          if (state === 'connected') {
            console.log('✅ WebRTC connection established');
          } else if (state === 'disconnected' || state === 'failed') {
            console.log('❌ WebRTC connection lost');
            switchToFileMode();
          }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer back to instructor
        webrtcSocket.emit('webrtc-answer', {
          to: 'instructor',
          answer: answer
        });
        
        console.log('📤 Sent WebRTC answer to instructor');
      } catch (error) {
        console.error('❌ Error handling WebRTC offer:', error);
        switchToFileMode();
      }
    }
    
    function switchToWebRTCMode() {
      console.log('🔄 Switching to WebRTC mode');
      isWebRTCMode = true;
      
      // Initialize stream timer
      if (!streamTimer) {
        streamTimer = createStreamTimer();
        console.log('⏱️ Stream timer initialized');
      }
      
      // Hide regular video and show WebRTC video
      video.style.display = 'none';
      webrtcVideo.style.display = 'block';
      
      // Configure WebRTC video element
      webrtcVideo.autoplay = true;
      webrtcVideo.playsInline = true;
      webrtcVideo.controls = false; // Remove controls for custom timeline
      
      // Show timeline for WebRTC mode
      document.getElementById('timeline').style.display = 'block';
      
      updateStreamTypeIndicator('Live WebRTC Stream');
      
      // Show WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'block';
      }
      
      // Start updating WebRTC timeline
      startWebRTCTimelineUpdates();
      
      // Initialize timeline for WebRTC
      initializeWebRTCTimeline();
      
      console.log('✅ Switched to WebRTC mode - video element visible:', webrtcVideo.style.display);
    }
    
    function switchToFileMode() {
      console.log('🔄 Switching to file mode');
      isWebRTCMode = false;
      
      // Stop stream timer
      if (streamTimer) {
        streamTimer = null;
      }
      
      webrtcVideo.style.display = 'none';
      video.style.display = 'block';
      
      // Show file-based controls
      document.getElementById('timeline').style.display = 'block';
      
      updateStreamTypeIndicator('File Stream');
      
      // Hide WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'none';
      }
      
      // Stop WebRTC timeline updates
      stopWebRTCTimelineUpdates();
      
      if (webrtcVideo.srcObject) {
        webrtcVideo.srcObject = null;
      }
    }
    
    // WebRTC Timeline Update Functions
    let webrtcTimelineInterval = null;
    let timelineScrollOffset = 0;
    let isTimelineDragging = false;
    let currentZoomLevel = 1;
    
    // Time formatting function
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Generate time hash ticks
    function generateTimeHashes(duration, zoomLevel = 1) {
      const timeHashes = document.getElementById('time-hashes');
      if (!timeHashes) return;
      
      // Determine tick interval based on zoom level and duration
      let tickInterval = 10; // Default 10 seconds
      if (duration > 3600) tickInterval = 60; // 1 minute for long streams
      else if (duration > 1800) tickInterval = 30; // 30 seconds for medium streams
      else if (zoomLevel > 2) tickInterval = 5; // 5 seconds when zoomed in
      
      const containerWidth = duration * zoomLevel * 2; // Adjust multiplier as needed
      const tickSpacing = (tickInterval / duration) * containerWidth;
      
      let ticksHTML = '';
      for (let time = 0; time <= duration; time += tickInterval) {
        const leftPosition = (time / duration) * containerWidth;
        ticksHTML += `
          <div class="time-tick" style="left: ${leftPosition}px;">
            <div class="time-tick-line"></div>
            <div class="time-tick-label">${formatTime(time)}</div>
          </div>
        `;
      }
      
      timeHashes.innerHTML = ticksHTML;
      console.log(`📏 Generated time hashes: ${Math.ceil(duration / tickInterval)} ticks`);
    }
    
    // Timeline zoom functionality
    function zoomTimeline(factor) {
      currentZoomLevel = Math.max(0.5, Math.min(5, currentZoomLevel * factor));
      
      // Regenerate time hashes with new zoom level
      generateTimeHashes(streamDuration, currentZoomLevel);
      
      // Update timeline container width
      const timelineContainer = document.getElementById('timelineContainer');
      if (timelineContainer) {
        const newWidth = streamDuration * currentZoomLevel * 2;
        timelineContainer.style.minWidth = `${newWidth}px`;
      }
      
      console.log(`🔍 Timeline zoom level: ${currentZoomLevel.toFixed(1)}x`);
    }
    
    function startWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
      }
      
      webrtcTimelineInterval = setInterval(() => {
        if (streamTimer && !isTimelineDragging) {
          updateTimelineScrollForWebRTC();
          updateTimeDisplayForWebRTC();
          updateJumpToLiveIndicatorForWebRTC();
        }
      }, 100); // Update every 100ms for smooth timeline
    }
    
    function stopWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
        webrtcTimelineInterval = null;
      }
    }
    
    function updateTimelineScrollForWebRTC() {
      const currentTime = streamTimer.currentTime;
      const duration = streamDuration;
      const timeline = document.getElementById('timeline');
      const timelineTrack = document.getElementById('timeline-track');
      const timeHashes = document.getElementById('time-hashes');
      
      if (!timeline || !timelineTrack || !timeHashes || duration <= 0) return;
      
      // Calculate scroll position to keep current time centered
      const timelineWidth = timeline.offsetWidth;
      const trackWidth = timelineTrack.offsetWidth || (duration * currentZoomLevel * 2);
      const timeProgress = currentTime / duration;
      
      // Calculate the scroll offset to center the current time
      const centerOffset = timelineWidth / 2;
      const targetScrollPosition = (timeProgress * trackWidth) - centerOffset;
      
      // Clamp scroll position to valid range
      const maxScroll = Math.max(0, trackWidth - timelineWidth);
      const clampedScroll = Math.max(0, Math.min(maxScroll, targetScrollPosition));
      
      // Apply smooth transform to both timeline track and time hashes
      const transformValue = `translateX(-${clampedScroll}px)`;
      timelineTrack.style.transform = transformValue;
      timeHashes.style.transform = transformValue;
      
      timelineScrollOffset = clampedScroll;
    }
    
    function updateTimeDisplayForWebRTC() {
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl && streamTimer) {
        currentTimeEl.textContent = formatTime(streamTimer.currentTime);
        totalTimeEl.textContent = formatTime(streamDuration);
      }
    }
    
    function updateJumpToLiveIndicatorForWebRTC() {
      const indicator = document.getElementById('jumpToLiveIndicator');
      
      if (!indicator || !streamTimer) return;
      
      // For WebRTC, we're always "live" unless we've manually adjusted the timer
      // Show indicator if user has scrolled back in time
      const currentTime = streamTimer.currentTime;
      const liveTime = (Date.now() - streamTimer.startTime) / 1000;
      const isAtLive = Math.abs(liveTime - currentTime) < 3;
      
      indicator.style.display = isAtLive ? 'none' : 'block';
    }
    
    function initializeWebRTCTimeline() {
      console.log('🎬 Initializing WebRTC timeline');
      
      // Clear existing timeline content
      const timelineContainer = document.getElementById('timelineContainer');
      if (timelineContainer) {
        timelineContainer.innerHTML = '';
      }
      
      // Generate time hash ticks
      generateTimeHashes(streamDuration, currentZoomLevel);
      
      // Generate timeline frames for WebRTC
      generateWebRTCTimelineFrames();
    }
    
    function generateWebRTCTimelineFrames() {
      const container = timeline.querySelector('.timeline-container');
      if (!container) return;
      
      const frameWidth = 120; // Width of each thumbnail frame
      const totalFrames = Math.ceil(streamDuration);
      const totalWidth = totalFrames * frameWidth;
      
      container.style.minWidth = `${totalWidth}px`;
      
      // Generate frames
      for (let i = 0; i < totalFrames; i++) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = `${frameWidth}px`;
        
        // Create placeholder thumbnail with proper SVG
        const img = document.createElement('div');
        img.className = 'thumbnail-placeholder';
        img.style.cssText = `
          width: 100%;
          height: calc(100% - 20px);
          background: #333;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 4px 4px 0 0;
          color: #fff;
          font-size: 12px;
          font-weight: 600;
        `;
        img.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24"></path>
          </svg>
        `;
        
        // Create time tick
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = formatTime(i);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek (for WebRTC this is just UI feedback)
        frame.addEventListener('click', () => {
          if (streamTimer) {
            streamTimer.setTime(i);
            console.log(`🎯 WebRTC timeline clicked: ${formatTime(i)}`);
          }
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        container.appendChild(frame);
      }
      
      console.log(`🎬 Generated ${totalFrames} WebRTC timeline frames`);
    }

    // Fetch class information from the backend
    async function fetchClassInfo() {
      try {
        // Get classId from URL parameters or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
        
        // If no class ID, automatically fetch user's assigned class
        if (!classId) {
          console.log('🔍 No class ID provided, fetching user\'s assigned class...');
          classId = await fetchUserAssignedClass();
          
          if (!classId) {
            console.error('❌ No class ID available');
            showErrorMessage('No Class Assignment Found', 'You are not currently enrolled in any classes. Please contact your instructor or check your enrollment status.');
            return;
          }
          
          // Store the fetched class ID for future use
          localStorage.setItem('currentClassId', classId);
          console.log('✅ Auto-assigned to class:', classId);
          
          // Update stream type indicator with class info
          updateStreamTypeIndicator();
        }
        
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('❌ Authentication failed');
            showErrorMessage('Authentication Required', 'You need to log in to access this stream. Please log in and try again.');
            return;
          } else if (response.status === 403) {
            console.error('❌ Access denied');
            showErrorMessage('Access Denied', 'You do not have permission to access this class stream. Please contact your instructor.');
            return;
          } else if (response.status === 404) {
            console.error('❌ Class not found');
            showErrorMessage('Class Not Found', 'The requested class could not be found. Please check the class ID and try again.');
            return;
          }
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('📊 Stream status data:', data);
        
        const streamStatus = data.status;
        const currentSource = data.currentSource;

        console.log('📡 Status:', streamStatus);
        console.log('📹 Source:', currentSource);

        // Check if stream is active
        if (streamStatus !== 'live') {
          console.log('⏸️ Stream is not live, waiting for instructor...');
          loading.style.display = 'block';
          
          // Show waiting message after 10 seconds
          setTimeout(() => {
            if (loading.style.display === 'block') {
              showWaitingMessage();
            }
          }, 10000);
          
          // Retry after 3 seconds
          setTimeout(() => fetchClassInfo(), 3000);
          return;
        }

        // Handle different stream sources
        if (currentSource === 'upload' && data.session && data.session.uploadFilename) {
          // For uploaded videos, use direct video URL
          const videoUrl = `/api/stream/video/${data.session.uploadFilename}`;
          console.log('📹 Loading uploaded video:', videoUrl);
          console.log('📁 Upload filename:', data.session.uploadFilename);
          
          // Use direct video playback for uploaded files
          video.src = videoUrl;
          video.load();
          
          video.addEventListener('loadstart', () => console.log('🔄 Video load started'));
          video.addEventListener('loadeddata', () => console.log('✅ Video data loaded'));
          video.addEventListener('canplay', () => console.log('▶️ Video can play'));
          video.addEventListener('error', (e) => console.error('❌ Video error:', e));
          
          video.play().catch(e => console.log('🔇 Video autoplay prevented:', e));
          
        } else {
          // For live streams, use HLS
          const streamUrl = `http://127.0.0.1:8888/live/${streamKey}/index.m3u8`;
          console.log('Loading HLS stream:', streamUrl);
          
          // Initialize HLS.js
          if (Hls.isSupported()) {
            hlsInstance = new Hls({
              enableWorker: true,
              lowLatencyMode: true,
              backBufferLength: 90
            });
            hlsInstance.loadSource(streamUrl);
            hlsInstance.attachMedia(video);
            hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
              video.play();
            });
          
          // Generate thumbnails when video metadata is loaded
          video.addEventListener('loadedmetadata', function() {
            generateThumbnails();
          }, { once: true });

            hlsInstance.on(Hls.Events.ERROR, function(event, data) {
              console.error('HLS error:', data);
              if (data.fatal) {
                setTimeout(() => fetchClassInfo(), 5000); // Retry after 5 seconds
              }
            });
          } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = streamUrl;
            video.addEventListener('loadedmetadata', function() {
              video.play();
              generateThumbnails();
            });
          } else {
            console.error('HLS is not supported in this browser');
          }
        }
        
        video.addEventListener('canplay', function() {
          loading.style.display = 'none';
        });
        
        video.addEventListener('waiting', function() {
          loading.style.display = 'block';
        });
        
        video.addEventListener('playing', function() {
          loading.style.display = 'none';
        });
        
        // Initialize WebRTC socket for live streaming (after main socket is ready)
        if (socket && socket.connected) {
          initializeWebRTCSocket();
        } else {
          // Wait for main socket to connect first
          setTimeout(() => {
            initializeWebRTCSocket();
          }, 1000);
        }
        
        // Note: Main socket connection is handled by initializeSocket() function
        
      } catch (error) {
        console.error('Error fetching class information:', error);
        // Retry after 5 seconds
        setTimeout(() => fetchClassInfo(), 5000);
      }
    }
    
    // Debug information on page load
    console.log('🚀 SMX Stream page loaded');
    console.log('🔍 Checking for class ID and authentication...');
    
    const urlParams = new URLSearchParams(window.location.search);
    const urlClassId = urlParams.get('classId');
    const storedClassId = localStorage.getItem('currentClassId');
    const authToken = localStorage.getItem('token');
    
    console.log('📋 URL Class ID:', urlClassId);
    console.log('💾 Stored Class ID:', storedClassId);
    console.log('🔐 Auth Token:', authToken ? 'Present' : 'Missing');
    
    if (!urlClassId && !storedClassId) {
      console.log('🔍 No class ID found - will automatically fetch user\'s assigned class');
    }
    
    if (!authToken) {
      console.warn('⚠️ No authentication token found - this will likely cause issues');
    }
    
    // Call the function to fetch class info and load the stream
    fetchClassInfo();
    
    // Play/pause toggle - Commented out as button was removed
    // playBtn.addEventListener('click', function() {
    //   if (video.paused) {
    //     video.play();
    //   } else {
    //     video.pause();
    //   }
    //   updatePlayButton();
    // });
    
    // function updatePlayButton() {
    //   playBtn.textContent = video.paused ? 'Play' : 'Pause';
    // }
    // Timeline click functionality for WebRTC with time hashes
    timeline.addEventListener('click', function(e) {
      if (!streamTimer) return;
      
      const rect = timeline.getBoundingClientRect();
      const timelineTrack = document.getElementById('timeline-track');
      
      if (!timelineTrack) return;
      
      // Calculate the actual time position considering the scroll offset
      const clickX = e.clientX - rect.left;
      const timelineWidth = rect.width;
      const trackWidth = timelineTrack.offsetWidth || (streamDuration * currentZoomLevel * 2);
      
      // Account for the current scroll position
      const scrolledClickX = clickX + timelineScrollOffset;
      const timeProgress = scrolledClickX / trackWidth;
      const newTime = Math.max(0, Math.min(streamDuration, timeProgress * streamDuration));
      
      // Pause auto-scrolling temporarily
      isTimelineDragging = true;
      
      // Set the new time
      streamTimer.setTime(newTime);
      
      // Resume auto-scrolling after a short delay
      setTimeout(() => {
        isTimelineDragging = false;
      }, 1000);
      
      console.log(`🎯 WebRTC timeline clicked: seeking to ${formatTime(newTime)}`);
    });
    
    
    // Timeline hover for thumbnail preview - WebRTC only with time hashes
    timeline.addEventListener('mousemove', function(e) {
      const duration = getDuration();
      const timelineTrack = document.getElementById('timeline-track');
      
      if (!duration || !timelineTrack || webrtcThumbnailCache.length === 0) return;
      
      const rect = timeline.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const trackWidth = timelineTrack.offsetWidth || (streamDuration * currentZoomLevel * 2);
      
      // Account for the current scroll position
      const scrolledClickX = clickX + timelineScrollOffset;
      const timeProgress = scrolledClickX / trackWidth;
      const hoverTime = Math.max(0, Math.min(duration, timeProgress * duration));
      
      const thumbnail = getThumbnailForTime(hoverTime);
      if (thumbnail && thumbnailImg && thumbnailTime && thumbnailPreview) {
        thumbnailImg.src = thumbnail.img ? thumbnail.img.src : thumbnail.url;
        thumbnailTime.textContent = formatTime(hoverTime);
        
        // Position the preview
        thumbnailPreview.style.left = clickX + 'px';
        thumbnailPreview.style.display = 'block';
      }
    });
    
    timeline.addEventListener('mouseleave', function() {
      if (thumbnailPreview) {
        thumbnailPreview.style.display = 'none';
      }
    });
    
    // Timeline zoom with mouse wheel
    timeline.addEventListener('wheel', function(e) {
      e.preventDefault();
      
      const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
      zoomTimeline(zoomFactor);
    });
    
    // Helper function to format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Fullscreen
    fullscreenBtn.addEventListener('click', function() {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.msRequestFullscreen) {
        video.msRequestFullscreen();
      }
    });
    
    // ⏩ Playback rate toggle - Commented out as button was removed
    // rateBtn.addEventListener('click', function() {
    //   video.playbackRate = video.playbackRate === 1 ? 2 : video.playbackRate === 2 ? 0.5 : 1;
    //   rateBtn.textContent = video.playbackRate + 'x';
    // });
    
    // 🔄 LIVE button - Commented out as button was removed
    // liveBtn.addEventListener('click', function() {
    //   if (video.duration) {
    //     video.currentTime = video.duration - 0.05;
    //   }
    // });
    
    // Update live status - Commented out as button was removed
    // setInterval(() => {
    //   if (video.duration) {
    //     const live = Math.abs(video.duration - video.currentTime) < 2;
    //     liveBtn.style.display = live ? 'none' : 'inline-block';
    //   }
    // }, 500);
    
    // 📦 Stream mode selector - Commented out as selector was removed
    // streamMode.addEventListener('change', function() {
    //   if (streamMode.value === 'local') {
    //     fileInput.click();
    //   } else {
    //     fetchClassInfo();
    //   }
    // });
    
    fileInput.addEventListener('change', function() {
      const file = fileInput.files[0];
      if (file) {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        const url = URL.createObjectURL(file);
        video.src = url;
        loading.style.display = 'block';
        
        // Generate thumbnails for local file
        video.addEventListener('loadedmetadata', function() {
          generateThumbnails();
        }, { once: true });
      }
    });
    
    // ⌨️ Keyboard shortcuts
    window.addEventListener('keydown', function(e) {
      if (e.key === 'k' || e.key === ' ') {
        e.preventDefault();
        // playBtn.click(); // Commented out as button was removed
        // Toggle play/pause directly
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
      else if (e.key === 'j') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'l') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'L') { // Capital L to jump to live
        e.preventDefault();
        jumpToLive();
      }
      else if (e.key === '=' || e.key === '+') { // Zoom in timeline
        e.preventDefault();
        if (window.enhancedTimeline) {
          visibleDuration = Math.max(5, visibleDuration * 0.8);
          zoomLevel = 30 / visibleDuration;
          window.enhancedTimeline.render();
        }
      }
      else if (e.key === '-') { // Zoom out timeline
        e.preventDefault();
        if (window.enhancedTimeline && window.enhancedTimeline.video) {
          visibleDuration = Math.min(window.enhancedTimeline.video.duration || 300, visibleDuration * 1.2);
          zoomLevel = 30 / visibleDuration;
          window.enhancedTimeline.render();
        }
      }
      else if (e.key === '0') { // Reset timeline zoom
        e.preventDefault();
        resetTimelineZoom();
      }
      else if (e.key === 'f') {
        // fullscreenBtn.click(); // Commented out as button was removed
        // Request fullscreen directly
        if (video.requestFullscreen) {
          video.requestFullscreen();
        } else if (video.webkitRequestFullscreen) {
          video.webkitRequestFullscreen();
        } else if (video.msRequestFullscreen) {
          video.msRequestFullscreen();
        }
      }
      else if (e.key === 'm') {
        webrtcVideo.muted = !webrtcVideo.muted;
      }
      else if (e.key === 'ArrowLeft') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 5);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'ArrowRight') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 5);
          streamTimer.setTime(newTime);
        }
      }
    });
    
    // Enhanced video event listeners
    video.addEventListener('playing', function() {
      loading.style.display = 'none';
      // playBtn.textContent = 'Pause'; // Commented out as button was removed
    });
    
    video.addEventListener('pause', function() {
      // playBtn.textContent = 'Play'; // Commented out as button was removed
    });

    // Advanced Video Timeline Component
    class VideoTimeline {
      constructor(videoId, timelineId) {
        console.log('VideoTimeline constructor called with:', videoId, timelineId);
        this.video = document.getElementById(videoId);
        this.timeline = document.getElementById(timelineId);
        this.scrubber = document.getElementById('scrubber');
        console.log('Elements found:', {
          video: this.video,
          timeline: this.timeline,
          scrubber: this.scrubber
        });
        this.thumbnails = [];
        this.zoomLevel = 1;
        this.visibleDuration = 60; // seconds visible at zoom level 1
        this.thumbnailInterval = 2; // seconds between thumbnails
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartTime = 0;
        
        this.init();
      }

      init() {
        console.log('VideoTimeline init called');
        if (!this.video || !this.timeline) {
          console.log('Missing video or timeline element');
          return;
        }
        
        // Create basic timeline structure immediately
        this.createBasicTimeline();
        
        // Wait for video metadata to load
        this.video.addEventListener('loadedmetadata', () => {
          console.log('Video metadata loaded, generating thumbnails');
          this.generateThumbnails();
          this.setupEventListeners();
        });

        // If metadata is already loaded
        if (this.video.readyState >= 1) {
          console.log('Video metadata already loaded');
          this.generateThumbnails();
          this.setupEventListeners();
        }
      }

      createBasicTimeline() {
        console.log('Creating basic timeline structure');
        // Create a basic timeline with time markers even without video duration
        const container = document.createElement('div');
        container.className = 'timeline-container';
        container.id = 'timeline-container';
        this.timeline.appendChild(container);
        
        // Add some basic time markers (0, 30s, 1min, etc.)
        for (let time = 0; time <= 300; time += 30) { // 5 minutes worth
          const frame = this.createTimeMarker(time);
          container.appendChild(frame);
        }
      }

      createTimeMarker(time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = '80px';
        frame.style.minWidth = '80px';
        
        // Create a simple placeholder
        const placeholder = document.createElement('div');
        placeholder.style.width = '100%';
        placeholder.style.height = 'calc(100% - 20px)';
        placeholder.style.background = 'linear-gradient(135deg, #1e293b, #0f172a)';
        placeholder.style.borderRadius = '4px 4px 0 0';
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
        placeholder.style.color = '#70b8ff';
        placeholder.style.fontSize = '10px';
        placeholder.textContent = this.formatTime(time);
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(placeholder);
        frame.appendChild(tick);
        
        return frame;
      }

      async generateThumbnails() {
        console.log('generateThumbnails called');
        const duration = this.video.duration;
        console.log('Video duration:', duration);
        if (!duration) {
          console.log('No duration available, skipping thumbnail generation');
          return;
        }

        // Clear existing container and create new one for thumbnails
        const existingContainer = this.timeline.querySelector('.timeline-container');
        if (existingContainer) {
          existingContainer.remove();
        }
        
        const container = document.createElement('div');
        container.className = 'timeline-container';
        this.timeline.appendChild(container);
        console.log('Timeline container created and added');

        // Generate thumbnails every 2 seconds
        for (let time = 0; time < duration; time += this.thumbnailInterval) {
          console.log('Generating thumbnail for time:', time);
          const thumbnail = await this.captureThumbnail(time);
          const frame = this.createThumbnailFrame(thumbnail, time);
          container.appendChild(frame);
          this.thumbnails.push({ element: frame, time: time });
        }

        console.log('Generated', this.thumbnails.length, 'thumbnails');
        this.updateTimelineWidth();
      }

      async captureThumbnail(time) {
        return new Promise((resolve) => {
          // For now, create a placeholder thumbnail
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 160;
          canvas.height = 90;
          
          // Create a simple gradient placeholder
          const gradient = ctx.createLinearGradient(0, 0, 160, 90);
          gradient.addColorStop(0, '#1e293b');
          gradient.addColorStop(1, '#0f172a');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 160, 90);
          
          // Add time text
          ctx.fillStyle = '#70b8ff';
          ctx.font = '12px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(this.formatTime(time), 80, 50);
          
          resolve(canvas.toDataURL());
        });
      }

      createThumbnailFrame(thumbnailSrc, time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        
        const img = document.createElement('img');
        img.src = thumbnailSrc;
        img.alt = `Frame at ${this.formatTime(time)}`;
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek
        frame.addEventListener('click', () => {
          this.video.currentTime = time;
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        return frame;
      }

      setupEventListeners() {
        // Update scrubber position on time update (only when not dragging)
        this.video.addEventListener('timeupdate', () => {
          if (!this.isDragging) {
            this.updateScrubberPosition();
          }
        });

        // Zoom with mouse wheel
        this.timeline.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
          this.zoomLevel *= zoomFactor;
          this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
          this.updateTimelineWidth();
        });

        // Scrubber drag functionality
        this.setupScrubberDrag();

        // Click on timeline to seek
        this.timeline.addEventListener('click', (e) => {
          if (e.target === this.timeline || e.target.classList.contains('timeline-container')) {
            this.seekToPosition(e);
          }
        });
      }

      setupScrubberDrag() {
        // Mouse events
        this.scrubber.addEventListener('mousedown', (e) => {
          this.startDrag(e);
        });

        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            this.handleDrag(e);
          }
        });

        document.addEventListener('mouseup', () => {
          this.endDrag();
        });

        // Touch events for mobile
        this.scrubber.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.startDrag(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
          if (this.isDragging) {
            e.preventDefault();
            this.handleDrag(e.touches[0]);
          }
        });

        document.addEventListener('touchend', () => {
          this.endDrag();
        });
      }

      startDrag(event) {
        this.isDragging = true;
        this.dragStartX = event.clientX;
        this.dragStartTime = this.video.currentTime;
        this.scrubber.classList.add('dragging');
        
        // Pause video during drag for smoother scrubbing
        this.wasPlaying = !this.video.paused;
        this.video.pause();
      }

      handleDrag(event) {
        if (!this.isDragging) return;

        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        // Calculate new time based on position
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        // Update video time and scrubber position
        this.video.currentTime = newTime;
        this.updateScrubberPosition();
        
        // Show time tooltip during drag
        this.showTimeTooltip(event.clientX, newTime);
      }

      endDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.scrubber.classList.remove('dragging');
        this.hideTimeTooltip();
        
        // Resume playback if it was playing before drag
        if (this.wasPlaying) {
          this.video.play();
        }
      }

      seekToPosition(event) {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        this.video.currentTime = newTime;
      }

      showTimeTooltip(x, time) {
        let tooltip = document.getElementById('scrubber-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.id = 'scrubber-tooltip';
          tooltip.style.cssText = `
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
          `;
          document.body.appendChild(tooltip);
        }
        
        tooltip.textContent = this.formatTime(time);
        tooltip.style.left = `${x - 25}px`;
        tooltip.style.top = `${this.timeline.getBoundingClientRect().top - 30}px`;
        tooltip.style.display = 'block';
      }

      hideTimeTooltip() {
        const tooltip = document.getElementById('scrubber-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
      }

      updateScrubberPosition() {
        if (!this.video.duration) return;
        
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const progress = this.video.currentTime / this.video.duration;
        const timelineWidth = container.offsetWidth;
        const scrubberPosition = progress * timelineWidth;
        
        this.scrubber.style.left = `${scrubberPosition}px`;
        
        // Auto-scroll to keep scrubber visible (only when not dragging)
        if (!this.isDragging) {
          const timelineScrollLeft = this.timeline.scrollLeft;
          const timelineVisibleWidth = this.timeline.offsetWidth;
          
          if (scrubberPosition < timelineScrollLeft || scrubberPosition > timelineScrollLeft + timelineVisibleWidth) {
            this.timeline.scrollLeft = scrubberPosition - timelineVisibleWidth / 2;
          }
        }
      }

      updateTimelineWidth() {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const frameWidth = 160 * this.zoomLevel;
        const totalFrames = this.thumbnails.length;
        const totalWidth = totalFrames * frameWidth;
        
        container.style.minWidth = `${totalWidth}px`;
        
        // Update frame widths
        this.thumbnails.forEach(({ element }) => {
          element.style.width = `${frameWidth}px`;
        });
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      zoom(factor) {
        this.zoomLevel *= factor;
        this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        this.updateTimelineWidth();
      }
    }

    // Global variables for new functionality
    let zoomEnabled = false;
    let isDraggingScrubber = false;
    let scrubberCentered = true;

    // Global functions for video controls
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, toggle the stream timer
        if (streamTimer.isPaused) {
          streamTimer.resume();
          playPauseBtn.textContent = '⏸';
          console.log('▶️ WebRTC stream timer resumed');
        } else {
          streamTimer.pause();
          playPauseBtn.textContent = '▶';
          console.log('⏸️ WebRTC stream timer paused');
        }
      } else {
        // For regular video
        const video = document.getElementById('video');
        if (video.paused) {
          video.play();
          playPauseBtn.textContent = '⏸';
        } else {
          video.pause();
          playPauseBtn.textContent = '▶';
        }
      }
    }

    function rewindVideo() {
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, adjust the timer (UI feedback only)
        const newTime = Math.max(0, streamTimer.currentTime - 10);
        streamTimer.setTime(newTime);
        scrubberCentered = false; // Allow free movement after user interaction
        console.log(`⏪ WebRTC rewind to ${formatTime(newTime)}`);
      } else {
        // For regular video
        const video = document.getElementById('video');
        video.currentTime = Math.max(0, video.currentTime - 10);
      }
    }

    function forwardVideo() {
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, adjust the timer (UI feedback only)
        const newTime = Math.min(streamDuration, streamTimer.currentTime + 10);
        streamTimer.setTime(newTime);
        scrubberCentered = false; // Allow free movement after user interaction
        console.log(`⏩ WebRTC forward to ${formatTime(newTime)}`);
      } else {
        // For regular video
        const video = document.getElementById('video');
        video.currentTime = Math.min(video.duration || 0, video.currentTime + 10);
      }
    }



    function zoomTimeline(factor) {
      if (window.videoTimeline) {
        window.videoTimeline.zoom(factor);
      }
    }

    // Update time display
    function updateTimeDisplay() {
      const video = document.getElementById('video');
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl) {
        currentTimeEl.textContent = formatTime(video.currentTime);
        totalTimeEl.textContent = formatTime(video.duration || 0);
      }
    }

    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Initialize advanced timeline
    setTimeout(() => {
      console.log('Initializing VideoTimeline...');
      window.videoTimeline = new VideoTimeline('video', 'timeline');
      console.log('VideoTimeline initialized:', window.videoTimeline);
      
      // Set up video event listeners for time display
      const video = document.getElementById('video');
      if (video) {
        video.addEventListener('timeupdate', () => {
          updateTimeDisplay();
          updateTimelineViewport();
        });
        video.addEventListener('loadedmetadata', () => {
          updateTimeDisplay();
          if (window.enhancedTimeline) {
            // Reset timeline when new video loads
            resetTimelineZoom();
            window.enhancedTimeline.render();
          }
        });
        video.addEventListener('play', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>⏸</span>';
        });
        video.addEventListener('pause', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>▶</span>';
        });
      }
    }, 1000);

    const videoElement = document.getElementById('video');
    const currentTimeDisplay = document.getElementById('currentTime');
    const totalTimeDisplay = document.getElementById('totalTime');

    // Play/Pause functionality for WebRTC
    function togglePlayPause() {
      const playPauseBtn = document.querySelector('.play-pause-btn');
      
      if (streamTimer) {
        // For WebRTC, we can't actually pause the stream, but we can pause our timer
        if (!streamTimer.isPaused) {
          streamTimer.pause();
          playPauseBtn.innerHTML = Icons.play;
          console.log('⏸️ WebRTC stream timer paused');
        } else {
          streamTimer.resume();
          playPauseBtn.innerHTML = Icons.pause;
          console.log('▶️ WebRTC stream timer resumed');
        }
      }
    }

    // WebRTC stream uses its own timer-based time display updates
    // Time display is handled by updateTimeDisplayForWebRTC() function

    // Rewind functionality
    function rewindVideo() {
      videoElement.currentTime -= 10;
    }

    // Fast forward functionality
    function forwardVideo() {
      videoElement.currentTime += 10;
    }


  </script>
</body>
</html>