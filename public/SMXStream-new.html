<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Stream Viewer - SMXKITS</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
  
  <!-- HLS.js for video streaming -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  
  <!-- Socket.IO for real-time communication -->
  <script src="/socket.io/socket.io.js"></script>
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      --secondary-gradient: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
      --accent-gradient: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
      --dark-gradient: linear-gradient(135deg, #0a0a0a 0%, #1a202c 100%);
      --card-gradient: linear-gradient(145deg, #2d3748 0%, #1a202c 100%);
      --steel-gradient: linear-gradient(135deg, #4a5568 0%, #718096 100%);
      --glass-bg: rgba(74, 85, 104, 0.1);
      --glass-border: rgba(74, 85, 104, 0.2);
      --text-primary: #ffffff;
      --text-secondary: #a0aec0;
      --text-accent: #2d3748;
      --shadow-primary: 0 20px 40px rgba(0, 0, 0, 0.4);
      --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.6);
      --shadow-glow: 0 0 30px rgba(74, 85, 104, 0.3);
      --shadow-glow-accent: 0 0 40px rgba(229, 62, 62, 0.4);
      --border-radius: 20px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      
      --bg: #0f172a;
      --fg: #f0f0f0;
      --accent: #000000;
      --track: #1e293b;
      --hover: rgba(255, 255, 255, 0.1);
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--dark-gradient);
      color: var(--text-primary);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
      line-height: 1.6;
    }

    /* Animated background particles */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 80%, rgba(0, 0, 0, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(26, 26, 26, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(51, 51, 51, 0.1) 0%, transparent 50%);
      z-index: -1;
      animation: float 20s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); }
      33% { transform: translateY(-20px) rotate(1deg); }
      66% { transform: translateY(10px) rotate(-1deg); }
    }
    
    .navbar {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      margin: 24px;
      padding: 1rem 0;
      flex-shrink: 0;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
    }
    
    .container {
      width: 100%;
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .navbar-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .logo {
      display: flex;
      align-items: center;
      color: var(--fg);
      font-size: 1.5rem;
      font-weight: bold;
      text-decoration: none;
    }
    
    .logo span {
      margin-right: 10px;
    }
    
    .nav-buttons {
      display: flex;
      gap: 1rem;
    }
    
    .btn {
      font-size: 1rem;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: var(--text-primary);
      border: 1px solid var(--glass-border);
      padding: 0.75rem 1.5rem;
      border-radius: 15px;
      cursor: pointer;
      text-decoration: none;
      transition: var(--transition);
      font-weight: 500;
      white-space: nowrap;
      position: relative;
      overflow: hidden;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: var(--primary-gradient);
      transition: var(--transition);
      z-index: -1;
    }

    .btn:hover::before {
      left: 0;
    }
    
    .btn:hover {
      color: white;
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      border-color: rgba(0, 0, 0, 0.5);
    }
    
    .btn-primary {
      background: var(--primary-gradient);
      border-color: var(--accent);
      color: white;
    }
    
    .btn-primary:hover {
      background: var(--secondary-gradient);
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
    }
    
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      padding: 0 24px 24px 24px;
    }
    
    .player-wrapper {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      overflow: hidden;
      box-shadow: var(--shadow-primary);
      border: 1px solid var(--glass-border);
      height: 100%;
      display: flex;
      flex-direction: column;
    }
    
    .video-container {
      position: relative;
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 60vh;
      background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
      border-radius: 24px 24px 0 0;
      box-shadow: var(--shadow-glow), inset 0 0 50px rgba(74, 85, 104, 0.1);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
    }
    
    .video-container:hover {
      box-shadow: var(--shadow-glow), inset 0 0 50px rgba(74, 85, 104, 0.2);
      border-color: rgba(74, 85, 104, 0.4);
    }
    
    .video-container.screenshot-mode {
      border-color: rgba(56, 161, 105, 0.8);
      box-shadow: 
        0 0 30px rgba(56, 161, 105, 0.6),
        inset 0 0 50px rgba(56, 161, 105, 0.1);
      animation: screenshotPulse 0.5s ease-in-out infinite alternate;
    }
    
    @keyframes screenshotPulse {
      0% { border-color: rgba(56, 161, 105, 0.8); }
      100% { border-color: rgba(56, 161, 105, 1); }
    }

    video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 24px 24px 0 0;
    }

    #timeline {
      flex-shrink: 0;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 0 0 24px 24px;
      position: relative;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: thin;
      scrollbar-color: var(--accent) transparent;
    }

    /* Video Overlay Controls - Bottom Center */
    .video-controls-overlay {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      z-index: 30;
    }

    .video-container:hover .video-controls-overlay {
      opacity: 1;
      pointer-events: all;
    }

    .video-control-btn {
      background: var(--card-gradient);
      border: 2px solid var(--glass-border);
      color: white;
      font-size: 1.5rem;
      transition: var(--transition);
      width: 60px;
      height: 60px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
    }

    .video-control-btn:hover {
      background: var(--steel-gradient);
      border-color: rgba(74, 85, 104, 0.6);
      transform: scale(1.1) translateY(-2px);
      box-shadow: var(--shadow-glow), 0 12px 30px rgba(0, 0, 0, 0.5);
    }
    
    .video-control-btn:active {
      transform: scale(1.05) translateY(0);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .video-control-btn svg {
      transition: all 0.3s ease;
    }
    
    .video-control-btn:hover svg {
      transform: scale(1.1);
    }
    
    /* Global SVG icon styling */
    svg {
      flex-shrink: 0;
    }
    
    .logo svg {
      transition: all 0.3s ease;
    }
    
    .logo:hover svg {
      transform: rotate(5deg) scale(1.1);
    }
    

    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .play-pause-btn {
      width: 80px;
      height: 80px;
      font-size: 1.5rem;
    }



    /* Zoom Toggle and Fullscreen Controls - Bottom Right */
    .video-utility-controls {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      gap: 0.75rem;
      align-items: center;
      z-index: 30;
    }

    .zoom-toggle-btn {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .zoom-toggle-btn.active {
      background: var(--primary-gradient);
      border-color: var(--accent);
    }

    .zoom-toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    .fullscreen-btn {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 1.2rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fullscreen-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }

    /* Clock Time Display - Bottom Left */
    .clock-display {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: var(--glass-bg);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-family: monospace;
      font-size: 0.9rem;
      color: white;
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      z-index: 30;
    }

    .clock-display.not-live {
      color: rgba(255, 255, 255, 0.7);
    }

    /* Hide default video controls */
    .video-container video::-webkit-media-controls {
      display: none !important;
    }

    .video-container video::-moz-media-controls {
      display: none !important;
    }

    .video-container video {
      outline: none;
    }
    
    .video-info {
      padding: 1rem 2rem;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      flex-shrink: 0;
    }
    
    .video-title {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }
    
    .video-description {
      color: rgba(255,255,255,0.7);
    }
    
    .controls {
      display: flex;
      padding: 0;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(15px);
      -webkit-backdrop-filter: blur(15px);
      border-radius: 0;
      border-top: none;
      gap: 0;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    
    #timeline {
      position: relative;
      width: 100%;
      height: 120px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      margin: 1rem 0;
      flex: none;
    }

    .timeline-viewport {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #timeline-track {
      position: absolute;
      top: 24px;
      left: 0;
      height: calc(100% - 24px);
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    .timeline-container {
      position: relative;
      height: 100%;
      display: flex;
      align-items: stretch;
      min-width: 200%;
    }

    /* Time Hash Styles */
    #time-hashes {
      position: absolute;
      top: 0;
      height: 24px;
      width: 100%;
      display: flex;
      align-items: end;
      font-size: 10px;
      color: rgba(255, 255, 255, 0.6);
      font-family: monospace;
      z-index: 10;
      transition: transform 0.1s ease-out;
      will-change: transform;
    }

    .time-tick {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
    }

    .time-tick-line {
      width: 1px;
      height: 8px;
      background: rgba(255, 255, 255, 0.4);
      margin-bottom: 2px;
    }

    .time-tick-label {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    /* Fixed Scrubber in Center */
    .timeline-scrubber {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 100%;
      background: linear-gradient(180deg, #ff4757 0%, #e53e3e 100%);
      border-radius: 2px;
      z-index: 20;
      box-shadow: 
        0 0 20px rgba(255, 71, 87, 0.8),
        0 0 40px rgba(255, 71, 87, 0.4),
        0 0 60px rgba(255, 71, 87, 0.2);
      pointer-events: none;
      animation: scrubberPulse 2s ease-in-out infinite alternate;
    }
    
    @keyframes scrubberPulse {
      0% {
        box-shadow: 
          0 0 20px rgba(255, 71, 87, 0.8),
          0 0 40px rgba(255, 71, 87, 0.4),
          0 0 60px rgba(255, 71, 87, 0.2);
      }
      100% {
        box-shadow: 
          0 0 30px rgba(255, 71, 87, 1),
          0 0 60px rgba(255, 71, 87, 0.6),
          0 0 90px rgba(255, 71, 87, 0.3);
      }
    }

    .timeline-scrubber::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .timeline-scrubber::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 12px;
      height: 12px;
      background: #ff4757;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }



    .thumbnail-frame {
      position: relative;
      height: 100%;
      border-right: 1px solid rgba(255, 255, 255, 0.1);
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
    }

    .thumbnail-frame:hover {
      transform: scale(1.02);
      z-index: 10;
      box-shadow: 0 5px 15px rgba(112, 184, 255, 0.3);
    }

    .thumbnail-frame img {
      width: 100%;
      height: calc(100% - 20px);
      object-fit: cover;
      border-radius: 4px 4px 0 0;
    }

    .time-tick {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-size: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: monospace;
      border-radius: 0 0 4px 4px;
    }
    
    #scrubber {
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 4px;
      height: 100%;
      background: var(--primary-gradient);
      z-index: 100;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
      pointer-events: none; /* Disable dragging */
    }

    #scrubber::before {
      content: '';
      position: absolute;
      top: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }

    #scrubber::after {
      content: '';
      position: absolute;
      bottom: -8px;
      left: -6px;
      width: 15px;
      height: 15px;
      background: var(--accent);
      border-radius: 50%;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.6);
    }
    
    .thumbnail-preview {
      position: absolute;
      bottom: 140px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 12px;
      display: none;
      z-index: 1000;
      pointer-events: none;
      box-shadow: var(--shadow-primary);
    }
    
    .thumbnail-preview img {
      width: 120px;
      height: 70px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .thumbnail-preview .time-label {
      color: rgba(255, 255, 255, 0.9);
      font-size: 12px;
      text-align: center;
      margin-top: 8px;
      font-family: monospace;
      font-weight: 600;
      background: var(--glass-bg);
      padding: 4px 8px;
      border-radius: 10px;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
      border: 1px solid var(--glass-border);
    }
    
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-top: 4px solid var(--accent);
      border-right: 4px solid rgba(0, 0, 0, 0.6);
      border-radius: 50%;
      animation: spin 1s infinite linear;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow-primary);
    }
    
    @keyframes spin {
      0% { transform: translate(-50%, -50%) rotate(0deg); }
      100% { transform: translate(-50%, -50%) rotate(360deg); }
    }
    

    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
      }
      50% { 
        opacity: 0.8; 
        transform: scale(1.05);
      }
    }
    
    .select-enhanced {
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 12px center;
      background-size: 16px;
      padding-right: 40px;
    }
    
    .select-enhanced option {
      background: rgba(28, 28, 28, 0.95);
      color: white;
      padding: 8px;
    }


    
    /* Welcome Modal Styles */
    .welcome-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 10000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    
    .welcome-modal.show {
      opacity: 1;
      visibility: visible;
    }
    
    .welcome-content {
      background: var(--card-gradient);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 2px solid var(--glass-border);
      border-radius: var(--border-radius);
      padding: 2.5rem;
      max-width: 500px;
      width: 90%;
      text-align: center;
      box-shadow: var(--shadow-primary);
      position: relative;
      animation: modalSlideIn 0.4s ease-out;
    }
    
    @keyframes modalSlideIn {
      from {
        transform: translateY(-50px) scale(0.9);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }
    
    .welcome-title {
      font-size: 2rem;
      font-weight: bold;
      color: var(--text-primary);
      margin-bottom: 1.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .welcome-text {
      color: rgba(255, 255, 255, 0.9);
      line-height: 1.6;
      margin-bottom: 2rem;
      font-size: 1.1rem;
    }
    
    .welcome-actions {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      align-items: center;
    }
    
    .welcome-checkbox {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.9rem;
      margin-bottom: 1rem;
    }
    
    .welcome-checkbox input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
      cursor: pointer;
    }
    
    .welcome-close {
      background: var(--primary-gradient);
      color: white;
      border: none;
      padding: 0.75rem 2rem;
      border-radius: 50px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: var(--shadow-primary);
    }
    
    .welcome-close:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-hover);
      background: var(--secondary-gradient);
    }
    
    .welcome-close:active {
      transform: translateY(0);
    }
    
    /* Stream Type Indicator */
    .stream-type-indicator {
      position: absolute;
      top: 1.5rem;
      left: 1.5rem;
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.9);
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      z-index: 10;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Enhanced Stream Controls */
    .stream-controls-overlay {
      position: absolute;
      bottom: 80px;
      left: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 12px;
      padding: 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      opacity: 0;
      transform: translateY(20px);
      transition: all 0.3s ease;
      z-index: 10;
    }
    
    .stream-controls-overlay.visible {
      opacity: 1;
      transform: translateY(0);
    }
    
    .rewind-controls {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .rewind-btn, .live-btn {
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    
    .rewind-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }
    
    .live-btn {
      background: rgba(239, 68, 68, 0.8);
      border-color: rgba(239, 68, 68, 0.9);
    }
    
    .live-btn:hover {
      background: rgba(239, 68, 68, 0.9);
    }
    
    .live-btn.active {
      background: rgba(239, 68, 68, 1);
      box-shadow: 0 0 20px rgba(239, 68, 68, 0.5);
      animation: pulse 2s infinite;
    }
    
    .timeline-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      color: rgba(255, 255, 255, 0.8);
    }
    
    .buffer-info {
      font-size: 0.75rem;
      color: rgba(255, 255, 255, 0.6);
      margin-top: 0.25rem;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    /* Notification Animations */
    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }
      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }
    
    /* Enhanced Clock Display */
    .clock-display {
      font-family: 'Courier New', monospace;
      font-weight: bold;
      transition: all 0.3s ease;
    }
    
    .clock-display.not-live {
      background: rgba(107, 114, 128, 0.8);
    }
    
    /* Behind Live Indicator */
    .behind-live-indicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(239, 68, 68, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      z-index: 1000;
      animation: pulse-warning 2s infinite;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }
    
    @keyframes pulse-warning {
      0%, 100% { opacity: 0.9; }
      50% { opacity: 0.6; }
    }
    
    /* LIVE Button Pulse Animation */
    .live-button-pulse {
      animation: pulse-live 1.5s infinite !important;
      box-shadow: 0 0 20px rgba(34, 197, 94, 0.6) !important;
    }
    
    @keyframes pulse-live {
      0%, 100% { 
        background: #22c55e !important;
        transform: scale(1);
      }
      50% { 
        background: #16a34a !important;
        transform: scale(1.05);
      }
    }
    
    /* Enhanced Timeline Canvas */
    #timelineCanvas {
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }
    
    #timelineCanvas:hover {
      cursor: crosshair;
    }
    
    #timelineCanvas.dragging {
      cursor: grabbing !important;
    }
    
    /* Stream Status Overlay */
    .stream-status-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.8);
      font-size: 1.2rem;
      font-weight: 500;
      text-align: center;
      pointer-events: none;
      z-index: 10;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      letter-spacing: 0.5px;
      user-select: none;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }
    
    .stream-status-overlay.hidden {
      opacity: 0;
      visibility: hidden;
    }
    
    .stream-status-overlay.paused {
      color: rgba(255, 71, 87, 0.9);
      animation: pulse-warning 2s infinite;
    }
    
    /* Sync Status Indicator */
    .sync-status {
      position: absolute;
      top: 20px;
      right: 20px;
      background: var(--card-gradient);
      color: white;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 600;
      z-index: 25;
      display: flex;
      align-items: center;
      gap: 6px;
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      transition: var(--transition);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    .sync-status.live {
      background: linear-gradient(135deg, #38a169 0%, #2f855a 100%);
      border-color: rgba(56, 161, 105, 0.5);
      box-shadow: 
        var(--shadow-glow-accent),
        0 0 20px rgba(56, 161, 105, 0.6),
        0 4px 15px rgba(0, 0, 0, 0.3);
      animation: livePulse 2s ease-in-out infinite alternate;
    }
    
    .sync-status.behind {
      background: linear-gradient(135deg, #d69e2e 0%, #b7791f 100%);
      border-color: rgba(214, 158, 46, 0.5);
      box-shadow: 
        0 0 20px rgba(214, 158, 46, 0.4),
        0 4px 15px rgba(0, 0, 0, 0.3);
    }
    
    @keyframes livePulse {
      0% {
        box-shadow: 
          0 0 20px rgba(56, 161, 105, 0.6),
          0 4px 15px rgba(0, 0, 0, 0.3);
      }
      100% {
        box-shadow: 
          0 0 30px rgba(56, 161, 105, 0.8),
          0 0 50px rgba(56, 161, 105, 0.4),
          0 4px 15px rgba(0, 0, 0, 0.3);
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="/socket.io/socket.io.js"></script>
</head>
<body>
  <nav class="navbar">
    <div class="container">
      <div class="navbar-content">
        <a href="/" class="logo">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 10px;">
            <path d="M12 2L2 7l10 5 10-5-10-5z"></path>
            <path d="M2 17l10 5 10-5"></path>
            <path d="M2 12l10 5 10-5"></path>
          </svg>
          SMX Stream
        </a>
        
        <div class="nav-buttons">
          <a href="dashboard.html" class="btn">Dashboard</a>
          <a href="#" class="btn">Settings</a>
        </div>
      </div>
    </div>
  </nav>
  
  <div class="main-content">
    <div class="player-wrapper">
        <div class="video-container">

          
          <!-- Video Elements -->
          <video id="video" autoplay muted style="display:none;" 
                 onerror="handleVideoError(this, 'main')"
                 onloadstart="handleVideoLoadStart(this, 'main')"
                 oncanplay="handleVideoCanPlay(this, 'main')"></video>
          <video id="hlsVideo" controls autoplay muted style="display:block; width:100%; height:100%; background:#000;"
                 onerror="handleVideoError(this, 'hls')"
                 onloadstart="handleVideoLoadStart(this, 'hls')"
                 oncanplay="handleVideoCanPlay(this, 'hls')"
                 ontimeupdate="handleTimeUpdate(this)"
                 onplay="handlePlayStateChange(true)"
                 onpause="handlePlayStateChange(false)"
                 onseeked="handleSeek(this)"></video>
          
          <!-- Stream Status Overlay -->
          <div id="streamStatusText" class="stream-status-overlay">
            Instructor Will Start Stream Soon
          </div>
          
          <div class="loading-spinner" id="loading"></div>
          <div class="stream-type-indicator" id="streamTypeIndicator">🔴 HLS Live Stream</div>
          
          <!-- Enhanced Stream Controls -->
          <div class="stream-controls-overlay" id="streamControls" style="display:none;">
            <div class="rewind-controls">
              <button class="rewind-btn" onclick="rewindStream(30)">⏪ 30s</button>
              <button class="rewind-btn" onclick="rewindStream(60)">⏪ 1m</button>
              <button class="rewind-btn" onclick="rewindStream(300)">⏪ 5m</button>
              <button class="live-btn" onclick="goToLive()" id="liveBtn">🔴 LIVE</button>
            </div>
            <div class="timeline-info" id="timelineInfo">
              <span id="currentTimeDisplay">00:00</span> / <span id="durationDisplay">LIVE</span>
              <span id="bufferInfo" class="buffer-info"></span>
            </div>
          </div>
          
          <!-- Sync Status Indicator -->
          <div class="sync-status" id="syncStatus" style="display:none;">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor">
              <circle cx="12" cy="12" r="10"></circle>
            </svg>
            <span id="syncStatusText">SYNCED</span>
          </div>
          
          <!-- Video Overlay Controls - Bottom Center -->
          <div class="video-controls-overlay">
            <!-- Rewind Buttons -->
            <button class="video-control-btn rewind-btn" onclick="rewindVideo(30)" title="Rewind 30s">
              ⏪ 30s
            </button>
            <button class="video-control-btn rewind-btn" onclick="rewindVideo(60)" title="Rewind 1m">
              ⏪ 1m
            </button>
            <button class="video-control-btn rewind-btn" onclick="rewindVideo(300)" title="Rewind 5m">
              ⏪ 5m
            </button>
            
            <!-- Play/Pause Button -->
            <button class="video-control-btn play-pause-btn" id="playPauseBtn" onclick="togglePlayPause()" title="Play/Pause">
              ⏸
            </button>
            
            <!-- Go Live Button -->
            <button class="video-control-btn go-live-btn" onclick="jumpToLive()" title="Go Live">
              🔴 LIVE
            </button>
          </div>
          
          <!-- Zoom Toggle and Fullscreen - Bottom Right -->
          <div class="video-utility-controls">
            <button class="zoom-toggle-btn" id="jumpToLiveBtn" onclick="jumpToLive()" title="Jump to Live" style="display:none; background: #22c55e; border-color: #16a34a;">
              GO LIVE
            </button>
            <button class="zoom-toggle-btn" id="zoomToggleBtn" onclick="toggleZoomMode()" title="Toggle Timeline Zoom">
              Zoom
            </button>
            <button class="fullscreen-btn" onclick="toggleFullscreen()" title="Fullscreen">
              ⛶
            </button>
          </div>
          
          <!-- Clock Time Display - Bottom Left -->
          <div class="clock-display" id="clockDisplay">
            --:--:--
          </div>
          
          <!-- Behind Live Indicator - Top Right -->
          <div class="behind-live-indicator" id="behindLiveIndicator" style="display:none;">
            📡 You are <span id="behindLiveSeconds">0</span> seconds behind live
          </div>
          
          <!-- Debug Panel (hidden by default) -->
          <div id="debugPanel" style="display: none; position: absolute; top: 60px; right: 20px; background: rgba(0,0,0,0.9); color: white; padding: 15px; border-radius: 10px; font-family: monospace; font-size: 11px; max-width: 350px; z-index: 100; border: 1px solid #333;">
            <div style="font-weight: bold; margin-bottom: 10px; color: #4CAF50;">🐛 Stream Debug Info</div>
            <div id="debugInfo"></div>
            <button onclick="toggleDebugPanel()" style="margin-top: 10px; padding: 5px 10px; background: #333; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 11px;">Hide Debug</button>
          </div>
          
          <!-- Debug Toggle Button -->
          <button id="debugToggle" onclick="toggleDebugPanel()" style="position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: none; padding: 6px 10px; border-radius: 5px; cursor: pointer; font-size: 11px; z-index: 50; backdrop-filter: blur(5px);">🐛</button>
        </div>
        


        
        <!-- Timeline (flush with video, no spacing) -->
        <div class="controls">
          <div id="timeline">
            <div class="timeline-viewport">
              <!-- Time Hash Ticks -->
              <div id="time-hashes" class="absolute top-0 h-6 w-full flex items-end text-xs text-gray-400 font-mono z-10">
                <!-- Time hash ticks will be generated here -->
              </div>
              
              <!-- Timeline Track -->
              <div id="timeline-track" class="absolute top-6 left-0 h-26 flex">
                <div class="timeline-container" id="timelineContainer">
                  <!-- Timeline frames will be generated here -->
                </div>
              </div>
              
              <!-- Enhanced Canvas Timeline -->
              <canvas id="timelineCanvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; cursor: pointer;"></canvas>
              
              <!-- Draggable Scrubber -->
              <div id="scrubber"></div>
              

            </div>
          </div>
        </div>
        
        <!-- Thumbnail preview -->
        <div class="thumbnail-preview" id="thumbnailPreview">
          <img id="thumbnailImg" src="" alt="Preview">
          <div class="time-label" id="thumbnailTime">0:00</div>
        </div>
        
        <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
      </div>
  </div>


  
  <!-- Welcome Modal -->
  <div class="welcome-modal" id="welcomeModal">
    <div class="welcome-content">
      <h2 class="welcome-title">WELCOME TO SMX STREAM</h2>
      <div class="welcome-text">
        <p>SMX Stream is your live training platform for Security Mission Exercises. Watch live training sessions, access recorded content, and interact with instructors in real-time.</p>
        <br>
        <p><strong>Keyboard Shortcuts:</strong></p>
        <ul style="text-align: left; margin: 10px 0; padding-left: 20px;">
          <li><strong>Space/K</strong> - Play/Pause</li>
          <li><strong>J/L</strong> - Skip backward/forward 10s</li>
          <li><strong>Shift+L</strong> - Jump to LIVE</li>
          <li><strong>M</strong> - Mute/Unmute</li>
          <li><strong>F</strong> - Fullscreen</li>
          <li><strong>Arrow Keys</strong> - Skip 5s</li>
        </ul>
        <p><strong>Timeline:</strong> Double-click any time marker to jump to LIVE edge</p>
      </div>
      <div class="welcome-actions">
        <div class="welcome-checkbox">
          <input type="checkbox" id="dontShowAgain">
          <label for="dontShowAgain">Don't show this again</label>
        </div>
        <button class="welcome-close" id="closeWelcome">Get Started</button>
      </div>
    </div>
  </div>
  
  <script>
    // ===== ICONS =====
    const Icons = {
      play: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>',
      pause: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>',
      rewind: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M11 18V6l-8.5 6 8.5 6zm.5-6l8.5 6V6l-8.5 6z"/></svg>',
      forward: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M4 18l8.5-6L4 6v12zm9-12v12l8.5-6L13 6z"/></svg>',
      fullscreen: '<svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/></svg>'
    };
    
    // ===== REAL-TIME SYNCHRONIZATION VARIABLES =====
    let socket = null;
    let classId = null;
    let instructorTime = 0;
    let instructorPlaying = false;
    let streamStartTime = null; // When the stream started (actual time)
    let isLiveSynced = true; // Whether student is at live edge
    let liveEdgeTime = 0; // Current live edge time
    let behindLiveSeconds = 0; // How many seconds behind live
    let lastSyncTime = 0; // Last time we synced with instructor
    let isLive = false;
    let canSeekAhead = false; // Students cannot seek ahead of instructor
    let isInstructor = false; // Track if current user is instructor
    
    // ===== HLS STREAMING VARIABLES =====
    let hlsInstance = null;
    let currentVideo = null; // Reference to active video element
    let streamKey = null;
    let isStreamActive = false;
    let hlsUrl = null;
    let rewindBuffer = 300; // 5 minutes rewind buffer in seconds
    let streamTimer = null; // Custom timer for HLS streams
    let liveEdgeTime = 0; // Current live edge timestamp
    let isAtLiveEdge = true; // Whether viewer is at live edge
    let bufferInfo = { start: 0, end: 0 }; // Buffer information

    // ===== UTILITY FUNCTIONS =====
    function getQueryParam(param) {
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get(param);
    }

    function hideLoadingSpinner() {
      const loading = document.getElementById('loading');
      if (loading) loading.style.display = 'none';
    }

    function showErrorMessage(title, message) {
      console.error(`${title}: ${message}`);
      // You can implement a proper error display here
      alert(`${title}: ${message}`);
    }

    // ===== AUTO-POLLING HLS INITIALIZATION =====
    function initializeCleanHLS() {
      const classId = getQueryParam('classId');
      if (!classId) {
        console.error('❌ No classId parameter found');
        showErrorMessage('Missing Class ID', 'Please access this page with a valid class ID parameter.');
        return null;
      }
      
      const video = document.getElementById('hlsVideo');
      if (!video) {
        console.error('❌ hlsVideo element not found');
        return null;
      }
      
      console.log('🎬 Initializing HLS with auto-polling for class:', classId);
      
      // Determine stream URL
      let streamUrl;
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        streamUrl = `http://localhost/hls/${classId}.m3u8`;
      } else {
        streamUrl = `http://198.211.107.134/hls/${classId}.m3u8`;
      }
      
      console.log('🔍 Stream URL:', streamUrl);
      
      // Show loading spinner while waiting for stream
      showLoadingSpinner();
      
      // Start waiting for stream with auto-polling
      waitForStream(streamUrl, video, classId);
      
      return null; // Will return HLS instance once stream is available
    }
    
    // ===== AUTO-POLLING STREAM DETECTION =====
    function waitForStream(streamUrl, videoElement, classId) {
      console.log('⏳ Checking for stream availability...');
      
      fetch(streamUrl, { 
        method: 'HEAD',
        cache: 'no-cache',
        headers: {
          'Cache-Control': 'no-cache'
        }
      })
      .then(res => {
        if (res.ok) {
          console.log('✅ Stream is available! Loading HLS...');
          loadStream(streamUrl, videoElement, classId);
        } else {
          console.log(`⏳ Stream not ready (${res.status}), retrying in 3 seconds...`);
          setTimeout(() => waitForStream(streamUrl, videoElement, classId), 3000);
        }
      })
      .catch(error => {
        console.log('⏳ Stream not available yet, retrying in 3 seconds...', error.message);
        setTimeout(() => waitForStream(streamUrl, videoElement, classId), 3000);
      });
    }
    
    // ===== LOAD STREAM ONCE AVAILABLE =====
    function loadStream(streamUrl, videoElement, classId) {
      console.log('🎬 Loading HLS stream for class:', classId);
      
      // Create HLS instance with optimized settings
      const hls = new Hls({
        enableWorker: true,
        lowLatencyMode: true,
        backBufferLength: 90,
        maxBufferLength: 300, // 5 minute buffer
        maxMaxBufferLength: 600,
        liveSyncDurationCount: 3,
        liveMaxLatencyDurationCount: 10
      });
      
      hls.loadSource(streamUrl);
      hls.attachMedia(videoElement);
      
      // Handle HLS events
      hls.on(Hls.Events.MANIFEST_PARSED, function() {
        console.log('✅ HLS stream loaded and parsed for class:', classId);
        videoElement.play().catch(e => console.log('🔇 Autoplay prevented:', e));
        isStreamActive = true;
        hideLoadingSpinner();
        
        // Show success notification
        showNotification('Stream Connected', 'Live stream is now playing!', 'success');
      });
      
      hls.on(Hls.Events.ERROR, function(event, data) {
        console.error('❌ HLS Error:', data);
        if (data.fatal) {
          console.log('💥 Fatal HLS error, restarting stream detection...');
          hls.destroy();
          isStreamActive = false;
          showLoadingSpinner();
          
          // Restart the polling process
          setTimeout(() => waitForStream(streamUrl, videoElement, classId), 5000);
        }
      });
      
      // Handle stream end/disconnect
      hls.on(Hls.Events.BUFFER_APPENDING_ERROR, function() {
        console.log('📡 Stream may have ended, checking...');
        setTimeout(() => {
          if (videoElement.readyState === 0) {
            console.log('🔄 Stream disconnected, restarting detection...');
            hls.destroy();
            isStreamActive = false;
            showLoadingSpinner();
            waitForStream(streamUrl, videoElement, classId);
          }
        }, 2000);
      });
      
      // Store references
      hlsInstance = hls;
      currentVideo = videoElement;
      hlsUrl = streamUrl;
      
      return hls;
    }
      
      // Handle HLS events
      hls.on(Hls.Events.MANIFEST_PARSED, function() {
        console.log('✅ HLS stream loaded and parsed for class:', classId);
        videoElement.play().catch(e => console.log('🔇 Autoplay prevented:', e));
        isStreamActive = true;
        hideLoadingSpinner();
        
        // Show success notification
        showNotification('Stream Connected', 'Live stream is now playing!', 'success');
      });
      
      hls.on(Hls.Events.ERROR, function(event, data) {
        console.error('❌ HLS Error:', data);
        if (data.fatal) {
          console.log('💥 Fatal HLS error, restarting stream detection...');
          hls.destroy();
          isStreamActive = false;
          showLoadingSpinner();
          
          // Restart the polling process
          setTimeout(() => waitForStream(streamUrl, videoElement, classId), 5000);
        }
      });
      
      // Handle stream end/disconnect
      hls.on(Hls.Events.BUFFER_APPENDING_ERROR, function() {
        console.log('📡 Stream may have ended, checking...');
        setTimeout(() => {
          if (videoElement.readyState === 0) {
            console.log('🔄 Stream disconnected, restarting detection...');
            hls.destroy();
            isStreamActive = false;
            showLoadingSpinner();
            waitForStream(streamUrl, videoElement, classId);
          }
        }, 2000);
      });
      
      // Store references
      hlsInstance = hls;
      currentVideo = videoElement;
      hlsUrl = streamUrl;
      
      return hls;
    }
    
    // ===== ENHANCED TIMELINE VARIABLES =====
    let timelineCanvas = null;
    let timelineCtx = null;
    let zoomLevel = 1; // 1 = 30 seconds visible, higher = more zoomed in
    let viewportStart = 0; // Start time of visible timeline range
    let visibleDuration = 30; // Seconds visible in timeline
    let thumbnailCache = new Map(); // Cache for video thumbnails
    let isDragging = false;
    let dragStartX = 0;
    let dragStartViewport = 0;
    let tooltipVisible = false;
    let tooltipX = 0;
    let tooltipTime = 0;
    
    // ===== SCREENSHOT FUNCTIONALITY VARIABLES =====
    let isScreenshotMode = false;
    let screenshotStartTime = 0;
    let screenshotCanvas = null;
    let screenshotContext = null;
    
    // ===== WELCOME MODAL FUNCTIONALITY =====
    const welcomeModal = document.getElementById('welcomeModal');
    const closeWelcomeBtn = document.getElementById('closeWelcome');
    const dontShowAgainCheckbox = document.getElementById('dontShowAgain');
    
    // Check if user has chosen not to show the welcome modal
    function shouldShowWelcome() {
      return localStorage.getItem('smx-stream-hide-welcome') !== 'true';
    }
    
    // Show welcome modal on page load
    function showWelcomeModal() {
      if (shouldShowWelcome()) {
        setTimeout(() => {
          welcomeModal.classList.add('show');
        }, 500); // Small delay for better UX
      }
    }
    
    // Close welcome modal
    function closeWelcomeModal() {
      welcomeModal.classList.remove('show');
      
      // Save preference if checkbox is checked
      if (dontShowAgainCheckbox.checked) {
        localStorage.setItem('smx-stream-hide-welcome', 'true');
      }
    }
    
    // Event listeners for welcome modal
    closeWelcomeBtn.addEventListener('click', closeWelcomeModal);
    
    // Close modal when clicking outside the content
    welcomeModal.addEventListener('click', function(e) {
      if (e.target === welcomeModal) {
        closeWelcomeModal();
      }
    });
    
    // Close modal with Escape key
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && welcomeModal.classList.contains('show')) {
        closeWelcomeModal();
      }
    });
    
    // Icon utility functions
    const Icons = {
      play: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,3 19,12 5,21"></polygon></svg>`,
      pause: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>`,
      rewind: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11,19 2,12 11,5"></polygon><polygon points="22,19 13,12 22,5"></polygon></svg>`,
      fastForward: `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="13,19 22,12 13,5"></polygon><polygon points="2,19 11,12 2,5"></polygon></svg>`,
      live: `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" style="color: #ff4757;"><circle cx="12" cy="12" r="10"></circle></svg>`,
      zoomIn: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>`,
      zoomOut: `<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="M21 21l-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>`
    };

    // ===== HLS STREAMING INITIALIZATION =====
    // Simple HLS initialization as per specification
    function initializeSimpleHLS(classId) {
      const video = document.getElementById('hlsVideo');
      if (!video) {
        console.error('❌ HLS video element not found');
        return;
      }
      
      if (Hls.isSupported()) {
        const hls = new Hls({
          enableWorker: true,
          lowLatencyMode: true,
          backBufferLength: 300, // 5 minutes rewind buffer
          debug: false
        });
        
        const hlsUrl = `http://198.211.107.134/hls/${classId}.m3u8`;
        console.log('📡 Loading HLS stream:', hlsUrl);
        
        hls.loadSource(hlsUrl);
        hls.attachMedia(video);
        
        hls.on(Hls.Events.MANIFEST_PARSED, () => {
          console.log('✅ HLS manifest loaded, starting playback');
          video.play().catch(e => console.log('Autoplay prevented:', e));
        });
        
        return hls;
      } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
        // Native HLS support (Safari)
        video.src = `http://198.211.107.134/hls/${classId}.m3u8`;
        video.play().catch(e => console.log('Autoplay prevented:', e));
      } else {
        console.error('❌ HLS not supported in this browser');
      }
    }

    // Full HLS initialization with advanced features
    async function initializeHLSStream(streamData) {
      try {
        console.log('🎬 Initializing HLS stream with data:', streamData);
        
        // Set current video element to HLS video
        currentVideo = hlsVideo;
        
        // Hide other video elements
        if (video) video.style.display = 'none';
        if (webrtcVideo) webrtcVideo.style.display = 'none';
        
        // Show HLS video element
        hlsVideo.style.display = 'block';
        
        // Construct HLS URL based on class ID or stream key
        const classId = streamData.classId || getCurrentClassId();
        if (classId) {
          hlsUrl = `http://198.211.107.134/hls/${classId}.m3u8`;
        } else if (streamKey) {
          hlsUrl = `http://198.211.107.134/hls/${streamKey}.m3u8`;
        } else {
          throw new Error('No class ID or stream key available for HLS URL');
        }
        console.log('📡 HLS URL:', hlsUrl);
        
        // Initialize HLS.js
        if (Hls.isSupported()) {
          console.log('✅ HLS.js is supported');
          
          // Destroy existing instance if any
          if (hlsInstance) {
            hlsInstance.destroy();
          }
          
          // Create new HLS instance with optimized settings
          hlsInstance = new Hls({
            enableWorker: true,
            lowLatencyMode: true,
            backBufferLength: rewindBuffer, // Allow rewind buffer
            maxBufferLength: 30, // Keep buffer reasonable for live
            maxMaxBufferLength: 60,
            liveSyncDurationCount: 3,
            liveMaxLatencyDurationCount: 10,
            debug: false
          });
          
          // Load the HLS stream
          hlsInstance.loadSource(hlsUrl);
          hlsInstance.attachMedia(hlsVideo);
          
          // Handle HLS events
          hlsInstance.on(Hls.Events.MANIFEST_PARSED, function() {
            console.log('📋 HLS manifest parsed');
            hlsVideo.play().catch(e => console.log('🔇 HLS autoplay prevented:', e));
            isStreamActive = true;
            
            // Initialize stream timer
            initializeStreamTimer();
            
            // Update UI
            updateStreamTypeIndicator('HLS Live Stream');
            loading.style.display = 'none';
          });
          
          hlsInstance.on(Hls.Events.ERROR, function(event, data) {
            console.error('❌ HLS error:', event, data);
            
            if (data.fatal) {
              switch(data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  console.log('🔄 Network error, attempting to recover...');
                  hlsInstance.startLoad();
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  console.log('🔄 Media error, attempting to recover...');
                  hlsInstance.recoverMediaError();
                  break;
                default:
                  console.error('💥 Fatal HLS error, destroying instance');
                  hlsInstance.destroy();
                  hlsInstance = null;
                  // Retry connection after 5 seconds
                  setTimeout(() => {
                    console.log('🔄 Retrying HLS connection...');
                    initializeHLSStream(streamData);
                  }, 5000);
                  break;
              }
            }
          });
          
          hlsInstance.on(Hls.Events.LEVEL_LOADED, function(event, data) {
            console.log('📊 HLS level loaded:', data.details);
            // Update live edge information
            if (data.details.live) {
              liveEdgeTime = data.details.totalduration || 0;
              isLive = true;
            }
          });
          
        } else if (hlsVideo.canPlayType('application/vnd.apple.mpegurl')) {
          // Native HLS support (Safari)
          console.log('✅ Native HLS support detected');
          hlsVideo.src = hlsUrl;
          hlsVideo.addEventListener('loadedmetadata', function() {
            hlsVideo.play().catch(e => console.log('🔇 Native HLS autoplay prevented:', e));
            isStreamActive = true;
            initializeStreamTimer();
            updateStreamTypeIndicator('HLS Live Stream (Native)');
            loading.style.display = 'none';
          });
        } else {
          console.error('❌ HLS is not supported in this browser');
          showErrorMessage('Browser Not Supported', 'Your browser does not support HLS streaming. Please use a modern browser like Chrome, Firefox, or Safari.');
          return;
        }
        
        // Add video event listeners
        hlsVideo.addEventListener('canplay', function() {
          console.log('▶️ HLS video can play');
          loading.style.display = 'none';
        });
        
        hlsVideo.addEventListener('waiting', function() {
          console.log('⏳ HLS video waiting for data');
          loading.style.display = 'block';
        });
        
        hlsVideo.addEventListener('playing', function() {
          console.log('▶️ HLS video playing');
          loading.style.display = 'none';
        });
        
        hlsVideo.addEventListener('error', function(e) {
          console.error('❌ HLS video error:', e);
          loading.style.display = 'block';
        });
        
        // Add timeline interaction for HLS
        setupHLSTimeline();
        
        // Show enhanced stream controls
        showStreamControls();
        
      } catch (error) {
        console.error('❌ Error initializing HLS stream:', error);
        showErrorMessage('Stream Error', 'Failed to initialize the live stream. Please refresh the page and try again.');
      }
    }
    
    // ===== ENHANCED HLS FUNCTIONS =====
    function rewindStream(seconds) {
      if (!hlsVideo || !hlsVideo.duration) {
        console.warn('Cannot rewind: video not ready');
        return;
      }
      
      const currentTime = hlsVideo.currentTime;
      const newTime = Math.max(0, currentTime - seconds);
      const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
      
      if (newTime >= minSeekTime) {
        hlsVideo.currentTime = newTime;
        isAtLiveEdge = false;
        updateLiveButton();
        console.log(`⏪ Rewound ${seconds}s to ${formatTime(newTime)}`);
      } else {
        console.warn(`Cannot rewind ${seconds}s: would exceed buffer limit`);
        showNotification(`Cannot rewind ${seconds}s - buffer limit reached`);
      }
    }
    
    function goToLive() {
      if (!hlsVideo || !hlsVideo.duration) {
        console.warn('Cannot go to live: video not ready');
        return;
      }
      
      // Seek to the live edge (end of buffer)
      hlsVideo.currentTime = hlsVideo.duration;
      isAtLiveEdge = true;
      updateLiveButton();
      console.log('🔴 Jumped to live edge');
    }
    
    function updateLiveButton() {
      const liveBtn = document.getElementById('liveBtn');
      if (liveBtn) {
        if (isAtLiveEdge) {
          liveBtn.classList.add('active');
          liveBtn.textContent = '🔴 LIVE';
        } else {
          liveBtn.classList.remove('active');
          liveBtn.textContent = '📺 GO LIVE';
        }
      }
    }
    
    function showStreamControls() {
      const streamControls = document.getElementById('streamControls');
      if (streamControls) {
        streamControls.style.display = 'flex';
        setTimeout(() => {
          streamControls.classList.add('visible');
        }, 100);
      }
    }
    
    function hideStreamControls() {
      const streamControls = document.getElementById('streamControls');
      if (streamControls) {
        streamControls.classList.remove('visible');
        setTimeout(() => {
          streamControls.style.display = 'none';
        }, 300);
      }
    }
    
    function handleTimeUpdate(video) {
      if (!video || !video.duration) return;
      
      const currentTime = video.currentTime;
      const duration = video.duration;
      
      // Update time displays
      updateTimeDisplays(currentTime, duration);
      
      // Update buffer info
      updateBufferInfo(video);
      
      // Check if at live edge
      const liveThreshold = 3; // seconds
      isAtLiveEdge = (duration - currentTime) < liveThreshold;
      updateLiveButton();
      
      // Update timeline
      updateTimelineDisplay();
    }
    
    function handlePlayStateChange(isPlaying) {
      console.log(`🎵 Play state changed: ${isPlaying ? 'playing' : 'paused'}`);
      
      if (isPlaying) {
        showStreamControls();
      }
    }
    
    function handleSeek(video) {
      if (!video) return;
      
      const currentTime = video.currentTime;
      const duration = video.duration;
      
      console.log(`🎯 Seeked to: ${formatTime(currentTime)}`);
      
      // Check if still at live edge after seek
      const liveThreshold = 3;
      isAtLiveEdge = (duration - currentTime) < liveThreshold;
      updateLiveButton();
      
      // Update displays
      updateTimeDisplays(currentTime, duration);
    }
    
    // ===== LOADING SPINNER FUNCTIONS =====
    function showLoadingSpinner() {
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      // Remove existing spinner if any
      const existingSpinner = videoContainer.querySelector('.loading-spinner');
      if (existingSpinner) {
        existingSpinner.remove();
      }
      
      // Create loading spinner overlay
      const spinnerOverlay = document.createElement('div');
      spinnerOverlay.className = 'loading-spinner';
      spinnerOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        color: white;
      `;
      
      spinnerOverlay.innerHTML = `
        <div style="
          width: 50px;
          height: 50px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid #ffa726;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 1rem;
        "></div>
        <div style="font-size: 1.1rem; font-weight: 500;">Waiting for stream...</div>
        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.7); margin-top: 0.5rem;">
          The instructor will start streaming shortly
        </div>
      `;
      
      // Add CSS animation if not already present
      if (!document.querySelector('#spinner-styles')) {
        const style = document.createElement('style');
        style.id = 'spinner-styles';
        style.textContent = `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `;
        document.head.appendChild(style);
      }
      
      videoContainer.appendChild(spinnerOverlay);
    }
    
    function hideLoadingSpinner() {
      const spinner = document.querySelector('.loading-spinner');
      if (spinner) {
        spinner.remove();
      }
    }
    
    function updateTimeDisplays(currentTime, duration) {
      const currentTimeDisplay = document.getElementById('currentTimeDisplay');
      const durationDisplay = document.getElementById('durationDisplay');
      
      if (currentTimeDisplay) {
        currentTimeDisplay.textContent = formatTime(currentTime);
      }
      
      if (durationDisplay) {
        if (isLive && isAtLiveEdge) {
          durationDisplay.textContent = 'LIVE';
        } else {
          durationDisplay.textContent = formatTime(duration);
        }
      }
    }
    
    function updateBufferInfo(video) {
      if (!video.buffered || video.buffered.length === 0) return;
      
      const buffered = video.buffered;
      const currentTime = video.currentTime;
      
      // Find the buffer range that contains current time
      for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        
        if (currentTime >= start && currentTime <= end) {
          bufferInfo = { start, end };
          
          const bufferAhead = end - currentTime;
          const bufferBehind = currentTime - start;
          
          const bufferInfoEl = document.getElementById('bufferInfo');
          if (bufferInfoEl) {
            bufferInfoEl.textContent = `Buffer: ${formatTime(bufferBehind)} / ${formatTime(bufferAhead)}`;
          }
          break;
        }
      }
    }
    
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) return '00:00';
      
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      
      if (hours > 0) {
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      } else {
        return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
    }
    
    function showNotification(message, type = 'info') {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: white;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        z-index: 1000;
        font-size: 0.875rem;
        font-weight: 500;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        transform: translateX(100%);
        transition: transform 0.3s ease;
      `;
      
      document.body.appendChild(notification);
      
      // Animate in
      setTimeout(() => {
        notification.style.transform = 'translateX(0)';
      }, 100);
      
      // Remove after 3 seconds
      setTimeout(() => {
        notification.style.transform = 'translateX(100%)';
        setTimeout(() => {
          document.body.removeChild(notification);
        }, 300);
      }, 3000);
    }
    
    // ===== LOADING SPINNER FUNCTIONS =====
    function showLoadingSpinner() {
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      // Remove existing spinner if any
      const existingSpinner = videoContainer.querySelector('.loading-spinner');
      if (existingSpinner) {
        existingSpinner.remove();
      }
      
      // Create loading spinner overlay
      const spinnerOverlay = document.createElement('div');
      spinnerOverlay.className = 'loading-spinner';
      spinnerOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        color: white;
      `;
      
      spinnerOverlay.innerHTML = `
        <div style="
          width: 50px;
          height: 50px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid #ffa726;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin-bottom: 1rem;
        "></div>
        <div style="font-size: 1.1rem; font-weight: 500;">Waiting for stream...</div>
        <div style="font-size: 0.9rem; color: rgba(255, 255, 255, 0.7); margin-top: 0.5rem;">
          The instructor will start streaming shortly
        </div>
      `;
      
      // Add CSS animation if not already present
      if (!document.querySelector('#spinner-styles')) {
        const style = document.createElement('style');
        style.id = 'spinner-styles';
        style.textContent = `
          @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
        `;
        document.head.appendChild(style);
      }
      
      videoContainer.appendChild(spinnerOverlay);
    }
    
    function hideLoadingSpinner() {
      const spinner = document.querySelector('.loading-spinner');
      if (spinner) {
        spinner.remove();
      }
    }
    
    // ===== HLS STREAM TIMER =====
    function initializeStreamTimer() {
      if (streamTimer) {
        clearInterval(streamTimer.interval);
      }
      
      streamTimer = {
        startTime: Date.now(),
        currentTime: 0,
        interval: null,
        
        start: function() {
          this.interval = setInterval(() => {
            if (isStreamActive && hlsVideo && !hlsVideo.paused) {
              this.currentTime = (Date.now() - this.startTime) / 1000;
              updateTimelineDisplay();
            }
          }, 100);
        },
        
        setTime: function(time) {
          if (hlsVideo && hlsVideo.duration) {
            // For HLS, we can seek within the available buffer
            const maxSeekTime = Math.min(time, hlsVideo.duration);
            const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
            
            if (time >= minSeekTime && time <= maxSeekTime) {
              hlsVideo.currentTime = time;
              this.currentTime = time;
              console.log(`⏯️ HLS seek to: ${formatTime(time)}`);
            } else {
              console.log(`⚠️ Seek time ${formatTime(time)} outside allowed range [${formatTime(minSeekTime)}, ${formatTime(maxSeekTime)}]`);
            }
          }
        },
        
        getCurrentTime: function() {
          return hlsVideo ? hlsVideo.currentTime : this.currentTime;
        },
        
        getDuration: function() {
          return hlsVideo ? hlsVideo.duration : 0;
        }
      };
      
      streamTimer.start();
    }
    
    // ===== HLS TIMELINE SETUP =====
    function setupHLSTimeline() {
      if (!timeline || !hlsVideo) return;
      
      // Timeline click handler for HLS seeking
      timeline.addEventListener('click', function(e) {
        if (!hlsVideo.duration) return;
        
        const rect = timeline.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const timelineWidth = rect.width;
        
        // Calculate seek time based on available buffer
        const maxSeekTime = hlsVideo.duration;
        const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
        const seekRange = maxSeekTime - minSeekTime;
        
        const clickProgress = clickX / timelineWidth;
        const seekTime = minSeekTime + (clickProgress * seekRange);
        
        if (streamTimer) {
          streamTimer.setTime(seekTime);
        }
        
        console.log(`🎯 HLS timeline clicked: seeking to ${formatTime(seekTime)}`);
      });
      
      // Timeline hover for time preview
      timeline.addEventListener('mousemove', function(e) {
        if (!hlsVideo.duration) return;
        
        const rect = timeline.getBoundingClientRect();
        const hoverX = e.clientX - rect.left;
        const timelineWidth = rect.width;
        
        const maxSeekTime = hlsVideo.duration;
        const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
        const seekRange = maxSeekTime - minSeekTime;
        
        const hoverProgress = hoverX / timelineWidth;
        const hoverTime = minSeekTime + (hoverProgress * seekRange);
        
        // Show time tooltip
        if (thumbnailPreview && thumbnailTime) {
          thumbnailTime.textContent = formatTime(hoverTime);
          thumbnailPreview.style.left = hoverX + 'px';
          thumbnailPreview.style.display = 'block';
        }
      });
      
      timeline.addEventListener('mouseleave', function() {
        if (thumbnailPreview) {
          thumbnailPreview.style.display = 'none';
        }
      });
    }
    
    // ===== TIMELINE DISPLAY UPDATE =====
    function updateTimelineDisplay() {
      if (!hlsVideo || !scrubber || !timeline) return;
      
      const currentTime = hlsVideo.currentTime;
      const duration = hlsVideo.duration;
      
      if (duration > 0) {
        // For HLS, show progress within the rewind buffer
        const maxTime = duration;
        const minTime = Math.max(0, duration - rewindBuffer);
        const seekableRange = maxTime - minTime;
        
        if (seekableRange > 0) {
          const progress = Math.max(0, Math.min(1, (currentTime - minTime) / seekableRange));
          scrubber.style.left = (progress * 100) + '%';
          
          // Update timeline track if it exists
          const timelineTrack = timeline.querySelector('.timeline-track');
          if (timelineTrack) {
            timelineTrack.style.width = (progress * 100) + '%';
          }
        }
      }
    }
    
    // ===== HLS STREAM STATUS HANDLER =====
    function handleHLSStreamStatusUpdate(data) {
      console.log('🎬 HLS stream status update:', data);
      
      if (data.status === 'live') {
        console.log('🔴 Stream is now LIVE');
        
        // Hide waiting message
        hideStreamStatusOverlay();
        loading.style.display = 'none';
        
        // Initialize or restart HLS stream
        if (streamKey && hlsUrl) {
          if (hlsInstance) {
            console.log('🔄 Restarting existing HLS stream');
            hlsInstance.loadSource(hlsUrl);
          } else {
            console.log('🆕 Starting new HLS stream');
            initializeHLSStream({ streamKey: streamKey });
          }
        }
        
        isStreamActive = true;
        updateStreamTypeIndicator('🔴 LIVE - HLS Stream');
        
      } else if (data.status === 'offline') {
        console.log('⏹️ Stream is now OFFLINE');
        
        // Stop HLS stream
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        
        // Clear video
        if (hlsVideo) {
          hlsVideo.src = '';
          hlsVideo.load();
        }
        
        isStreamActive = false;
        showWaitingMessage();
        updateStreamTypeIndicator('⏸️ Stream Offline');
        
      } else if (data.status === 'paused') {
        console.log('⏸️ Stream is PAUSED');
        
        if (hlsVideo) {
          hlsVideo.pause();
        }
        
        updateStreamTypeIndicator('⏸️ Stream Paused');
      }
      
      // Handle stream URL changes
      if (data.streamUrl && data.streamUrl !== hlsUrl) {
        console.log('🔄 Stream URL changed:', data.streamUrl);
        hlsUrl = data.streamUrl;
        
        if (hlsInstance && isStreamActive) {
          hlsInstance.loadSource(hlsUrl);
        }
      }
    }
    
    // ===== SOCKET.IO INITIALIZATION =====
    function initializeSocket() {
      if (typeof io === 'undefined') {
        console.error('❌ Socket.IO not available');
        return;
      }
      
      socket = io();
      
      socket.on('connect', () => {
        console.log('🔌 Connected to server with socket ID:', socket.id);
        console.log('🔍 Current classId:', classId);
        if (classId) {
          // Join class as student - automatic streaming
          console.log('🔌 Emitting student-join-class for classId:', classId);
          socket.emit('student-join-class', { classId });
          console.log(`🎓 Joined class: ${classId}`);
          
          // Show waiting message initially
          showWaitingMessage();
        } else {
          console.error('❌ No classId available for joining room');
          showStreamStatusOverlay('No class ID provided');
        }
      });
      
      socket.on('disconnect', (reason) => {
        console.log('🔌 Disconnected from server:', reason);
        showStreamStatusOverlay('Connection lost - Reconnecting...');
        isStreamActive = false;
        
        // Clear any active timeouts
        clearPauseTimeout();
        
        // Show reconnection status
        setTimeout(() => {
          if (!socket.connected) {
            showStreamStatusOverlay('Reconnecting to server...');
          }
        }, 2000);
      });
      
      socket.on('connect_error', (error) => {
        console.error('❌ Socket.IO connection error:', error);
        showStreamStatusOverlay('Connection error - Please refresh page');
      });
      
      socket.on('reconnect', (attemptNumber) => {
        console.log('🔄 Reconnected to server after', attemptNumber, 'attempts');
        showNotification('Reconnected to server', 'success');
        
        // Rejoin the class room
        if (classId) {
          console.log('🔌 Rejoining class after reconnection:', classId);
          socket.emit('student-join-class', { classId });
          
          // Check current stream state
          setTimeout(() => {
            checkStreamState();
          }, 1000);
        }
      });
      
      socket.on('reconnect_error', (error) => {
        console.error('❌ Reconnection failed:', error);
        showStreamStatusOverlay('Reconnection failed - Please refresh page');
      });
      
      // Stream synchronization events
      socket.on('stream:init', (data) => {
        console.log('🎬 Stream initialized:', data);
        handleStreamInit(data);
        hideStreamStatusOverlay();
        isStreamActive = true;
      });
      
      socket.on('stream:play', (data) => {
        console.log('▶️ Instructor played video at:', data.time);
        handleInstructorPlay(data);
        hideStreamStatusOverlay();
        clearPauseTimeout();
        isStreamActive = true;
      });
      
      socket.on('stream:pause', (data) => {
        console.log('⏸️ Instructor paused video at:', data.time);
        handleInstructorPause(data);
        if (isStreamActive) {
          startPauseTimeout();
        }
      });
      
      socket.on('stream:seek', (data) => {
        console.log('⏭️ Instructor seeked to:', data.time);
        handleInstructorSeek(data);
      });
      
      socket.on('stream:time', (data) => {
        // Regular time updates from instructor
        instructorTime = data.time;
        instructorPlaying = data.playing;
        lastSyncTime = Date.now();
        
        // Calculate how far behind live we are
        const video = document.getElementById('video');
        if (video && video.currentTime) {
          behindLiveSeconds = Math.max(0, instructorTime - video.currentTime);
          isLiveSynced = behindLiveSeconds < 3;
        }
        
        updateLiveStatus();
        
        // Update timeline live edge
        if (window.enhancedTimeline) {
          window.enhancedTimeline.render();
        }
        
        // Auto-sync if too far behind (more than 5 seconds)
        if (behindLiveSeconds > 5 && video && video.src) {
          console.log(`🔄 Auto-syncing: ${behindLiveSeconds}s behind`);
          video.currentTime = instructorTime;
        }
      });
      // Note: Removed duplicate stream:play and stream:pause handlers
      // The main handlers are defined above in the "Stream synchronization events" section
      
      
      // Stream status updates
      socket.on('streamStatus', (data) => {
        console.log('📡 Stream status update received:', data);
        handleHLSStreamStatusUpdate(data);
      });
      
      // Test event to verify Socket.IO is working
      socket.on('test-event', (data) => {
        console.log('🧪 Test event received:', data);
      });
      
      // Listen for any events (debugging) - only in development
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        socket.onAny((eventName, ...args) => {
          console.log('📨 Socket.IO event received:', eventName, args);
        });
      }
      
      // Handle current stream state for late joiners
      socket.on('stream:current-state', (data) => {
        console.log('📥 Received current stream state:', data);
        handleCurrentStreamState(data);
      });
      
      socket.on('stream:no-state', (data) => {
        console.log('ℹ️ No active stream state available');
        showWaitingMessage();
      });
      
      // Handle viewer count updates
      socket.on('viewerCount', (data) => {
        console.log('👥 Viewer count update:', data.count);
        updateViewerCount(data.count);
      });
      
      socket.on('viewer:count', (data) => {
        console.log('👥 Viewer count update (alt):', data.count);
        updateViewerCount(data.count);
      });
      
      // Handle HLS Stream events
      socket.on('stream:started', (data) => {
        console.log('🔴 Stream started:', data);
        handleStreamStarted(data);
      });
      
      socket.on('stream:ended', (data) => {
        console.log('⏹️ Stream ended:', data);
        handleStreamEnded(data);
      });
      
      // Legacy WebRTC event handlers (for backward compatibility)
      socket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Legacy WebRTC event - converting to HLS:', data);
        handleStreamStarted(data);
      });
      
      socket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Legacy WebRTC event - converting to HLS:', data);
        handleStreamEnded(data);
      });
      
      // Handle connection status
      socket.on('stream:student-ready', (data) => {
        console.log('✅ Student ready confirmation:', data);
        showNotification('Connected to stream', 'success');
      });
      
      socket.on('error', (data) => {
        console.error('❌ Socket error:', data);
        showNotification(data.message || 'Connection error', 'error');
      });
    }
    
    // ===== STREAM SYNCHRONIZATION HANDLERS =====
    function handleStreamInit(data) {
      console.log('🎬 Handling stream initialization:', data);
      
      // Check if this is an HLS stream
      if (data.streamUrl && data.streamUrl.includes('.m3u8')) {
        console.log('📺 Setting up HLS stream:', data.streamUrl);
        
        // Initialize HLS stream
        const streamData = {
          classId: data.classId || getCurrentClassId(),
          streamUrl: data.streamUrl,
          type: 'hls'
        };
        
        initializeHLSStream(streamData);
        return;
      }
      
      // Legacy video stream handling (for backward compatibility)
      const video = document.getElementById('video');
      if (data.streamUrl && video) {
        console.log('📺 Setting up legacy video stream:', data.streamUrl);
        video.style.display = 'block';
        video.src = data.streamUrl;
        
        // Set up video event handlers
        video.addEventListener('loadeddata', () => {
          console.log('📺 Video loaded, syncing to instructor state');
          
          // Sync to instructor's current position
          if (data.currentTime) {
            video.currentTime = data.currentTime;
          }
          
          // Play if instructor is playing
          if (data.playing) {
            video.play().catch(e => {
              console.log('Autoplay prevented, showing play button:', e);
              showStreamStatusOverlay('Click to start watching');
            });
          }
          
          console.log('✅ Video synchronized with instructor');
        }, { once: true });
        
        video.addEventListener('error', (e) => {
          console.error('❌ Video loading error:', e);
          showStreamStatusOverlay('Error loading video stream');
        });
        
        video.load();
        console.log('🔄 Video loading started');
      }
      
      // Update stream state
      streamStartTime = new Date(data.startTime);
      instructorTime = data.currentTime || 0;
      instructorPlaying = data.playing || false;
      isStreamActive = true;
      
      updateStreamTypeIndicator('Live Stream');
      updateClockDisplay();
      
      console.log('✅ Stream initialization complete');
    }
    
    function handleInstructorPlay(data) {
      const hlsVideo = document.getElementById('hlsVideo');
      const video = document.getElementById('video');
      
      // Use HLS video if available, otherwise fall back to regular video
      const activeVideo = (hlsVideo && hlsVideo.style.display !== 'none') ? hlsVideo : video;
      
      instructorTime = data.time;
      instructorPlaying = true;
      
      // Sync video to instructor time (HLS streams support seeking within buffer)
      if (activeVideo && activeVideo.src) {
        // For HLS, only sync if within seekable range
        if (activeVideo === hlsVideo && hlsVideo.duration) {
          const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
          if (instructorTime >= minSeekTime && Math.abs(hlsVideo.currentTime - instructorTime) > 2) {
            console.log(`🔄 Syncing HLS video: ${hlsVideo.currentTime}s -> ${instructorTime}s`);
            hlsVideo.currentTime = instructorTime;
          }
        } else if (activeVideo === video) {
          // Legacy video sync
          if (Math.abs(video.currentTime - instructorTime) > 1) {
            console.log(`🔄 Syncing video: ${video.currentTime}s -> ${instructorTime}s`);
            video.currentTime = instructorTime;
          }
        }
        
        if (activeVideo.paused) {
          activeVideo.play().catch(e => console.log('Autoplay prevented:', e));
        }
      }
      
      updatePlayPauseButton(false); // Show pause button
      updateLiveStatus();
    }
    
    function handleInstructorPause(data) {
      const hlsVideo = document.getElementById('hlsVideo');
      const video = document.getElementById('video');
      
      // Use HLS video if available, otherwise fall back to regular video
      const activeVideo = (hlsVideo && hlsVideo.style.display !== 'none') ? hlsVideo : video;
      
      instructorTime = data.time;
      instructorPlaying = false;
      
      // Sync and pause video
      if (activeVideo && activeVideo.src) {
        console.log(`⏸️ Pausing and syncing video to: ${instructorTime}s`);
        
        // For HLS, only sync if within seekable range
        if (activeVideo === hlsVideo && hlsVideo.duration) {
          const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
          if (instructorTime >= minSeekTime) {
            hlsVideo.currentTime = instructorTime;
          }
        } else if (activeVideo === video) {
          video.currentTime = instructorTime;
        }
        
        activeVideo.pause();
      }
      
      updatePlayPauseButton(true); // Show play button
      updateLiveStatus();
    }
    
    function handleInstructorSeek(data) {
      const hlsVideo = document.getElementById('hlsVideo');
      const video = document.getElementById('video');
      
      // Use HLS video if available, otherwise fall back to regular video
      const activeVideo = (hlsVideo && hlsVideo.style.display !== 'none') ? hlsVideo : video;
      
      instructorTime = data.time;
      
      // Sync video to instructor seek position
      if (activeVideo && activeVideo.src) {
        console.log(`⏭️ Seeking video to: ${instructorTime}s`);
        
        // For HLS, only seek if within seekable range
        if (activeVideo === hlsVideo && hlsVideo.duration) {
          const minSeekTime = Math.max(0, hlsVideo.duration - rewindBuffer);
          if (instructorTime >= minSeekTime) {
            hlsVideo.currentTime = instructorTime;
          }
        } else if (activeVideo === video) {
          video.currentTime = instructorTime;
        }
      }
      
      updateLiveStatus();
    }
    
    function handleStreamStatusUpdate(data) {
      console.log('🎬 handleStreamStatusUpdate called with:', data);
      
    const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
      const streamStatusText = document.getElementById('streamStatusText');
      
      if (data.status === 'live') {
        console.log('✅ Stream is now live');
        
        if (data.streamUrl) {
          console.log('📺 Switching to uploaded video stream:', data.streamUrl);
          
          // Switch to uploaded video stream
          if (webrtcVideo) {
            webrtcVideo.style.display = 'none';
            console.log('🔄 Hidden WebRTC video');
          }
          
          if (video) {
            video.style.display = 'block';
            video.src = data.streamUrl;
            video.load();
            console.log('🔄 Set video source and loaded:', data.streamUrl);
            
            // Update stream state
            isStreamActive = true;
            updateStreamTypeIndicator('Live Stream');
            hideStreamStatusOverlay();
            
            // Auto-play when loaded
            video.addEventListener('loadeddata', () => {
              console.log('📺 Video loaded, ready to sync with instructor');
              video.play().catch(e => {
                console.log('Autoplay prevented, waiting for user interaction:', e);
                showStreamStatusOverlay('Click to start watching');
              });
            }, { once: true });
          }
        } else {
          console.log('📡 Live stream without specific URL - waiting for WebRTC or stream init');
          showStreamStatusOverlay('Instructor is starting stream...');
        }
      } else if (data.status === 'offline') {
        console.log('⏹️ Stream is now offline');
        isStreamActive = false;
        
        if (video) {
          video.pause();
          video.src = '';
        }
        if (webrtcVideo) {
          webrtcVideo.style.display = 'none';
        }
        
        showStreamStatusOverlay('Stream ended');
        updateStreamTypeIndicator('Offline');
      } else if (data.status === 'paused') {
        console.log('⏸️ Stream is paused');
        if (video) {
          video.pause();
        }
        showStreamStatusOverlay('Stream paused by instructor');
      } else {
        console.log('❓ Unknown stream status:', data.status);
      }
    }
    
    // ===== HLS STREAM SOCKET HANDLERS =====
    function handleStreamStarted(data) {
      console.log('🔴 HLS stream started:', data);
      
      // Extract class ID from the data or current context
      const classId = data.classId || getCurrentClassId();
      if (!classId) {
        console.error('❌ No class ID available for stream');
        return;
      }
      
      // Initialize HLS stream with class-based URL
      const streamData = {
        classId: classId,
        streamUrl: `http://198.211.107.134/hls/${classId}.m3u8`,
        type: 'hls'
      };
      
      initializeHLSStream(streamData);
      showStreamStatusOverlay('🔴 Live Stream Started');
      
      // Hide status overlay after stream starts
      setTimeout(() => {
        hideStreamStatusOverlay();
      }, 2000);
    }
    
    function handleStreamEnded(data) {
      console.log('⏹️ HLS stream ended:', data);
      
      // Stop HLS instance
      if (hlsInstance) {
        hlsInstance.destroy();
        hlsInstance = null;
      }
      
      // Hide video and show status
      const hlsVideo = document.getElementById('hlsVideo');
      if (hlsVideo) {
        hlsVideo.style.display = 'none';
        hlsVideo.src = '';
      }
      
      // Hide stream controls
      hideStreamControls();
      
      // Update status
      isStreamActive = false;
      updateStreamTypeIndicator('Stream Ended');
      showStreamStatusOverlay('Stream has ended');
    }
    
    function getCurrentClassId() {
      // Try to get class ID from URL parameters or localStorage
      const urlParams = new URLSearchParams(window.location.search);
      return urlParams.get('classId') || localStorage.getItem('currentClassId');
    }
    
    function updateViewerCount(count) {
      // Update viewer count display if element exists
      const viewerCountEl = document.getElementById('viewerCount');
      if (viewerCountEl) {
        viewerCountEl.textContent = count;
      }
      
      // Log for debugging
      console.log('👥 Current viewers:', count);
    }
    
    function updateStreamTypeIndicator(type) {
      // Update stream type indicator if element exists
      const streamTypeEl = document.getElementById('streamType');
      if (streamTypeEl) {
        streamTypeEl.textContent = type;
      }
      
      // Update document title to reflect stream status
      if (type === 'Offline') {
        document.title = 'SMX Stream - Offline';
      } else {
        document.title = `SMX Stream - ${type}`;
      }
      
      console.log('📡 Stream type updated:', type);
    }
    
    // ===== VIDEO ERROR HANDLING =====
    function handleVideoError(videoElement, type) {
      console.error(`❌ Video error (${type}):`, videoElement.error);
      
      const errorCode = videoElement.error ? videoElement.error.code : 'unknown';
      const errorMessage = getVideoErrorMessage(errorCode);
      
      showStreamStatusOverlay(`Video Error: ${errorMessage}`);
      
      // Try to recover after a delay
      setTimeout(() => {
        if (type === 'main' && videoElement.src) {
          console.log('🔄 Attempting to reload main video...');
          videoElement.load();
        }
      }, 3000);
    }
    
    function handleVideoLoadStart(videoElement, type) {
      console.log(`📺 Video loading started (${type})`);
      if (type === 'main') {
        showStreamStatusOverlay('Loading video stream...');
      }
    }
    
    function handleVideoCanPlay(videoElement, type) {
      console.log(`📺 Video can play (${type})`);
      if (type === 'main') {
        hideStreamStatusOverlay();
      }
    }
    
    function getVideoErrorMessage(errorCode) {
      switch (errorCode) {
        case 1: return 'Video loading aborted';
        case 2: return 'Network error while loading video';
        case 3: return 'Video decoding error';
        case 4: return 'Video format not supported';
        default: return 'Unknown video error';
      }
    }
    
    // ===== STREAM STATUS OVERLAY HELPERS =====
    function showStreamStatusOverlay(message) {
      const overlay = document.getElementById('streamStatusText');
      if (overlay) {
        overlay.textContent = message;
        overlay.classList.remove('hidden');
        console.log('📺 Showing stream status:', message);
      }
    }
    
    function hideStreamStatusOverlay() {
      const overlay = document.getElementById('streamStatusText');
      if (overlay) {
        overlay.classList.add('hidden');
        console.log('📺 Hiding stream status overlay');
      }
    }
    
    function updateStreamTypeIndicator(type) {
      const indicator = document.getElementById('streamTypeIndicator');
      if (indicator) {
        indicator.textContent = type;
        console.log('📡 Updated stream type indicator:', type);
      }
    }
    
    function showWaitingMessage() {
      showStreamStatusOverlay('Waiting for instructor to start stream...');
      updateStreamTypeIndicator('Waiting');
    }
    
    function hideWaitingMessage() {
      hideStreamStatusOverlay();
    }
    
    function handleCurrentStreamState(data) {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Set up the video source
      if (data.streamUrl) {
        if (webrtcVideo) webrtcVideo.style.display = 'none';
        video.style.display = 'block';
        video.src = data.streamUrl;
        
        video.addEventListener('loadeddata', () => {
          // Sync to instructor's current position
          const currentTime = data.currentTime + (data.timeSinceStart / 1000);
          video.currentTime = Math.max(0, currentTime);
          
          // Play if instructor is playing
          if (data.playing) {
            video.play().catch(e => console.log('Autoplay prevented:', e));
          }
          
          // Update state variables
          instructorTime = currentTime;
          instructorPlaying = data.playing;
          streamStartTime = new Date(data.startTime);
          
          updateLiveStatus();
          updateStreamTypeIndicator('Live Stream (Joined)');
          
          console.log('✅ Synced to current stream state');
        }, { once: true });
        
        video.load();
      }
    }
    
    // ===== TIMELINE ENFORCEMENT FOR STUDENTS =====
    function enforceTimelineRestrictions() {
      const video = document.getElementById('video');
      const timeline = document.getElementById('timeline');
      
      // Prevent seeking ahead of instructor (LIVE EDGE ENFORCEMENT)
      video.addEventListener('seeking', (e) => {
        if (!isInstructor) {
          if (video.currentTime > instructorTime) {
            console.log('🚫 Cannot seek ahead of instructor');
            video.currentTime = instructorTime;
            showNotification('Cannot seek ahead of live stream', 'warning');
          }
        }
      });
      
      // Prevent fast-forwarding beyond instructor time (LIVE EDGE ENFORCEMENT)
      video.addEventListener('timeupdate', (e) => {
        if (!isInstructor) {
          // Enforce live edge lock - students cannot watch past instructor time
          if (video.currentTime > instructorTime + 0.25) {
            console.log('🚫 Live edge enforced: snapping back to instructor time');
            video.currentTime = instructorTime;
          }
        }
      });
      
      // Enforce timeline scrubbing restrictions
      if (timeline) {
        timeline.addEventListener('click', (e) => {
          const timelineRect = timeline.getBoundingClientRect();
          const clickX = e.clientX - timelineRect.left;
          const timelineWidth = timelineRect.width;
          const clickProgress = clickX / timelineWidth;
          const clickTime = clickProgress * video.duration;
          
          if (!isInstructor && clickTime > instructorTime) {
            e.preventDefault();
            e.stopPropagation();
            showNotification('Cannot scrub ahead of live stream', 'warning');
            return false;
          }
        }, true);
      }
    }
    
    // ===== USER ROLE DETECTION =====
    function detectUserRole() {
      // Check if user is instructor based on token or URL params
      const token = localStorage.getItem('token');
      if (token) {
        try {
          const payload = JSON.parse(atob(token.split('.')[1]));
          isInstructor = payload.role === 'instructor' || payload.role === 'admin';
          console.log('👤 User role detected:', isInstructor ? 'Instructor' : 'Student');
        } catch (e) {
          console.log('⚠️ Could not decode token, assuming student role');
          isInstructor = false;
        }
      } else {
        isInstructor = false;
      }
    }
    
    // ===== DEBUG SYSTEM =====
    let debugPanelVisible = false;
    let debugUpdateInterval = null;
    
    function toggleDebugPanel() {
      const panel = document.getElementById('debugPanel');
      const toggle = document.getElementById('debugToggle');
      
      debugPanelVisible = !debugPanelVisible;
      
      if (debugPanelVisible) {
        panel.style.display = 'block';
        toggle.style.display = 'none';
        startDebugUpdates();
      } else {
        panel.style.display = 'none';
        toggle.style.display = 'block';
        stopDebugUpdates();
      }
    }
    
    function startDebugUpdates() {
      updateDebugInfo();
      debugUpdateInterval = setInterval(updateDebugInfo, 1000);
    }
    
    function stopDebugUpdates() {
      if (debugUpdateInterval) {
        clearInterval(debugUpdateInterval);
        debugUpdateInterval = null;
      }
    }
    
    function updateDebugInfo() {
      const debugInfo = document.getElementById('debugInfo');
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      const info = {
        'Socket Connected': socket?.connected ? '✅ Yes' : '❌ No',
        'Socket ID': socket?.id || 'N/A',
        'Class ID': classId || 'N/A',
        'Stream Active': isStreamActive ? '✅ Yes' : '❌ No',
        'Video Element': video ? '✅ Present' : '❌ Missing',
        'Video Source': video?.src ? '✅ Set' : '❌ Empty',
        'Video Ready State': video ? video.readyState : 'N/A',
        'Video Current Time': video ? video.currentTime.toFixed(2) + 's' : 'N/A',
        'Video Paused': video ? (video.paused ? '⏸️ Yes' : '▶️ No') : 'N/A',
        'Instructor Time': instructorTime.toFixed(2) + 's',
        'Instructor Playing': instructorPlaying ? '▶️ Yes' : '⏸️ No',
        'Stream Start Time': streamStartTime ? streamStartTime.toLocaleTimeString() : 'N/A',
        'Live Synced': isLiveSynced ? '✅ Yes' : '⚠️ No',
        'Behind Live': behindLiveSeconds + 's',
        'WebRTC Video': webrtcVideo?.style.display !== 'none' ? '📹 Visible' : '🔇 Hidden'
      };
      
      debugInfo.innerHTML = Object.entries(info)
        .map(([key, value]) => `<div style="margin: 2px 0;"><strong>${key}:</strong> ${value}</div>`)
        .join('');
    }
    
    // Make debug functions global
    window.toggleDebugPanel = toggleDebugPanel;
    
    // ===== LIVE EDGE ENFORCEMENT INITIALIZATION =====
    function initializeLiveEdgeEnforcement() {
      console.log('🔒 Initializing live edge enforcement for student');
      
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Apply enforcement to both video elements
      [video, webrtcVideo].forEach(videoElement => {
        if (videoElement) {
          // Prevent playback past live edge
          videoElement.addEventListener('timeupdate', () => {
            if (videoElement.currentTime > instructorTime + 0.25) {
              console.log('🚫 Live edge enforced: snapping back to instructor time');
              videoElement.currentTime = instructorTime;
            }
          });
          
          // Prevent seeking past live edge
          videoElement.addEventListener('seeking', () => {
            if (videoElement.currentTime > instructorTime) {
              console.log('🚫 Cannot seek ahead of instructor');
              videoElement.currentTime = instructorTime;
              showNotification('Cannot seek ahead of live stream', 'warning');
            }
          });
        }
      });
      
      // Enforce timeline scrubbing restrictions
      const timeline = document.getElementById('timeline');
      if (timeline) {
        timeline.addEventListener('click', (e) => {
          const timelineRect = timeline.getBoundingClientRect();
          const clickX = e.clientX - timelineRect.left;
          const timelineWidth = timelineRect.width;
          const clickProgress = clickX / timelineWidth;
          const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
          
          if (activeVideo && activeVideo.duration) {
            const clickTime = clickProgress * activeVideo.duration;
            
            if (clickTime > instructorTime) {
              e.preventDefault();
              e.stopPropagation();
              showNotification('Cannot scrub ahead of live stream', 'warning');
              return false;
            }
          }
        }, true);
      }
      
      console.log('✅ Live edge enforcement initialized');
    }
    
    // ===== STREAM RECOVERY FOR LATE JOINERS =====
    async function recoverStreamState() {
      if (!classId) return;
      
      try {
        console.log('🔄 Recovering stream state for late joiner...');
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/state/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.success && data.state) {
            console.log('✅ Stream state recovered:', data.state);
            
            // Update instructor time
            instructorTime = data.state.currentLiveTime || data.state.currentTime;
            instructorPlaying = data.state.playing;
            
            // Load video if available
            if (data.state.streamUrl) {
              const video = document.getElementById('video');
              if (video) {
                video.src = data.state.streamUrl;
                
                video.addEventListener('loadeddata', () => {
                  // Sync to current live time
                  video.currentTime = instructorTime;
                  
                  if (instructorPlaying) {
                    video.play().catch(e => {
                      console.log('Autoplay prevented, user interaction required');
                      showNotification('Click to resume live stream', 'info');
                    });
                  }
                }, { once: true });
                
                video.load();
              }
            }
          } else {
            console.log('📭 No active stream to recover');
          }
        }
      } catch (error) {
        console.error('❌ Failed to recover stream state:', error);
      }
    }
    
    // ===== ENHANCED CANVAS TIMELINE IMPLEMENTATION =====
    class EnhancedTimeline {
      constructor(canvasId, videoId) {
        this.canvas = document.getElementById(canvasId);
        this.video = document.getElementById(videoId);
        this.ctx = this.canvas.getContext('2d');
        
        if (!this.canvas || !this.video) {
          console.error('❌ Timeline canvas or video element not found');
          return;
        }
        
        this.setupCanvas();
        this.setupEventListeners();
        this.startRenderLoop();
        
        console.log('✅ Enhanced Timeline initialized');
      }
      
      setupCanvas() {
        // Set canvas size to match container
        const container = this.canvas.parentElement;
        const rect = container.getBoundingClientRect();
        
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
        
        // Store references globally
        timelineCanvas = this.canvas;
        timelineCtx = this.ctx;
      }
      
      setupEventListeners() {
        // Mouse wheel for zooming
        this.canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          this.handleZoom(e);
        });
        
        // Mouse events for panning and clicking
        this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));
        this.canvas.addEventListener('mouseleave', (e) => this.handleMouseLeave(e));
        
        // Video events
        this.video.addEventListener('loadedmetadata', () => this.render());
        this.video.addEventListener('timeupdate', () => this.render());
        
        // Window resize
        window.addEventListener('resize', () => {
          this.setupCanvas();
          this.render();
        });
      }
      
      handleZoom(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseTimeRatio = mouseX / rect.width;
        const mouseTime = viewportStart + (mouseTimeRatio * visibleDuration);
        
        // Zoom in/out
        const zoomFactor = e.deltaY > 0 ? 1.2 : 0.8;
        const newVisibleDuration = Math.max(5, Math.min(this.video.duration || 300, visibleDuration * zoomFactor));
        
        // Adjust viewport to keep mouse position stable
        const newViewportStart = mouseTime - (mouseTimeRatio * newVisibleDuration);
        
        visibleDuration = newVisibleDuration;
        viewportStart = Math.max(0, Math.min(this.video.duration - visibleDuration, newViewportStart));
        zoomLevel = 30 / visibleDuration; // Normalize zoom level
        
        this.render();
      }
      
      handleMouseDown(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        if (e.shiftKey) {
          // Start panning
          isDragging = true;
          dragStartX = mouseX;
          dragStartViewport = viewportStart;
          this.canvas.style.cursor = 'grabbing';
        } else {
          // Jump to time (if allowed)
          this.jumpToTime(mouseX);
        }
      }
      
      handleMouseMove(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        
        if (isDragging) {
          // Pan timeline
          const deltaX = mouseX - dragStartX;
          const deltaTime = -(deltaX / rect.width) * visibleDuration;
          const newViewportStart = dragStartViewport + deltaTime;
          
          viewportStart = Math.max(0, Math.min(this.video.duration - visibleDuration, newViewportStart));
          this.render();
        } else {
          // Show tooltip
          this.showTooltip(mouseX);
        }
      }
      
      handleMouseUp(e) {
        isDragging = false;
        this.canvas.style.cursor = 'pointer';
      }
      
      handleMouseLeave(e) {
        isDragging = false;
        tooltipVisible = false;
        this.canvas.style.cursor = 'pointer';
        this.render();
      }
      
      jumpToTime(mouseX) {
        const rect = this.canvas.getBoundingClientRect();
        const timeRatio = mouseX / rect.width;
        const targetTime = viewportStart + (timeRatio * visibleDuration);
        
        // Apply live edge enforcement for students
        if (!isInstructor && targetTime > instructorTime) {
          showNotification('Cannot jump ahead of live stream', 'warning');
          return;
        }
        
        if (this.video && targetTime >= 0 && targetTime <= this.video.duration) {
          this.video.currentTime = targetTime;
          console.log(`⏭️ Jumped to time: ${targetTime.toFixed(2)}s`);
        }
      }
      
      showTooltip(mouseX) {
        const rect = this.canvas.getBoundingClientRect();
        const timeRatio = mouseX / rect.width;
        const time = viewportStart + (timeRatio * visibleDuration);
        
        tooltipVisible = true;
        tooltipX = mouseX;
        tooltipTime = time;
        this.render();
      }
      
      startRenderLoop() {
        // Render at 30fps when active
        setInterval(() => {
          if (this.video && !this.video.paused) {
            this.render();
          }
        }, 33);
      }
      
      render() {
        if (!this.ctx || !this.video) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Clear canvas
        this.ctx.clearRect(0, 0, width, height);
        
        // Draw background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        this.ctx.fillRect(0, 0, width, height);
        
        // Draw timeline components
        this.drawTicks();
        this.drawThumbnails();
        this.drawPlayhead();
        this.drawLiveEdge();
        this.drawTooltip();
      }
      
      drawTicks() {
        if (!this.video.duration) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        // Calculate tick intervals based on zoom
        let majorInterval, minorInterval;
        if (visibleDuration <= 10) {
          majorInterval = 1; minorInterval = 0.2;
        } else if (visibleDuration <= 30) {
          majorInterval = 5; minorInterval = 1;
        } else if (visibleDuration <= 120) {
          majorInterval = 10; minorInterval = 2;
        } else {
          majorInterval = 30; minorInterval = 5;
        }
        
        const viewportEnd = viewportStart + visibleDuration;
        
        // Draw minor ticks
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 1;
        
        for (let time = Math.floor(viewportStart / minorInterval) * minorInterval; time <= viewportEnd; time += minorInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          const tickHeight = height * 0.2;
          
          this.ctx.beginPath();
          this.ctx.moveTo(x, height - tickHeight);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
        }
        
        // Draw major ticks with labels
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        this.ctx.font = '10px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.lineWidth = 2;
        
        for (let time = Math.floor(viewportStart / majorInterval) * majorInterval; time <= viewportEnd; time += majorInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          const tickHeight = height * 0.4;
          
          // Draw tick
          this.ctx.beginPath();
          this.ctx.moveTo(x, height - tickHeight);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
          
          // Draw label
          const minutes = Math.floor(time / 60);
          const seconds = Math.floor(time % 60);
          const label = `${minutes}:${seconds.toString().padStart(2, '0')}`;
          
          this.ctx.fillText(label, x, height - tickHeight - 5);
        }
      }
      
      drawThumbnails() {
        if (!this.video.duration) return;
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        const thumbnailHeight = height * 0.6;
        const thumbnailWidth = thumbnailHeight * (16/9); // Assume 16:9 aspect ratio
        
        // Calculate thumbnail interval based on zoom
        let thumbnailInterval;
        if (visibleDuration <= 30) {
          thumbnailInterval = 5;
        } else if (visibleDuration <= 120) {
          thumbnailInterval = 10;
        } else {
          thumbnailInterval = 30;
        }
        
        const viewportEnd = viewportStart + visibleDuration;
        
        for (let time = Math.floor(viewportStart / thumbnailInterval) * thumbnailInterval; time <= viewportEnd; time += thumbnailInterval) {
          if (time < 0 || time > this.video.duration) continue;
          
          const x = ((time - viewportStart) / visibleDuration) * width;
          
          // Get or create thumbnail
          const thumbnail = this.getThumbnail(time);
          if (thumbnail) {
            const thumbX = x - thumbnailWidth / 2;
            const thumbY = 5;
            
            this.ctx.drawImage(thumbnail, thumbX, thumbY, thumbnailWidth, thumbnailHeight);
            
            // Draw border
            this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(thumbX, thumbY, thumbnailWidth, thumbnailHeight);
          }
        }
      }
      
      getThumbnail(time) {
        const key = Math.floor(time);
        
        if (thumbnailCache.has(key)) {
          return thumbnailCache.get(key);
        }
        
        // Create thumbnail asynchronously
        this.createThumbnail(time, key);
        return null;
      }
      
      async createThumbnail(time, key) {
        if (!this.video.videoWidth || !this.video.videoHeight) return;
        
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = 160;
        canvas.height = 90;
        
        // Temporarily seek to capture frame
        const originalTime = this.video.currentTime;
        this.video.currentTime = time;
        
        await new Promise(resolve => {
          const onSeeked = () => {
            ctx.drawImage(this.video, 0, 0, canvas.width, canvas.height);
            thumbnailCache.set(key, canvas);
            this.video.removeEventListener('seeked', onSeeked);
            this.video.currentTime = originalTime;
            resolve();
          };
          this.video.addEventListener('seeked', onSeeked);
        });
      }
      
      drawPlayhead() {
        if (!this.video.duration) return;
        
        const currentTime = this.video.currentTime;
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        if (currentTime >= viewportStart && currentTime <= viewportStart + visibleDuration) {
          const x = ((currentTime - viewportStart) / visibleDuration) * width;
          
          // Draw playhead line
          this.ctx.strokeStyle = '#ff4757';
          this.ctx.lineWidth = 3;
          this.ctx.beginPath();
          this.ctx.moveTo(x, 0);
          this.ctx.lineTo(x, height);
          this.ctx.stroke();
          
          // Draw playhead indicator
          this.ctx.fillStyle = '#ff4757';
          this.ctx.beginPath();
          this.ctx.arc(x, 10, 6, 0, Math.PI * 2);
          this.ctx.fill();
        }
      }
      
      drawLiveEdge() {
        if (!isInstructor && instructorTime > 0) {
          const width = this.canvas.width;
          const height = this.canvas.height;
          
          if (instructorTime >= viewportStart && instructorTime <= viewportStart + visibleDuration) {
            const x = ((instructorTime - viewportStart) / visibleDuration) * width;
            
            // Draw live edge line
            this.ctx.strokeStyle = '#22c55e';
            this.ctx.lineWidth = 2;
            this.ctx.setLineDash([5, 5]);
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, height);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            
            // Draw "LIVE" label
            this.ctx.fillStyle = '#22c55e';
            this.ctx.font = 'bold 10px sans-serif';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('LIVE', x, height - 5);
          }
        }
      }
      
      drawTooltip() {
        if (!tooltipVisible) return;
        
        const minutes = Math.floor(tooltipTime / 60);
        const seconds = Math.floor(tooltipTime % 60);
        const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Draw tooltip background
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.fillRect(tooltipX - 25, 5, 50, 20);
        
        // Draw tooltip text
        this.ctx.fillStyle = 'white';
        this.ctx.font = '12px monospace';
        this.ctx.textAlign = 'center';
        this.ctx.fillText(timeText, tooltipX, 18);
      }
    }
    
    // ===== TIMELINE UTILITY FUNCTIONS =====
    function updateTimelineViewport() {
      if (!window.enhancedTimeline || !window.enhancedTimeline.video) return;
      
      const video = window.enhancedTimeline.video;
      const currentTime = video.currentTime;
      
      // Auto-follow playhead if it goes outside viewport
      if (currentTime < viewportStart || currentTime > viewportStart + visibleDuration) {
        viewportStart = Math.max(0, currentTime - visibleDuration / 2);
        if (window.enhancedTimeline) {
          window.enhancedTimeline.render();
        }
      }
    }
    
    function resetTimelineZoom() {
      visibleDuration = 30;
      viewportStart = 0;
      zoomLevel = 1;
      if (window.enhancedTimeline) {
        window.enhancedTimeline.render();
      }
    }
    
    function centerTimelineOnTime(time) {
      if (!window.enhancedTimeline || !window.enhancedTimeline.video) return;
      
      viewportStart = Math.max(0, Math.min(
        window.enhancedTimeline.video.duration - visibleDuration,
        time - visibleDuration / 2
      ));
      
      if (window.enhancedTimeline) {
        window.enhancedTimeline.render();
      }
    }
    
    // ===== TIMELINE VIDEO SOURCE SWITCHING =====
    function switchTimelineVideoSource(videoId) {
      if (window.enhancedTimeline) {
        const newVideo = document.getElementById(videoId);
        if (newVideo) {
          window.enhancedTimeline.video = newVideo;
          
          // Clear thumbnail cache when switching sources
          thumbnailCache.clear();
          
          // Reset timeline view
          resetTimelineZoom();
          
          console.log(`🔄 Timeline switched to video source: ${videoId}`);
        }
      }
    }
    
    // ===== STREAM STATUS OVERLAY MANAGEMENT =====
    let streamStatusOverlay = null;
    let pauseTimeout = null;
    let isStreamActive = false;
    
    function initializeStreamStatusOverlay() {
      streamStatusOverlay = document.getElementById('streamStatusText');
      
      if (!streamStatusOverlay) {
        console.error('❌ Stream status overlay not found');
        return;
      }
      
      console.log('✅ Stream status overlay initialized');
      
      // Initially show the overlay
      showStreamStatusOverlay('Instructor Will Start Stream Soon');
      
      // Set up video event listeners
      setupStreamStatusListeners();
    }
    
    function setupStreamStatusListeners() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Regular video events
      if (video) {
        video.addEventListener('loadeddata', () => {
          console.log('📹 Video loaded - hiding status overlay');
          hideStreamStatusOverlay();
          isStreamActive = true;
        });
        
        video.addEventListener('play', () => {
          hideStreamStatusOverlay();
          clearPauseTimeout();
          isStreamActive = true;
        });
        
        video.addEventListener('pause', () => {
          if (isStreamActive) {
            startPauseTimeout();
          }
        });
        
        video.addEventListener('ended', () => {
          showStreamStatusOverlay('Stream has ended');
          isStreamActive = false;
        });
        
        video.addEventListener('error', () => {
          showStreamStatusOverlay('Stream connection error');
          isStreamActive = false;
        });
      }
      
      // WebRTC video events
      if (webrtcVideo) {
        webrtcVideo.addEventListener('loadeddata', () => {
          console.log('📹 WebRTC video loaded - hiding status overlay');
          hideStreamStatusOverlay();
          isStreamActive = true;
        });
        
        webrtcVideo.addEventListener('play', () => {
          hideStreamStatusOverlay();
          clearPauseTimeout();
          isStreamActive = true;
        });
        
        webrtcVideo.addEventListener('pause', () => {
          if (isStreamActive) {
            startPauseTimeout();
          }
        });
      }
    }
    
    function showStreamStatusOverlay(message, isPaused = false) {
      if (!streamStatusOverlay) return;
      
      streamStatusOverlay.textContent = message;
      streamStatusOverlay.classList.remove('hidden');
      
      if (isPaused) {
        streamStatusOverlay.classList.add('paused');
      } else {
        streamStatusOverlay.classList.remove('paused');
      }
      
      console.log('👁️ Stream status overlay shown:', message);
    }
    
    function hideStreamStatusOverlay() {
      if (!streamStatusOverlay) return;
      
      streamStatusOverlay.classList.add('hidden');
      streamStatusOverlay.classList.remove('paused');
      
      console.log('🙈 Stream status overlay hidden');
    }
    
    function startPauseTimeout() {
      clearPauseTimeout();
      
      // Show pause message after 10 seconds of being paused
      pauseTimeout = setTimeout(() => {
        if (isStreamActive) {
          showStreamStatusOverlay('🔴 Instructor has paused the stream', true);
          
          // Start checking for stream recovery every 5 seconds after 30 seconds
          setTimeout(() => {
            startStreamRecoveryCheck();
          }, 20000); // Additional 20 seconds = 30 total
        }
      }, 10000); // 10 seconds
    }
    
    function clearPauseTimeout() {
      if (pauseTimeout) {
        clearTimeout(pauseTimeout);
        pauseTimeout = null;
      }
      
      if (window.streamRecoveryInterval) {
        clearInterval(window.streamRecoveryInterval);
        window.streamRecoveryInterval = null;
      }
    }
    
    function startStreamRecoveryCheck() {
      if (window.streamRecoveryInterval) return; // Already running
      
      console.log('🔄 Starting stream recovery check...');
      window.streamRecoveryInterval = setInterval(async () => {
        console.log('🔄 Checking for stream recovery...');
        await checkStreamState();
        
        // If stream is active again, clear the recovery check
        if (isStreamActive) {
          console.log('✅ Stream recovered, stopping recovery check');
          clearInterval(window.streamRecoveryInterval);
          window.streamRecoveryInterval = null;
        }
      }, 5000);
    }
    
    // Check stream state from server
    async function checkStreamState() {
      if (!classId) return;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/state/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.success && data.state && data.state.streamUrl) {
            console.log('✅ Active stream detected from server');
            isStreamActive = true;
            hideStreamStatusOverlay();
          } else {
            console.log('📭 No active stream from server');
            isStreamActive = false;
            showStreamStatusOverlay('Instructor Will Start Stream Soon');
          }
        }
      } catch (error) {
        console.error('❌ Failed to check stream state:', error);
        showStreamStatusOverlay('Checking stream status...');
      }
    }
    
    // ===== SCREENSHOT FUNCTIONALITY =====
    function initializeScreenshotFeature() {
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      // Create hidden canvas for screenshots
      screenshotCanvas = document.createElement('canvas');
      screenshotContext = screenshotCanvas.getContext('2d');
      
      let mouseDownTime = 0;
      let isMouseDown = false;
      
      videoContainer.addEventListener('mousedown', (e) => {
        // Only trigger on areas outside the video controls
        if (e.target.closest('.video-controls-overlay') || 
            e.target.closest('.video-utility-controls') ||
            e.target.tagName === 'VIDEO') {
          return;
        }
        
        isMouseDown = true;
        mouseDownTime = Date.now();
        screenshotStartTime = mouseDownTime;
        
        // Add visual feedback
        videoContainer.style.cursor = 'crosshair';
        videoContainer.classList.add('screenshot-mode');
      });
      
      videoContainer.addEventListener('mouseup', (e) => {
        if (!isMouseDown) return;
        
        const holdDuration = Date.now() - mouseDownTime;
        isMouseDown = false;
        
        // Remove visual feedback
        videoContainer.style.cursor = '';
        videoContainer.classList.remove('screenshot-mode');
        
        // If held for at least 100ms, take screenshot
        if (holdDuration >= 100) {
          takeVideoScreenshot();
        }
      });
      
      videoContainer.addEventListener('mouseleave', (e) => {
        if (isMouseDown) {
          isMouseDown = false;
          videoContainer.style.cursor = '';
          videoContainer.classList.remove('screenshot-mode');
        }
      });
    }
    
    async function takeVideoScreenshot() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
      
      if (!activeVideo || activeVideo.videoWidth === 0) {
        showNotification('No video to capture', 'error');
        return;
      }
      
      try {
        // Set canvas dimensions to match video
        screenshotCanvas.width = activeVideo.videoWidth;
        screenshotCanvas.height = activeVideo.videoHeight;
        
        // Draw video frame to canvas
        screenshotContext.drawImage(activeVideo, 0, 0);
        
        // Add timestamp overlay
        const currentTime = formatTime(activeVideo.currentTime);
        const actualTime = streamStartTime ? 
          new Date(streamStartTime.getTime() + (activeVideo.currentTime * 1000)).toLocaleTimeString() : 
          new Date().toLocaleTimeString();
        
        // Add semi-transparent overlay for timestamp
        screenshotContext.fillStyle = 'rgba(0, 0, 0, 0.7)';
        screenshotContext.fillRect(10, 10, 200, 60);
        
        // Add timestamp text
        screenshotContext.fillStyle = 'white';
        screenshotContext.font = '16px Arial';
        screenshotContext.fillText(`Video: ${currentTime}`, 20, 35);
        screenshotContext.fillText(`Time: ${actualTime}`, 20, 55);
        
        // Convert to blob and copy to clipboard
        screenshotCanvas.toBlob(async (blob) => {
          try {
            await navigator.clipboard.write([
              new ClipboardItem({ 'image/png': blob })
            ]);
            
            showNotification('Screenshot copied to clipboard! 📸', 'success');
            
            // Auto-paste if possible (requires user gesture)
            setTimeout(() => {
              document.execCommand('paste');
            }, 100);
            
          } catch (error) {
            console.error('Failed to copy screenshot:', error);
            showNotification('Failed to copy screenshot', 'error');
          }
        }, 'image/png');
        
      } catch (error) {
        console.error('Screenshot error:', error);
        showNotification('Screenshot failed', 'error');
      }
    }
    
    // ===== LIVE STATUS AND CLOCK DISPLAY =====
    function updateLiveStatus() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
      
      if (activeVideo === video && video.src && instructorTime > 0) {
        const timeDiff = Math.abs(video.currentTime - instructorTime);
        behindLiveSeconds = Math.max(0, instructorTime - video.currentTime);
        isLive = timeDiff < 3; // Within 3 seconds is considered "live"
        isLiveSynced = behindLiveSeconds < 2;
      } else if (activeVideo === webrtcVideo) {
        // For WebRTC, assume we're always live
        isLive = true;
        isLiveSynced = true;
        behindLiveSeconds = 0;
      }
      
      updateClockDisplay();
      updateSyncStatus();
      updateTimelineRestrictions();
      updateBehindLiveIndicator();
    }
    
    function updateBehindLiveIndicator() {
      const indicator = document.getElementById('behindLiveIndicator');
      const secondsSpan = document.getElementById('behindLiveSeconds');
      
      if (!indicator || !secondsSpan) return;
      
      if (behindLiveSeconds > 5) {
        indicator.style.display = 'block';
        secondsSpan.textContent = Math.floor(behindLiveSeconds);
      } else {
        indicator.style.display = 'none';
      }
    }
    
    function updateTimelineRestrictions() {
      const timeline = document.getElementById('timeline');
      if (!timeline || !instructorTime) return;
      
      // Add visual indicator of allowed scrub area
      const container = timeline.querySelector('.timeline-container');
      if (!container) return;
      
      // Remove existing restriction overlay
      const existingOverlay = timeline.querySelector('.timeline-restriction-overlay');
      if (existingOverlay) existingOverlay.remove();
      
      // Create restriction overlay for areas beyond instructor time
      const video = document.getElementById('video');
      if (!video.duration) return;
      
      const restrictionOverlay = document.createElement('div');
      restrictionOverlay.className = 'timeline-restriction-overlay';
      
      const instructorProgress = instructorTime / video.duration;
      const restrictionStart = (instructorProgress * 100) + 2; // 2% buffer
      
      restrictionOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: ${restrictionStart}%;
        right: 0;
        height: 100%;
        background: linear-gradient(90deg, transparent 0%, rgba(229, 62, 62, 0.3) 20%, rgba(229, 62, 62, 0.5) 100%);
        pointer-events: none;
        z-index: 15;
        border-left: 2px solid rgba(229, 62, 62, 0.8);
      `;
      
      timeline.appendChild(restrictionOverlay);
    }
    
    function updateSyncStatus() {
      const syncStatus = document.getElementById('syncStatus');
      const syncStatusText = document.getElementById('syncStatusText');
      const jumpToLiveBtn = document.getElementById('jumpToLiveBtn');
      
      if (!syncStatus || !syncStatusText) return;
      
      syncStatus.style.display = 'flex';
      
      if (isLive) {
        syncStatus.className = 'sync-status live';
        syncStatusText.textContent = 'LIVE';
        if (jumpToLiveBtn) jumpToLiveBtn.style.display = 'none';
      } else {
        syncStatus.className = 'sync-status behind';
        syncStatusText.textContent = 'BEHIND';
        if (jumpToLiveBtn) jumpToLiveBtn.style.display = 'block';
      }
    }
    
    function updateClockDisplay() {
      const clockDisplay = document.getElementById('clockDisplay');
      if (!clockDisplay) return;
      
      const video = document.getElementById('video');
      const currentVideoTime = video.currentTime || 0;
      
      // Calculate actual time based on stream start time and video position
      let displayTime = '--:--:--';
      let liveStatus = '-';
      
      if (streamStartTime) {
        const actualTime = new Date(streamStartTime.getTime() + (currentVideoTime * 1000));
        displayTime = actualTime.toLocaleTimeString();
        liveStatus = isLive ? 'LIVE' : '-';
      }
      
      clockDisplay.innerHTML = `${displayTime} <span style="margin-left: 10px; font-weight: bold; color: ${isLive ? '#22c55e' : '#6b7280'}">${liveStatus}</span>`;
      
      // Update clock display styling based on live status
      clockDisplay.className = `clock-display ${isLive ? '' : 'not-live'}`;
      
      // Update timeline visual state
      updateTimelineVisualState();
    }
    
    function updateTimelineVisualState() {
      const timeline = document.getElementById('timeline');
      if (!timeline) return;
      
      const video = document.getElementById('video');
      if (!video.duration) return;
      
      // Update timeline progress indicators
      updateTimelineProgress();
      
      // Update time display
      updateTimeDisplay();
      
      // Generate dynamic tick marks
      updateTimelineTicks();
    }
    
    function updateTimelineProgress() {
      const timeline = document.getElementById('timeline');
      const video = document.getElementById('video');
      
      if (!timeline || !video.duration) return;
      
      // Remove existing progress indicators
      const existingProgress = timeline.querySelectorAll('.timeline-progress-indicator');
      existingProgress.forEach(el => el.remove());
      
      // Add student progress indicator
      const studentProgress = (video.currentTime / video.duration) * 100;
      const studentIndicator = document.createElement('div');
      studentIndicator.className = 'timeline-progress-indicator student-progress';
      studentIndicator.style.cssText = `
        position: absolute;
        top: 0;
        left: ${studentProgress}%;
        width: 2px;
        height: 100%;
        background: linear-gradient(180deg, #3b82f6 0%, #1d4ed8 100%);
        z-index: 18;
        box-shadow: 0 0 10px rgba(59, 130, 246, 0.6);
      `;
      timeline.appendChild(studentIndicator);
      
      // Add instructor progress indicator if different
      if (instructorTime && video.duration) {
        const instructorProgress = (instructorTime / video.duration) * 100;
        if (Math.abs(instructorProgress - studentProgress) > 1) {
          const instructorIndicator = document.createElement('div');
          instructorIndicator.className = 'timeline-progress-indicator instructor-progress';
          instructorIndicator.style.cssText = `
            position: absolute;
            top: 0;
            left: ${instructorProgress}%;
            width: 3px;
            height: 100%;
            background: linear-gradient(180deg, #22c55e 0%, #16a34a 100%);
            z-index: 19;
            box-shadow: 0 0 15px rgba(34, 197, 94, 0.8);
            border-radius: 1px;
          `;
          timeline.appendChild(instructorIndicator);
        }
      }
    }
    
    function updateTimeDisplay() {
      // Update or create time display
      let timeDisplay = document.getElementById('timelineTimeDisplay');
      if (!timeDisplay) {
        timeDisplay = document.createElement('div');
        timeDisplay.id = 'timelineTimeDisplay';
        timeDisplay.style.cssText = `
          position: absolute;
          bottom: -30px;
          left: 20px;
          color: var(--text-secondary);
          font-size: 12px;
          font-family: 'Courier New', monospace;
          background: rgba(0, 0, 0, 0.7);
          padding: 4px 8px;
          border-radius: 4px;
          backdrop-filter: blur(5px);
        `;
        document.getElementById('timeline').appendChild(timeDisplay);
      }
      
      const video = document.getElementById('video');
      const currentTime = formatTime(video.currentTime || 0);
      const duration = formatTime(video.duration || 0);
      const instructorTimeStr = formatTime(instructorTime || 0);
      
      timeDisplay.innerHTML = `
        Student: ${currentTime} / ${duration}<br>
        Instructor: ${instructorTimeStr} ${isLive ? '🔴 LIVE' : '⏸️'}
      `;
    }
    
    function updateTimelineTicks() {
      const timeline = document.getElementById('timeline');
      const video = document.getElementById('video');
      
      if (!timeline || !video.duration) return;
      
      // Remove existing ticks
      const existingTicks = timeline.querySelectorAll('.dynamic-time-tick');
      existingTicks.forEach(el => el.remove());
      
      // Add major ticks every 30 seconds, minor ticks every 10 seconds
      const duration = video.duration;
      const timelineWidth = timeline.offsetWidth;
      
      for (let time = 0; time <= duration; time += 10) {
        const isMajor = time % 30 === 0;
        const position = (time / duration) * 100;
        
        const tick = document.createElement('div');
        tick.className = `dynamic-time-tick ${isMajor ? 'major' : 'minor'}`;
        tick.style.cssText = `
          position: absolute;
          top: ${isMajor ? '0' : '10px'};
          left: ${position}%;
          width: 1px;
          height: ${isMajor ? '100%' : '50%'};
          background: ${isMajor ? 'rgba(255, 255, 255, 0.6)' : 'rgba(255, 255, 255, 0.3)'};
          z-index: 10;
          pointer-events: none;
        `;
        
        if (isMajor && time > 0) {
          const label = document.createElement('div');
          label.style.cssText = `
            position: absolute;
            top: -20px;
            left: -15px;
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            width: 30px;
            text-align: center;
            pointer-events: none;
          `;
          label.textContent = formatTime(time);
          tick.appendChild(label);
        }
        
        timeline.appendChild(tick);
      }
    }
    
    // ===== MODIFIED CONTROL FUNCTIONS =====
    function togglePlayPause() {
      // Students cannot control playback - it follows instructor
      showNotification('Playback is controlled by the instructor', 'warning');
    }
    
    function rewindVideo(seconds = 10) {
      // HLS rewind functionality - shift video currentTime as specified
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (!video || !video.duration) {
        console.warn('⚠️ No video available for rewind');
        return;
      }
      
      const newTime = Math.max(0, video.currentTime - seconds);
      video.currentTime = newTime;
      
      console.log(`⏪ Rewound ${seconds}s to ${newTime.toFixed(1)}s`);
      
      // Show rewind notification
      const timeLabel = seconds >= 60 ? Math.floor(seconds/60) + 'm' : seconds + 's';
      if (typeof showNotification === 'function') {
        showNotification(`Rewound ${timeLabel}`, 'info');
      }
        video.currentTime = newTime;
      } else {
        showNotification('Cannot rewind past instructor position', 'warning');
      }
    }
    
    function forwardVideo() {
      // Students cannot fast-forward ahead of instructor
      showNotification('Cannot skip ahead of instructor', 'warning');
    }
    
    // ===== STUDENT VIDEO EVENT HANDLERS =====
    function setupStudentVideoHandlers() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      // Prevent students from manually controlling video
      [video, webrtcVideo].forEach(vid => {
        if (!vid) return;
        
        vid.addEventListener('play', (e) => {
          if (!instructorPlaying) {
            console.log('🚫 Student tried to play - pausing');
            vid.pause();
            showNotification('Video playback is controlled by instructor', 'warning');
          }
        });
        
        vid.addEventListener('seeking', (e) => {
          if (vid.currentTime > instructorTime + 2) {
            console.log('🚫 Student tried to seek ahead - correcting');
            vid.currentTime = instructorTime;
            showNotification('Cannot seek ahead of instructor', 'warning');
          }
        });
      });
      
      console.log('✅ Student video event handlers set up');
    }
    
    function jumpToLive() {
      // Jump to the end of HLS buffer (live edge) as specified
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video && video.duration) {
        // Jump to end of buffer (live edge)
        video.currentTime = video.duration;
        console.log('🔴 Jumped to LIVE edge:', video.duration);
        
        // Show notification
        if (typeof showNotification === 'function') {
          showNotification('Jumped to LIVE', 'success');
        }
        showNotification('Jumped to LIVE', 'success');
      }
    }
    
    // ===== UTILITY FUNCTIONS =====
    function updatePlayPauseButton(showPlay) {
      const playPauseBtn = document.getElementById('playPauseBtn');
      if (playPauseBtn) {
        playPauseBtn.innerHTML = showPlay ? '▶' : '⏸';
      }
    }
    
    function showNotification(message, type = 'info') {
      // Create a simple notification
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 100px;
        right: 20px;
        background: ${type === 'warning' ? '#f59e0b' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 1000;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideIn 0.3s ease-out;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease-in forwards';
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
    
    // ===== INITIALIZATION =====
    function initializeStreamViewer() {
      // Get class ID from URL or localStorage
      const urlParams = new URLSearchParams(window.location.search);
      classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
      
      console.log('🔍 Class ID detection:', {
        fromURL: urlParams.get('classId'),
        fromStorage: localStorage.getItem('currentClassId'),
        final: classId,
        currentURL: window.location.href
      });
      
      if (!classId) {
        console.error('❌ No class ID available');
        showErrorMessage('Class Not Found', 'No class ID specified. Please access this page through your dashboard.');
        return;
      }
      
      console.log('📚 Initializing stream viewer for class:', classId);
      
      // Check for direct stream URL from Stream Mode (instructor upload)
      checkForDirectStreamUrl();
      
      // Initialize Socket.IO (only if no direct stream found)
      if (!checkForDirectStreamUrl()) {
        initializeSocket();
        
        // Fetch class info and stream status
        fetchClassInfo();
      }
      
      // Set up periodic check for stream updates from localStorage
      setInterval(checkForStreamUpdates, 2000);
      
      // Enforce timeline restrictions
      enforceTimelineRestrictions();
      
      // Start regular updates
      setInterval(updateLiveStatus, 1000);
      setInterval(updateClockDisplay, 1000);
      
      // Initialize screenshot feature
      initializeScreenshotFeature();
      
      // Set up student video event handlers
      setupStudentVideoHandlers();
    }
    
    // Check for direct stream URL from Stream Mode localStorage
    function checkForDirectStreamUrl() {
      const streamUrl = localStorage.getItem('currentStreamUrl');
      const streamType = localStorage.getItem('currentStreamType');
      
      if (streamUrl) {
        console.log('🎥 Found direct stream URL from Stream Mode:', streamUrl);
        console.log('📺 Stream type:', streamType);
        
        // Load the video directly
        const video = document.getElementById('video');
        if (video) {
          video.src = streamUrl;
          video.load();
          
          // Show success message
          showNotification('Stream Loaded', 'Video loaded from instructor upload', 'success');
          
          // Update UI to show loaded state
          updateStreamStatus('loaded', 'Video loaded and ready to play');
          
          // Auto-play if it's a live stream
          if (streamType === 'live') {
            video.play().catch(e => console.log('Auto-play prevented:', e));
          }
          
          return true; // Stream loaded successfully
        }
      }
      
      return false; // No direct stream found
    }
    
    // Update stream status display
    function updateStreamStatus(status, message) {
      const statusElement = document.querySelector('.stream-status');
      if (statusElement) {
        statusElement.textContent = message;
        statusElement.className = `stream-status ${status}`;
      }
      
      // Also update any connection status displays
      const connectionStatus = document.querySelector('.connection-status');
      if (connectionStatus) {
        connectionStatus.textContent = message;
        connectionStatus.style.color = status === 'loaded' ? '#10b981' : '#f59e0b';
      }
    }
    
    // Periodic check for stream updates from localStorage
    let currentStreamUrl = null;
    function checkForStreamUpdates() {
      const newStreamUrl = localStorage.getItem('currentStreamUrl');
      
      if (newStreamUrl && newStreamUrl !== currentStreamUrl) {
        console.log('🔄 Stream URL updated, reloading:', newStreamUrl);
        currentStreamUrl = newStreamUrl;
        
        const video = document.getElementById('video');
        if (video) {
          video.src = newStreamUrl;
          video.load();
          
          const streamType = localStorage.getItem('currentStreamType');
          showNotification('Stream Updated', 'New video loaded from instructor', 'info');
          
          // Auto-play if it's a live stream
          if (streamType === 'live') {
            video.play().catch(e => console.log('Auto-play prevented:', e));
          }
        }
      }
    }
    
    async function fetchClassInfo() {
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const data = await response.json();
          console.log('✅ Class info loaded:', data);
          
          // If socket is connected, join the class
          if (socket && socket.connected) {
            socket.emit('student-join-class', { classId });
          }
        } else {
          throw new Error(`Failed to fetch class info: ${response.status}`);
        }
      } catch (error) {
        console.error('❌ Error fetching class info:', error);
        showErrorMessage('Connection Error', 'Failed to connect to the class stream.');
      }
    }

    // Initialize WebRTC interface when page loads
    window.addEventListener('load', function() {
      // Detect user role first
      detectUserRole();
      
      showWelcomeModal();
      
      // Initialize stream viewer functionality
      initializeStreamViewer();
      
      // Initialize stream status overlay
      initializeStreamStatusOverlay();
      
      // Initialize live edge enforcement for students
      if (!isInstructor) {
        initializeLiveEdgeEnforcement();
      }
      
      // Initialize enhanced canvas timeline
      setTimeout(() => {
        // Try to initialize with the active video element
        const video = document.getElementById('video');
        const webrtcVideo = document.getElementById('webrtcVideo');
        const activeVideoId = (video && video.style.display !== 'none') ? 'video' : 'webrtcVideo';
        
        window.enhancedTimeline = new EnhancedTimeline('timelineCanvas', activeVideoId);
        console.log('✅ Enhanced Timeline initialized with:', activeVideoId);
        
        // Also set up WebRTC video events if it's the active one
        if (activeVideoId === 'webrtcVideo' && webrtcVideo) {
          webrtcVideo.addEventListener('timeupdate', () => {
            updateTimelineViewport();
          });
        }
      }, 100);
      
      // Check for live stream video from localStorage first
      checkForLiveStreamVideo();
      
      // Check initial stream state from server
      setTimeout(() => {
        checkStreamState();
      }, 1000);
      
      // Initialize stream timer for WebRTC
      if (!streamTimer) {
        streamTimer = createStreamTimer();
        console.log('⏱️ Stream timer initialized on page load');
      }
      
      // Start WebRTC timeline updates
      startWebRTCTimelineUpdates();
      
      // Initialize WebRTC timeline
      initializeWebRTCTimeline();
      
      // Show WebRTC status
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'flex';
      }
    });

    // Check for live stream video from localStorage and autoplay
    function checkForLiveStreamVideo() {
      try {
        const liveStreamVideoData = localStorage.getItem('liveStreamVideo');
        if (liveStreamVideoData) {
          const videoData = JSON.parse(liveStreamVideoData);
          console.log('🎬 Found live stream video in localStorage:', videoData.name);
          
          // Load and autoplay the video
          loadLiveStreamVideo(videoData);
          
          // Clear the localStorage entry after loading
          localStorage.removeItem('liveStreamVideo');
          console.log('🧹 Cleared live stream video from localStorage');
        } else {
          console.log('📭 No live stream video found in localStorage');
        }
      } catch (error) {
        console.error('❌ Error checking for live stream video:', error);
      }
    }

    // Load and autoplay the live stream video
    function loadLiveStreamVideo(videoData) {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      
      if (!video) {
        console.error('❌ Video element not found');
        return;
      }
      
      console.log('🚀 Loading live stream video:', videoData.name);
      
      // Hide WebRTC video and show regular video
      if (webrtcVideo) {
        webrtcVideo.style.display = 'none';
      }
      video.style.display = 'block';
      
      // Set video source
      video.src = videoData.url;
      
      // Set up event listeners for autoplay
      video.addEventListener('loadeddata', function() {
        console.log('✅ Live stream video data loaded');
        
        // Hide stream status overlay when video loads
        hideStreamStatusOverlay();
        isStreamActive = true;
        
        // Attempt to autoplay
        video.play().then(() => {
          console.log('▶️ Live stream video started playing automatically');
          
          // Update UI to show live status
          updateLiveStatus(true);
          
          // Update video title
          updateVideoTitle(videoData.name);
          
        }).catch(error => {
          console.log('🔇 Autoplay prevented, user interaction required:', error);
          
          // Show play button overlay or notification
          showPlayPrompt(videoData.name);
        });
      }, { once: true });
      
      video.addEventListener('error', function(e) {
        console.error('❌ Error loading live stream video:', e);
        showErrorMessage('Video Load Error', 'Failed to load the live stream video. Please try again.');
      }, { once: true });
      
      // Load the video
      video.load();
    }

    // Update live status indicator
    function updateLiveStatus(isLive) {
      const liveBadge = document.querySelector('.live-badge');
      if (liveBadge) {
        if (isLive) {
          liveBadge.classList.remove('hidden');
          liveBadge.textContent = 'LIVE';
        } else {
          liveBadge.classList.add('hidden');
        }
      }
    }

    // Update video title
    function updateVideoTitle(title) {
      const videoTitle = document.querySelector('.video-title');
      if (videoTitle) {
        videoTitle.textContent = title || 'Live Stream';
      }
    }

    // Show play prompt when autoplay is prevented
    function showPlayPrompt(videoName) {
      // Create a play prompt overlay
      const videoContainer = document.querySelector('.video-container');
      if (!videoContainer) return;
      
      const playPrompt = document.createElement('div');
      playPrompt.className = 'play-prompt-overlay';
      playPrompt.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 100;
        color: white;
        text-align: center;
        padding: 2rem;
      `;
      
      playPrompt.innerHTML = `
        <div style="font-size: 1.5rem; margin-bottom: 1rem;">🎬 ${videoName}</div>
        <div style="font-size: 1rem; margin-bottom: 2rem; opacity: 0.8;">Click to start the live stream</div>
        <button style="
          background: var(--primary-gradient);
          border: 2px solid var(--accent);
          color: white;
          font-size: 1.2rem;
          padding: 1rem 2rem;
          border-radius: 50px;
          cursor: pointer;
          transition: all 0.3s ease;
        ">▶️ Play Live Stream</button>
      `;
      
      const playButton = playPrompt.querySelector('button');
      playButton.addEventListener('click', () => {
        const video = document.getElementById('video');
        video.play().then(() => {
          console.log('▶️ Live stream started after user interaction');
          updateLiveStatus(true);
          videoContainer.removeChild(playPrompt);
        }).catch(error => {
          console.error('❌ Failed to play video after user interaction:', error);
        });
      });
      
      videoContainer.appendChild(playPrompt);
    }
    
    // Error message display function
    function showErrorMessage(title, message) {
      // Hide loading spinner
      loading.style.display = 'none';
      
      // Create error overlay
      const errorOverlay = document.createElement('div');
      errorOverlay.className = 'welcome-modal show';
      errorOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ef4444; display: flex; align-items: center; gap: 0.5rem;">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
              <line x1="12" y1="9" x2="12" y2="13"></line>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            ${title}
          </h2>
          <div class="welcome-text">
            <p>${message}</p>
            <div style="margin-top: 20px; padding: 15px; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border-left: 4px solid #ef4444;">
              <strong>Quick Fixes:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>Make sure you're logged in to the system</li>
                <li>Access the stream through the dashboard or class page</li>
                <li>Check that the class ID in the URL is correct</li>
                <li>Contact your instructor if the problem persists</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="goToDashboard()">Go to Dashboard</button>
            <button class="welcome-close" onclick="retryConnection()" style="background: #22c55e;">Retry</button>
            <button class="welcome-close" onclick="openDebugTool()" style="background: #ff9800;">Debug Tool</button>
            <button class="welcome-close" onclick="testWebRTCConnection()" style="background: #8b5cf6;">Test WebRTC</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(errorOverlay);
    }
    
    function goToDashboard() {
      window.location.href = '/dashboard.html';
    }
    
    function retryConnection() {
      // Remove error overlay
      const errorOverlay = document.querySelector('.welcome-modal');
      if (errorOverlay) {
        errorOverlay.remove();
      }
      
      // Show loading and retry
      loading.style.display = 'block';
      fetchClassInfo();
    }
    
    function openDebugTool() {
      window.open('/debug-stream.html', '_blank');
    }
    
    // Test WebRTC connection manually
    function testWebRTCConnection() {
      console.log('🧪 Testing WebRTC connection...');
      console.log('📊 Current state:');
      console.log('  - Class ID:', classId);
      console.log('  - WebRTC Socket:', webrtcSocket ? 'Connected' : 'Not connected');
      console.log('  - Peer Connection:', peerConnection ? 'Exists' : 'None');
      console.log('  - WebRTC Video Element:', webrtcVideo);
      console.log('  - Is WebRTC Mode:', isWebRTCMode);
      
      // Force switch to WebRTC mode for testing
      switchToWebRTCMode();
      
      // Test video element
      if (webrtcVideo) {
        console.log('📺 WebRTC Video Element Properties:');
        console.log('  - Display:', webrtcVideo.style.display);
        console.log('  - Source Object:', webrtcVideo.srcObject);
        console.log('  - Autoplay:', webrtcVideo.autoplay);
        console.log('  - Muted:', webrtcVideo.muted);
      }
    }
    
    // Test streaming connection end-to-end
    async function testStreamingConnection() {
      console.log('🧪 Testing streaming connection...');
      
      const results = {
        classId: classId || 'Not set',
        streamKey: streamKey || 'Not set',
        socketConnection: false,
        hlsServer: false,
        streamEndpoint: false,
        streamStatus: 'Unknown'
      };
      
      try {
        // Test 1: Check if we have class ID
        if (!classId) {
          console.error('❌ No class ID available');
          return results;
        }
        
        // Test 2: Check Socket.IO connection
        if (typeof io !== 'undefined') {
          results.socketConnection = true;
          console.log('✅ Socket.IO is available');
        } else {
          console.error('❌ Socket.IO not available');
        }
        
        // Test 3: Check HLS server
        try {
          const hlsTestUrl = `http://198.211.107.134/hls/${streamKey}.m3u8`;
          const hlsResponse = await fetch(hlsTestUrl, { method: 'HEAD' });
          results.hlsServer = hlsResponse.ok;
          console.log(hlsResponse.ok ? '✅ HLS server responding' : '❌ HLS server not responding');
        } catch (error) {
          console.error('❌ HLS server test failed:', error.message);
        }
        
        // Test 4: Check stream status endpoint
        try {
          const authToken = localStorage.getItem('token');
          const statusResponse = await fetch(`/api/stream/status/${classId}`, {
            headers: { 'Authorization': `Bearer ${authToken}` }
          });
          
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            results.streamStatus = statusData.status;
            results.streamEndpoint = true;
            console.log('✅ Stream status endpoint working, status:', statusData.status);
          } else {
            console.error('❌ Stream status endpoint failed:', statusResponse.status);
          }
        } catch (error) {
          console.error('❌ Stream status test failed:', error.message);
        }
        
        // Test 5: Test stream start simulation (for instructors only)
        const userRole = localStorage.getItem('role');
        if (userRole === 'instructor' || userRole === 'admin') {
          console.log('👨‍🏫 Instructor detected - testing stream start capability');
          try {
            const authToken = localStorage.getItem('token');
            const testResponse = await fetch(`/api/streams/start/${classId}`, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
              },
              body: JSON.stringify({ source: 'test' })
            });
            
            if (testResponse.ok) {
              console.log('✅ Stream start endpoint accessible');
              // Immediately stop the test stream
              await fetch(`/api/streams/stop/${classId}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({})
              });
            } else {
              console.error('❌ Stream start endpoint failed:', testResponse.status);
            }
          } catch (error) {
            console.error('❌ Stream start test failed:', error.message);
          }
        }
        
        console.log('🧪 Streaming connection test results:', results);
        return results;
        
      } catch (error) {
        console.error('❌ Streaming connection test failed:', error);
        return results;
      }
    }
    
    // Pre-Stream Checklist System
    async function runPreStreamChecklist() {
      console.log('🔍 Running Pre-Stream Checklist...');
      
      const checklist = {
        authentication: { status: 'pending', message: 'Checking authentication...' },
        classAccess: { status: 'pending', message: 'Verifying class access...' },

        studentEnrollment: { status: 'pending', message: 'Checking student enrollment...' },
        streamingInfrastructure: { status: 'pending', message: 'Testing streaming infrastructure...' },
        socketConnection: { status: 'pending', message: 'Establishing real-time connection...' },
        streamStatus: { status: 'pending', message: 'Initializing stream status...' }
      };
      
      // Show checklist if instructor
      const userRole = localStorage.getItem('role');
      if (userRole === 'instructor') {
        showPreStreamChecklist(checklist);
      }
      
      try {
        // 1. Authentication Check
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          checklist.authentication = { status: 'failed', message: 'No authentication token found' };
          throw new Error('Authentication required');
        }
        
        // Verify token with server
        const authResponse = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!authResponse.ok) {
          checklist.authentication = { status: 'failed', message: 'Invalid or expired token' };
          throw new Error('Authentication failed');
        }
        
        checklist.authentication = { status: 'success', message: 'Authentication verified' };
        updateChecklistItem('authentication', checklist.authentication);
        
        // 2. Class Access Check
        const classResponse = await fetch(`/api/stream/status/${classId}`, {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (!classResponse.ok) {
          if (classResponse.status === 403) {
            checklist.classAccess = { status: 'failed', message: 'Access denied to this class' };
          } else if (classResponse.status === 404) {
            checklist.classAccess = { status: 'failed', message: 'Class not found' };
          } else {
            checklist.classAccess = { status: 'failed', message: `Server error: ${classResponse.status}` };
          }
          throw new Error('Class access failed');
        }
        
        const classData = await classResponse.json();
        checklist.classAccess = { status: 'success', message: `Access granted to "${classData.currentLesson?.title || 'class'}"` };
        updateChecklistItem('classAccess', checklist.classAccess);
        
        // 3. Student Enrollment Check
        const enrollmentCount = classData.session?.enrolledStudents || 0;
        if (enrollmentCount === 0) {
          checklist.studentEnrollment = { status: 'warning', message: 'No students enrolled yet' };
        } else {
          checklist.studentEnrollment = { status: 'success', message: `${enrollmentCount} students enrolled` };
        }
        updateChecklistItem('studentEnrollment', checklist.studentEnrollment);
        
        // 5. Streaming Infrastructure Check
        const hlsServerUrl = process.env.HLS_SERVER_URL || 'http://198.211.107.134';
        try {
          const infraResponse = await fetch(`${hlsServerUrl}/health`, { method: 'HEAD' });
          if (infraResponse.ok) {
            checklist.streamingInfrastructure = { status: 'success', message: 'Streaming server ready' };
          } else {
            checklist.streamingInfrastructure = { status: 'warning', message: 'Streaming server may not be ready' };
          }
        } catch (error) {
          checklist.streamingInfrastructure = { status: 'warning', message: 'Cannot verify streaming server' };
        }
        updateChecklistItem('streamingInfrastructure', checklist.streamingInfrastructure);
        
        // 6. Socket.IO Connection
        if (typeof io !== 'undefined') {
          checklist.socketConnection = { status: 'success', message: 'Real-time connection ready' };
        } else {
          checklist.socketConnection = { status: 'warning', message: 'Socket.IO not available' };
        }
        updateChecklistItem('socketConnection', checklist.socketConnection);
        
        // 7. Stream Status Initialization
        checklist.streamStatus = { status: 'success', message: `Stream status: ${classData.status}` };
        updateChecklistItem('streamStatus', checklist.streamStatus);
        
        console.log('✅ Pre-Stream Checklist completed successfully');
        return { success: true, checklist };
        
      } catch (error) {
        console.error('❌ Pre-Stream Checklist failed:', error);
        return { success: false, checklist, error: error.message };
      }
    }
    

    
    // Show pre-stream checklist for instructors
    function showPreStreamChecklist(checklist) {
      const checklistOverlay = document.createElement('div');
      checklistOverlay.className = 'welcome-modal show';
      checklistOverlay.id = 'preStreamChecklist';
      checklistOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title">🔍 Pre-Stream Checklist</h2>
          <div class="welcome-text">
            <p>Verifying all systems are ready for streaming...</p>
            <div id="checklistItems" style="margin: 20px 0; text-align: left;">
              ${Object.entries(checklist).map(([key, item]) => `
                <div class="checklist-item" id="checklist-${key}" style="
                  padding: 10px;
                  margin: 8px 0;
                  background: rgba(255, 255, 255, 0.05);
                  border-radius: 8px;
                  border-left: 4px solid #fbbf24;
                  display: flex;
                  align-items: center;
                ">
                  <div class="status-icon" style="margin-right: 10px; font-size: 1.2em;">⏳</div>
                  <div class="status-text">${item.message}</div>
                </div>
              `).join('')}
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closePreStreamChecklist()" disabled id="checklistCloseBtn">Please Wait...</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(checklistOverlay);
    }
    
    // Update individual checklist item
    function updateChecklistItem(key, item) {
      const checklistItem = document.getElementById(`checklist-${key}`);
      if (!checklistItem) return;
      
      const statusIcon = checklistItem.querySelector('.status-icon');
      const statusText = checklistItem.querySelector('.status-text');
      
      let color, icon;
      switch (item.status) {
        case 'success':
          color = '#22c55e';
          icon = '✅';
          break;
        case 'warning':
          color = '#fbbf24';
          icon = '⚠️';
          break;
        case 'failed':
          color = '#ef4444';
          icon = '❌';
          break;
        default:
          color = '#fbbf24';
          icon = '⏳';
      }
      
      checklistItem.style.borderLeftColor = color;
      statusIcon.textContent = icon;
      statusText.textContent = item.message;
      
      // Check if all items are complete
      setTimeout(() => {
        const allItems = document.querySelectorAll('.checklist-item .status-icon');
        const allComplete = Array.from(allItems).every(icon => 
          icon.textContent === '✅' || icon.textContent === '⚠️' || icon.textContent === '❌'
        );
        
        if (allComplete) {
          const closeBtn = document.getElementById('checklistCloseBtn');
          if (closeBtn) {
            closeBtn.disabled = false;
            closeBtn.textContent = 'Continue';
          }
        }
      }, 100);
    }
    
    // Close pre-stream checklist
    function closePreStreamChecklist() {
      const checklistOverlay = document.getElementById('preStreamChecklist');
      if (checklistOverlay) {
        checklistOverlay.remove();
      }
    }
    
    // Auto-assign class ID for students based on their enrollment
    async function autoAssignStudentClass() {
      const userRole = localStorage.getItem('role');
      if (userRole !== 'student') return null;
      
      try {
        const authToken = localStorage.getItem('token');
        const response = await fetch('/api/auth/verify', {
          headers: { 'Authorization': `Bearer ${authToken}` }
        });
        
        if (response.ok) {
          const userData = await response.json();
          if (userData.user.classId) {
            console.log('📚 Auto-assigned student to class:', userData.user.classId);
            localStorage.setItem('currentClassId', userData.user.classId);
            return userData.user.classId;
          }
        }
      } catch (error) {
        console.error('❌ Failed to auto-assign student class:', error);
      }
      
      return null;
    }
    
    function showWaitingMessage() {
      // Update the stream type indicator
      updateStreamTypeIndicator('Waiting for Stream...');
      
      // Create a waiting overlay
      const waitingOverlay = document.createElement('div');
      waitingOverlay.className = 'welcome-modal show';
      waitingOverlay.id = 'waitingOverlay';
      waitingOverlay.innerHTML = `
        <div class="welcome-content">
          <h2 class="welcome-title" style="color: #ff9800;">⏳ Waiting for Stream</h2>
          <div class="welcome-text">
            <p>The instructor hasn't started streaming yet. The page will automatically update when the stream becomes available.</p>
            <div style="margin: 20px 0; padding: 15px; background: rgba(255, 152, 0, 0.1); border-radius: 10px; border-left: 4px solid #ff9800;">
              <strong>What's happening:</strong>
              <ul style="margin: 10px 0; text-align: left;">
                <li>✅ Connected to class successfully</li>
                <li>⏳ Waiting for instructor to start streaming</li>
                <li>🔄 Automatically checking for updates every 3 seconds</li>
              </ul>
            </div>
          </div>
          <div class="welcome-actions">
            <button class="welcome-close" onclick="closeWaitingMessage()">Continue Waiting</button>
            <button class="welcome-close" onclick="goToDashboard()" style="background: #6b7280;">Back to Dashboard</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(waitingOverlay);
    }
    
    function closeWaitingMessage() {
      const waitingOverlay = document.getElementById('waitingOverlay');
      if (waitingOverlay) {
        waitingOverlay.remove();
      }
    }
    
    // Update stream type indicator with class information
    function updateStreamTypeIndicator(streamType = 'Stream') {
      const className = localStorage.getItem('currentClassName');
      if (className) {
        streamTypeIndicator.textContent = `${className} - ${streamType}`;
      } else {
        streamTypeIndicator.textContent = streamType;
      }
    }
    
    // ===== NOTIFICATION SYSTEM =====
    function showNotification(message, type = 'info') {
      // Remove existing notification
      const existingNotification = document.querySelector('.stream-notification');
      if (existingNotification) {
        existingNotification.remove();
      }
      
      // Create notification element
      const notification = document.createElement('div');
      notification.className = `stream-notification ${type}`;
      notification.textContent = message;
      
      // Style the notification
      const colors = {
        info: { bg: 'rgba(59, 130, 246, 0.9)', border: '#3b82f6' },
        warning: { bg: 'rgba(245, 158, 11, 0.9)', border: '#f59e0b' },
        error: { bg: 'rgba(239, 68, 68, 0.9)', border: '#ef4444' },
        success: { bg: 'rgba(34, 197, 94, 0.9)', border: '#22c55e' }
      };
      
      const color = colors[type] || colors.info;
      
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${color.bg};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        border-left: 4px solid ${color.border};
        font-size: 14px;
        font-weight: 500;
        z-index: 1000;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        animation: slideInRight 0.3s ease-out;
      `;
      
      // Add animation keyframes if not already added
      if (!document.querySelector('#notification-styles')) {
        const style = document.createElement('style');
        style.id = 'notification-styles';
        style.textContent = `
          @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
          @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }
      
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.remove();
            }
          }, 300);
        }
      }, 3000);
    }
    
    // Automatically fetch user's assigned class ID
    async function fetchUserAssignedClass() {
      try {
        const authToken = localStorage.getItem('token');
        if (!authToken) {
          console.log('❌ No auth token available');
          return null;
        }
        
        console.log('📡 Fetching user\'s assigned class from server...');
        
        // First, try to get user info which should include their assigned class
        const userResponse = await fetch('/api/auth/verify', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (userResponse.ok) {
          const userData = await userResponse.json();
          console.log('👤 User data:', userData.user);
          
          // Check if user has a direct class assignment
          if (userData.user.classId) {
            console.log('✅ Found direct class assignment:', userData.user.classId);
            return userData.user.classId;
          }
        }
        
        // If no direct assignment, try to get user's enrolled classes
        const classesResponse = await fetch('/api/classes/my-classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (classesResponse.ok) {
          const userClasses = await classesResponse.json();
          console.log('📚 Found user classes:', userClasses.length);
          
          if (userClasses.length > 0) {
            // Prioritize classes with active streams, then most recent
            const sortedClasses = userClasses.sort((a, b) => {
              // Live streams first
              if (a.streamStatus === 'live' && b.streamStatus !== 'live') return -1;
              if (b.streamStatus === 'live' && a.streamStatus !== 'live') return 1;
              
              // Then by most recent update
              return new Date(b.updatedAt) - new Date(a.updatedAt);
            });
            
            const selectedClass = sortedClasses[0];
            console.log('✅ Auto-selected class:', selectedClass.name, selectedClass._id);
            
            // Store class name for display
            localStorage.setItem('currentClassName', selectedClass.name);
            
            return selectedClass._id;
          }
        }
        
        // Fallback: try to get any accessible class for this user
        console.log('⚠️ No enrolled classes found, checking accessible classes...');
        const allClassesResponse = await fetch('/api/classes', {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (allClassesResponse.ok) {
          const allClasses = await allClassesResponse.json();
          if (allClasses.length > 0) {
            // For instructors, they might have access to classes they teach
            const userRole = localStorage.getItem('role');
            if (userRole === 'instructor' || userRole === 'admin') {
              const firstClass = allClasses[0];
              console.log('✅ Instructor/Admin assigned to first available class:', firstClass._id);
              localStorage.setItem('currentClassName', firstClass.name);
              return firstClass._id;
            }
          }
        }
        
        console.log('❌ No accessible classes found');
        return null;
        
      } catch (error) {
        console.error('❌ Error fetching user assigned class:', error);
        return null;
      }
    }
    

    
    const video = document.getElementById('video');
    const webrtcVideo = document.getElementById('webrtcVideo');
    const streamTypeIndicator = document.getElementById('streamTypeIndicator');
    // const playBtn = document.getElementById('playBtn'); // Removed
    const timeline = document.getElementById('timeline');
    const progress = document.getElementById('progress');
    
    // HLS-Only Variables (WebRTC removed)
    let classId = null;
    
    // Stream Timer for WebRTC (since WebRTC doesn't have reliable currentTime)
    let streamTimer = null;
    let streamStartTime = null;
    let streamDuration = 3600; // Default 1 hour, can be updated from server
    let isStreamPaused = false;
    let pausedAt = 0;
    const playhead = document.getElementById('playhead');
    // const fullscreenBtn = document.getElementById('fullscreenBtn'); // Removed
    const loading = document.getElementById('loading');
    // const rateBtn = document.getElementById('rateBtn'); // Removed
    // const liveBtn = document.getElementById('liveBtn'); // Removed
    // const streamMode = document.getElementById('streamMode'); // Removed
    const fileInput = document.getElementById('fileInput');
    const thumbnailPreview = document.getElementById('thumbnailPreview');
    const thumbnailImg = document.getElementById('thumbnailImg');
    const thumbnailTime = document.getElementById('thumbnailTime');
    
    // Skip buttons - Commented out as buttons were removed
    // document.getElementById('rewind10').onclick = () => video.currentTime -= 10;
    // document.getElementById('rewind30').onclick = () => video.currentTime -= 30;
    // document.getElementById('forward10').onclick = () => video.currentTime += 10;
    // document.getElementById('forward30').onclick = () => video.currentTime += 30;
    
    let hlsInstance = null;
    
    // Stream Timer Utility for WebRTC
    function createStreamTimer(startTime = Date.now()) {
      return {
        startTime: startTime,
        isPaused: false,
        pauseAt: 0,
        
        get currentTime() {
          if (this.isPaused) return this.pauseAt;
          return (Date.now() - this.startTime) / 1000;
        },
        
        pause() {
          this.isPaused = true;
          this.pauseAt = (Date.now() - this.startTime) / 1000;
        },
        
        resume() {
          this.isPaused = false;
          this.startTime = Date.now() - this.pauseAt * 1000;
        },
        
        reset() {
          this.startTime = Date.now();
          this.pauseAt = 0;
          this.isPaused = false;
        },
        
        setTime(seconds) {
          if (this.isPaused) {
            this.pauseAt = seconds;
          } else {
            this.startTime = Date.now() - seconds * 1000;
          }
        }
      };
    }
    
    // HLS-only video control functions
    function getCurrentTime() {
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      return video ? video.currentTime || 0 : 0;
    }
    function getDuration() {
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
    
      return video ? video.duration || 0 : 0;
    }
    
    function setCurrentTime(time) {
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video) {
        video.currentTime = time;
      }
    }

    // Thumbnail generation functionality
    let thumbnailCache = [];
    let webrtcThumbnailCache = [];
    
    function generateThumbnails() {
      const offscreen = document.createElement('canvas');
      offscreen.width = 120;
      offscreen.height = 70;
      const offCtx = offscreen.getContext('2d');

      let current = 0;
      const end = Math.floor(video.duration);

      function snapNext() {
        if (current > end) return;

        video.currentTime = current;
        video.addEventListener('seeked', function capture() {
          offCtx.drawImage(video, 0, 0, offscreen.width, offscreen.height);
          const img = new Image();
          img.src = offscreen.toDataURL();
          thumbnailCache.push({ time: current, img });

          current++;
          video.removeEventListener('seeked', capture);
          setTimeout(snapNext, 200); // short delay ensures rendering stability
        }, { once: true });
      }

      snapNext();
    }
    
    // Function to get thumbnail for a specific time - Updated for both modes
    function getThumbnailForTime(time, cache = null) {
      const targetCache = cache || (isWebRTCMode ? webrtcThumbnailCache : thumbnailCache);
      
      if (targetCache.length === 0) return null;
      
      // Find the closest thumbnail
      let closest = targetCache[0];
      let minDiff = Math.abs(closest.time - time);
      
      for (let i = 1; i < targetCache.length; i++) {
        const diff = Math.abs(targetCache[i].time - time);
        if (diff < minDiff) {
          minDiff = diff;
          closest = targetCache[i];
        }
      }
      
      return closest;
    }
    
    // Function to load WebRTC thumbnails from server
    async function loadWebRTCThumbnails() {
      if (!classId) return;
      
      try {
        console.log('📸 Loading WebRTC thumbnails...');
        webrtcThumbnailCache = [];
        
        // Generate thumbnails for every second up to stream duration
        for (let i = 0; i <= streamDuration; i++) {
          webrtcThumbnailCache.push({
            time: i,
            url: `/api/thumbnails/${classId}/${i}.jpg`, // Adjust URL based on your backend
            img: null // Will be loaded on demand
          });
        }
        
        console.log(`📸 Generated ${webrtcThumbnailCache.length} WebRTC thumbnail placeholders`);
      } catch (error) {
        console.error('❌ Error loading WebRTC thumbnails:', error);
      }
    }
    
    // WebRTC Functions
    function initializeWebRTCSocket() {
      if (webrtcSocket) return;
      
      webrtcSocket = io();
      
      webrtcSocket.on('connect', () => {
        console.log('🔌 WebRTC Socket connected');
        if (classId) {
          webrtcSocket.emit('student-join-class', { classId: classId });
        }
      });
      
      webrtcSocket.on('disconnect', () => {
        console.log('❌ WebRTC Socket disconnected');
      });
      
      webrtcSocket.on('instructor-started-webrtc', (data) => {
        console.log('🔴 Instructor started WebRTC stream:', data.mediaType);
        console.log('🔄 Current WebRTC video element:', webrtcVideo);
        console.log('🔄 Current peer connection:', peerConnection);
        
        // Set stream duration if provided
        if (data.duration) {
          streamDuration = data.duration;
        }
        
        switchToWebRTCMode();
        updateStreamTypeIndicator(`Live ${data.mediaType}`);
        
        // Load WebRTC thumbnails
        loadWebRTCThumbnails();
        
        // Show loading while waiting for WebRTC connection
        loading.style.display = 'block';
        loading.textContent = 'Connecting to live stream...';
      });
      
      webrtcSocket.on('instructor-stopped-webrtc', (data) => {
        console.log('⏹️ Instructor stopped WebRTC stream');
        switchToFileMode();
        if (peerConnection) {
          peerConnection.close();
          peerConnection = null;
        }
      });
      
      webrtcSocket.on('webrtc-offer', async (data) => {
        console.log('📡 Received WebRTC offer from instructor');
        await handleWebRTCOffer(data.offer);
      });
      
      webrtcSocket.on('webrtc-ice-candidate', async (data) => {
        console.log('📡 Received ICE candidate from instructor');
        if (peerConnection) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    // WebRTC functions removed - HLS-only implementation
    function handleStreamOffer(streamData) {
  console.log('🎬 Handling HLS stream offer:', streamData);
      
      // Initialize HLS stream instead of WebRTC
      if (streamData.classId)stream notification:', data);
      
      if (data.type === 'stream:start') {
    initializeCleanHLS();
        
        // Handle incoming stream
        peerConnection.ontrack = (event) => {
          console.log('📺 Received WebRTC stream:', event.streams[0]);
      console.log('📺 Stream tracks:', event.streams[0].getTracks());
          
          webrtcVideo.srcObject = event.streams[0];
          
          // Ensure we're in WebRTC mode
          switchToWebRTCMode();
          
          // Try to play the video
          webrtcVideo.play().then(() => {
            console.log('✅ WebRTC video playing');
            loading.style.display = 'none';
          }).catch(error => {
            console.error('❌ WebRTC video play failed:', error);⏹️ Stream stopped');
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
            // Try to play with user interaction
            webrtcVideo.muted = true;
            webrtcVideo.play().then(() => {Initialize HLS stream for the class
          setTimeout(() => {
            initializeCleanHLS();
          }, 1000);
        }updateStreamTypeIndicator('🔴 HLS Live Stream');
      console.log('✅ HLS mode initialized');
    }
              console.log('✅ WebRTC video playing (muted)');
              loading.style.display = 'none';
            }).catch(e => {
              console.error('❌ WebRTC video play failed even muted:', e);
            });
          });
        };
        
        // Handle ICE candidates
        peerConnection.onicecandidate = (event) => {
          if (event.candidate) {
            webrtcSocket.emit('webrtc-ice-candidate', {
              to: 'instructor',
              candidate: event.candidate
            });
          }
        };
        
        // Handle connection state changes
        peerConnection.onconnectionstatechange = () => {
          const state = peerConnection.connectionState;
          console.log('🔗 WebRTC connection state:', state);
          
          if (state === 'connected') {
            console.log('✅ WebRTC connection established');
          } else if (state === 'disconnected' || state === 'failed') {
            console.log('❌ WebRTC connection lost');
            switchToFileMode();
          }
        };
        
        // Set remote description and create answer
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        
        // Send answer back to instructor
        webrtcSocket.emit('webrtc-answer', {
          to: 'instructor',
          answer: answer
        });
        
        console.log('📤 Sent WebRTC answer to instructor');
      } catch (error) {
        console.error('❌ Error handling WebRTC offer:', error);
        switchToFileMode();
      }
    }
    
    // WebRTC functions removed - HLS only
    function initializeHLSMode() {
      console.log('🎬 Initializing HLS-only mode');
      
      const hlsVideo = document.getElementById('hlsVideo');
      const regularVideo = document.getElementById('video');
      
      if (hlsVideo) {
        hlsVideo.style.display = 'block';
        hlsVideo.autoplay = true;
        hlsVideo.playsInline = true;
        hlsVideo.controls = false; // Use custom controls
        currentVideo = hlsVideo;
      }
      
      if (regularVideo) {
        regularVideo.style.display = 'none';
      }
      updateStreamTypeIndicator('🔴 HLS Live Stream');
      console.log('✅ HLS mode initialized');
    }
      // Show timeline
      const timeline = document.getElementById('timeline');
      if (timeline) {
        timeline.style.display = 'block';
      }
      
      
      
      // Show file-based controls
      document.getElementById('timeline').style.display = 'block';
      
      updateStreamTypeIndicator('File Stream');
      
      // Hide WebRTC status indicator
      const webrtcStatus = document.getElementById('webrtcStatus');
      if (webrtcStatus) {
        webrtcStatus.style.display = 'none';
      }
      
      // Stop WebRTC timeline updates
      stopWebRTCTimelineUpdates();
      
      if (webrtcVideo.srcObject) {
        webrtcVideo.srcObject = null;
      }
    }
    
    // WebRTC Timeline Update Functions
    let webrtcTimelineInterval = null;
    let timelineScrollOffset = 0;
    let isTimelineDragging = false;
    let currentZoomLevel = 1;
    
    // Time formatting function
    function formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Generate time hash ticks
    function generateTimeHashes(duration, zoomLevel = 1) {
      const timeHashes = document.getElementById('time-hashes');
      if (!timeHashes) return;
      
      // Determine tick interval based on zoom level and duration
      let tickInterval = 10; // Default 10 seconds
      if (duration > 3600) tickInterval = 60; // 1 minute for long streams
      else if (duration > 1800) tickInterval = 30; // 30 seconds for medium streams
      else if (zoomLevel > 2) tickInterval = 5; // 5 seconds when zoomed in
      
      const containerWidth = duration * zoomLevel * 2; // Adjust multiplier as needed
      const tickSpacing = (tickInterval / duration) * containerWidth;
      
      let ticksHTML = '';
      for (let time = 0; time <= duration; time += tickInterval) {
        const leftPosition = (time / duration) * containerWidth;
        ticksHTML += `
          <div class="time-tick" style="left: ${leftPosition}px;">
            <div class="time-tick-line"></div>
            <div class="time-tick-label">${formatTime(time)}</div>
          </div>
        `;
      }
      
      timeHashes.innerHTML = ticksHTML;
      console.log(`📏 Generated time hashes: ${Math.ceil(duration / tickInterval)} ticks`);
    }
    
    // Timeline zoom functionality
    function zoomTimeline(factor) {
      currentZoomLevel = Math.max(0.5, Math.min(5, currentZoomLevel * factor));
      
      // Regenerate time hashes with new zoom level
      generateTimeHashes(streamDuration, currentZoomLevel);
      
      // Update timeline container width
      const timelineContainer = document.getElementById('timelineContainer');
      if (timelineContainer) {
        const newWidth = streamDuration * currentZoomLevel * 2;
        timelineContainer.style.minWidth = `${newWidth}px`;
      }
      
      console.log(`🔍 Timeline zoom level: ${currentZoomLevel.toFixed(1)}x`);
    }
    
    function startWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
      }
      
      webrtcTimelineInterval = setInterval(() => {
        if (streamTimer && !isTimelineDragging) {
          updateTimelineScrollForWebRTC();
          updateTimeDisplayForWebRTC();
          updateJumpToLiveIndicatorForWebRTC();
        }
      }, 100); // Update every 100ms for smooth timeline
    }
    
    function stopWebRTCTimelineUpdates() {
      if (webrtcTimelineInterval) {
        clearInterval(webrtcTimelineInterval);
        webrtcTimelineInterval = null;
      }
    }
    
    function updateTimelineScrollForWebRTC() {
      const currentTime = streamTimer.currentTime;
      const duration = streamDuration;
      const timeline = document.getElementById('timeline');
      const timelineTrack = document.getElementById('timeline-track');
      const timeHashes = document.getElementById('time-hashes');
      
      if (!timeline || !timelineTrack || !timeHashes || duration <= 0) return;
      
      // Calculate scroll position to keep current time centered
      const timelineWidth = timeline.offsetWidth;
      const trackWidth = timelineTrack.offsetWidth || (duration * currentZoomLevel * 2);
      const timeProgress = currentTime / duration;
      
      // Calculate the scroll offset to center the current time
      const centerOffset = timelineWidth / 2;
      const targetScrollPosition = (timeProgress * trackWidth) - centerOffset;
      
      // Clamp scroll position to valid range
      const maxScroll = Math.max(0, trackWidth - timelineWidth);
      const clampedScroll = Math.max(0, Math.min(maxScroll, targetScrollPosition));
      
      // Apply smooth transform to both timeline track and time hashes
      const transformValue = `translateX(-${clampedScroll}px)`;
      timelineTrack.style.transform = transformValue;
      timeHashes.style.transform = transformValue;
      
      timelineScrollOffset = clampedScroll;
    }
    
    function updateTimeDisplayForWebRTC() {
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl && streamTimer) {
        currentTimeEl.textContent = formatTime(streamTimer.currentTime);
        totalTimeEl.textContent = formatTime(streamDuration);
      }
    }
    
    function updateJumpToLiveIndicatorForWebRTC() {
      const indicator = document.getElementById('jumpToLiveIndicator');
      
      if (!indicator || !streamTimer) return;
      
      // For WebRTC, we're always "live" unless we've manually adjusted the timer
      // Show indicator if user has scrolled back in time
      const currentTime = streamTimer.currentTime;
      const liveTime = (Date.now() - streamTimer.startTime) / 1000;
      const isAtLive = Math.abs(liveTime - currentTime) < 3;
      
      indicator.style.display = isAtLive ? 'none' : 'block';
    }
    
    function initializeWebRTCTimeline() {
      console.log('🎬 Initializing WebRTC timeline');
      
      // Clear existing timeline content
      const timelineContainer = document.getElementById('timelineContainer');
      if (timelineContainer) {
        timelineContainer.innerHTML = '';
      }
      
      // Generate time hash ticks
      generateTimeHashes(streamDuration, currentZoomLevel);
      
      // Generate timeline frames for WebRTC
      generateWebRTCTimelineFrames();
    }
    
    function generateWebRTCTimelineFrames() {
      const container = timeline.querySelector('.timeline-container');
      if (!container) return;
      
      const frameWidth = 120; // Width of each thumbnail frame
      const totalFrames = Math.ceil(streamDuration);
      const totalWidth = totalFrames * frameWidth;
      
      container.style.minWidth = `${totalWidth}px`;
      
      // Generate frames
      for (let i = 0; i < totalFrames; i++) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = `${frameWidth}px`;
        
        // Create placeholder thumbnail with proper SVG
        const img = document.createElement('div');
        img.className = 'thumbnail-placeholder';
        img.style.cssText = `
          width: 100%;
          height: calc(100% - 20px);
          background: #333;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 4px 4px 0 0;
          color: #fff;
          font-size: 12px;
          font-weight: 600;
        `;
        img.innerHTML = `
          <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M12 1v6M12 17v6M4.22 4.22l4.24 4.24M15.54 15.54l4.24 4.24M1 12h6M17 12h6M4.22 19.78l4.24-4.24M15.54 8.46l4.24-4.24"></path>
          </svg>
        `;
        
        // Create time tick
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = formatTime(i);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek (for WebRTC this is just UI feedback)
        frame.addEventListener('click', () => {
          if (streamTimer) {
            streamTimer.setTime(i);
            console.log(`🎯 WebRTC timeline clicked: ${formatTime(i)}`);
          }
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        container.appendChild(frame);
      }
      
      console.log(`🎬 Generated ${totalFrames} WebRTC timeline frames`);
    }

    // Fetch class information from the backend
    async function fetchClassInfo() {
      try {
        // Get classId from URL parameters or localStorage
        const urlParams = new URLSearchParams(window.location.search);
        classId = urlParams.get('classId') || localStorage.getItem('currentClassId');
        
        // If no class ID, automatically fetch user's assigned class
        if (!classId) {
          console.log('🔍 No class ID provided, fetching user\'s assigned class...');
          classId = await fetchUserAssignedClass();
          
          if (!classId) {
            console.error('❌ No class ID available');
            showErrorMessage('No Class Assignment Found', 'You are not currently enrolled in any classes. Please contact your instructor or check your enrollment status.');
            return;
          }
          
          // Store the fetched class ID for future use
          localStorage.setItem('currentClassId', classId);
          console.log('✅ Auto-assigned to class:', classId);
          
          // Update stream type indicator with class info
          updateStreamTypeIndicator();
        }
        
        const authToken = localStorage.getItem('token');
        const response = await fetch(`/api/stream/status/${classId}`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            console.error('❌ Authentication failed');
            showErrorMessage('Authentication Required', 'You need to log in to access this stream. Please log in and try again.');
            return;
          } else if (response.status === 403) {
            console.error('❌ Access denied');
            showErrorMessage('Access Denied', 'You do not have permission to access this class stream. Please contact your instructor.');
            return;
          } else if (response.status === 404) {
            console.error('❌ Class not found');
            showErrorMessage('Class Not Found', 'The requested class could not be found. Please check the class ID and try again.');
            return;
          }
          throw new Error(`Server returned ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        console.log('📊 Stream status data:', data);
        
        const streamStatus = data.status;
        const currentSource = data.currentSource;

        console.log('📡 Status:', streamStatus);
        console.log('📹 Source:', currentSource);

        // Check if stream is active
        if (streamStatus !== 'live') {
          console.log('⏸️ Stream is not live, waiting for instructor...');
          loading.style.display = 'block';
          
          // Show waiting message after 10 seconds
          setTimeout(() => {
            if (loading.style.display === 'block') {
              showWaitingMessage();
            }
          }, 10000);
          
          // Retry after 3 seconds
          setTimeout(() => fetchClassInfo(), 3000);
          return;
        }

        // Get stream key from class data
        streamKey = data.streamKey;
        
        // Initialize HLS streaming
        await initializeHLSStream(data);
        
        video.addEventListener('canplay', function() {
          loading.style.display = 'none';
        });
        
        video.addEventListener('waiting', function() {
          loading.style.display = 'block';
        });
        
        video.addEventListener('playing', function() {
          loading.style.display = 'none';
        });
        
        // Initialize WebRTC socket for live streaming
        initializeWebRTCSocket();
        
        // Connect to Socket.IO for real-time updates
        if (classId && typeof io !== 'undefined') {
          const socket = io();
          console.log('🔌 Connecting to Socket.IO for class:', classId);
          
          // Join class as student for automatic streaming
          socket.emit('student-join-class', { classId: classId });
          console.log('🎓 Joining class as student:', classId);
          
          socket.on('connect', () => {
            console.log('✅ Socket.IO connected successfully');
            // Re-join class on reconnection
            socket.emit('student-join-class', { classId: classId });
          });
          
          socket.on('disconnect', () => {
            console.log('❌ Socket.IO disconnected');
          });
          
          socket.on('streamStatus', (data) => {
            console.log('📡 Stream status update:', data);
            if (data.status === 'offline') {
              // Stream ended
              if (hlsInstance) {
                hlsInstance.destroy();
                hlsInstance = null;
              }
              video.src = '';
              video.pause();
              loading.style.display = 'block';
            } else if (data.status === 'live') {
              // New stream started
              loading.style.display = 'none';
              

              if (data.source === 'upload' && data.streamUrl) {
                // Switch to uploaded video
                if (hlsInstance) {
                  hlsInstance.destroy();
                  hlsInstance = null;
                }
                video.src = data.streamUrl;
                video.load();
                video.play().catch(e => console.log('Video autoplay prevented:', e));
              } else {
                // Switch to live HLS stream
                const newStreamUrl = `http://198.211.107.134/hls/${streamKey}.m3u8`;
                if (hlsInstance) {
                  hlsInstance.loadSource(newStreamUrl);
                } else if (Hls.isSupported()) {
                  hlsInstance = new Hls({
                    enableWorker: true,
                    lowLatencyMode: true,
                    backBufferLength: 90
                  });
                  hlsInstance.loadSource(newStreamUrl);
                  hlsInstance.attachMedia(video);
                }
              }
            } else if (data.status === 'paused') {
              video.pause();
            }
          });
          
          socket.on('notice', (data) => {
            // Display instructor notice
            console.log('Instructor notice:', data.message);
            // You can add UI to display notices here
          });
        }
        
      } catch (error) {
        console.error('Error fetching class information:', error);
        // Retry after 5 seconds
        setTimeout(() => fetchClassInfo(), 5000);
      }
    }
    
    // Debug information on page load
    console.log('🚀 SMX Stream page loaded');
    console.log('🔍 Checking for class ID and authentication...');
    
    const urlParams = new URLSearchParams(window.location.search);
    const urlClassId = urlParams.get('classId');
    const storedClassId = localStorage.getItem('currentClassId');
    const authToken = localStorage.getItem('token');
    
    console.log('📋 URL Class ID:', urlClassId);
    console.log('💾 Stored Class ID:', storedClassId);
    console.log('🔐 Auth Token:', authToken ? 'Present' : 'Missing');
    
    if (!urlClassId && !storedClassId) {
      console.log('🔍 No class ID found - will automatically fetch user\'s assigned class');
    }
    
    if (!authToken) {
      console.warn('⚠️ No authentication token found - this will likely cause issues');
    }
    
    // Call the function to fetch class info and load the stream
    fetchClassInfo();
    
    // Play/pause toggle - Commented out as button was removed
    // playBtn.addEventListener('click', function() {
    //   if (video.paused) {
    //     video.play();
    //   } else {
    //     video.pause();
    //   }
    //   updatePlayButton();
    // });
    
    // function updatePlayButton() {
    //   playBtn.textContent = video.paused ? 'Play' : 'Pause';
    // }
    // Timeline click functionality for WebRTC with time hashes
    timeline.addEventListener('click', function(e) {
      if (!streamTimer) return;
      
      const rect = timeline.getBoundingClientRect();
      const timelineTrack = document.getElementById('timeline-track');
      
      if (!timelineTrack) return;
      
      // Calculate the actual time position considering the scroll offset
      const clickX = e.clientX - rect.left;
      const timelineWidth = rect.width;
      const trackWidth = timelineTrack.offsetWidth || (streamDuration * currentZoomLevel * 2);
      
      // Account for the current scroll position
      const scrolledClickX = clickX + timelineScrollOffset;
      const timeProgress = scrolledClickX / trackWidth;
      const newTime = Math.max(0, Math.min(streamDuration, timeProgress * streamDuration));
      
      // Pause auto-scrolling temporarily
      isTimelineDragging = true;
      
      // Set the new time
      streamTimer.setTime(newTime);
      
      // Resume auto-scrolling after a short delay
      setTimeout(() => {
        isTimelineDragging = false;
      }, 1000);
      
      console.log(`🎯 WebRTC timeline clicked: seeking to ${formatTime(newTime)}`);
    });
    
    
    // Timeline hover for thumbnail preview - WebRTC only with time hashes
    timeline.addEventListener('mousemove', function(e) {
      const duration = getDuration();
      const timelineTrack = document.getElementById('timeline-track');
      
      if (!duration || !timelineTrack || webrtcThumbnailCache.length === 0) return;
      
      const rect = timeline.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const trackWidth = timelineTrack.offsetWidth || (streamDuration * currentZoomLevel * 2);
      
      // Account for the current scroll position
      const scrolledClickX = clickX + timelineScrollOffset;
      const timeProgress = scrolledClickX / trackWidth;
      const hoverTime = Math.max(0, Math.min(duration, timeProgress * duration));
      
      const thumbnail = getThumbnailForTime(hoverTime);
      if (thumbnail && thumbnailImg && thumbnailTime && thumbnailPreview) {
        thumbnailImg.src = thumbnail.img ? thumbnail.img.src : thumbnail.url;
        thumbnailTime.textContent = formatTime(hoverTime);
        
        // Position the preview
        thumbnailPreview.style.left = clickX + 'px';
        thumbnailPreview.style.display = 'block';
      }
    });
    
    timeline.addEventListener('mouseleave', function() {
      if (thumbnailPreview) {
        thumbnailPreview.style.display = 'none';
      }
    });
    
    // Timeline zoom with mouse wheel
    timeline.addEventListener('wheel', function(e) {
      e.preventDefault();
      
      const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
      zoomTimeline(zoomFactor);
    });
    
    // Helper function to format time
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Fullscreen
    fullscreenBtn.addEventListener('click', function() {
      if (video.requestFullscreen) {
        video.requestFullscreen();
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.msRequestFullscreen) {
        video.msRequestFullscreen();
      }
    });
    
    // ⏩ Playback rate toggle - Commented out as button was removed
    // rateBtn.addEventListener('click', function() {
    //   video.playbackRate = video.playbackRate === 1 ? 2 : video.playbackRate === 2 ? 0.5 : 1;
    //   rateBtn.textContent = video.playbackRate + 'x';
    // });
    
    // 🔄 LIVE button - Commented out as button was removed
    // liveBtn.addEventListener('click', function() {
    //   if (video.duration) {
    //     video.currentTime = video.duration - 0.05;
    //   }
    // });
    
    // Update live status - Commented out as button was removed
    // setInterval(() => {
    //   if (video.duration) {
    //     const live = Math.abs(video.duration - video.currentTime) < 2;
    //     liveBtn.style.display = live ? 'none' : 'inline-block';
    //   }
    // }, 500);
    
    // 📦 Stream mode selector - Commented out as selector was removed
    // streamMode.addEventListener('change', function() {
    //   if (streamMode.value === 'local') {
    //     fileInput.click();
    //   } else {
    //     fetchClassInfo();
    //   }
    // });
    
    fileInput.addEventListener('change', function() {
      const file = fileInput.files[0];
      if (file) {
        if (hlsInstance) {
          hlsInstance.destroy();
          hlsInstance = null;
        }
        const url = URL.createObjectURL(file);
        video.src = url;
        loading.style.display = 'block';
        
        // Generate thumbnails for local file
        video.addEventListener('loadedmetadata', function() {
          generateThumbnails();
        }, { once: true });
      }
    });
    
    // ⌨️ Keyboard shortcuts
    window.addEventListener('keydown', function(e) {
      if (e.key === 'k' || e.key === ' ') {
        e.preventDefault();
        // playBtn.click(); // Commented out as button was removed
        // Toggle play/pause directly
        if (video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
      else if (e.key === 'j') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'l') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 10);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'L') { // Capital L to jump to live
        e.preventDefault();
        jumpToLive();
      }
      else if (e.key === '=' || e.key === '+') { // Zoom in timeline
        e.preventDefault();
        if (window.enhancedTimeline) {
          visibleDuration = Math.max(5, visibleDuration * 0.8);
          zoomLevel = 30 / visibleDuration;
          window.enhancedTimeline.render();
        }
      }
      else if (e.key === '-') { // Zoom out timeline
        e.preventDefault();
        if (window.enhancedTimeline && window.enhancedTimeline.video) {
          visibleDuration = Math.min(window.enhancedTimeline.video.duration || 300, visibleDuration * 1.2);
          zoomLevel = 30 / visibleDuration;
          window.enhancedTimeline.render();
        }
      }
      else if (e.key === '0') { // Reset timeline zoom
        e.preventDefault();
        resetTimelineZoom();
      }
      else if (e.key === 'f') {
        // fullscreenBtn.click(); // Commented out as button was removed
        // Request fullscreen directly
        if (video.requestFullscreen) {
          video.requestFullscreen();
        } else if (video.webkitRequestFullscreen) {
          video.webkitRequestFullscreen();
        } else if (video.msRequestFullscreen) {
          video.msRequestFullscreen();
        }
      }
      else if (e.key === 'm') {
        webrtcVideo.muted = !webrtcVideo.muted;
      }
      else if (e.key === 'ArrowLeft') {
        if (streamTimer) {
          const newTime = Math.max(0, streamTimer.currentTime - 5);
          streamTimer.setTime(newTime);
        }
      }
      else if (e.key === 'ArrowRight') {
        if (streamTimer) {
          const newTime = Math.min(streamDuration, streamTimer.currentTime + 5);
          streamTimer.setTime(newTime);
        }
      }
    });
    
    // Enhanced video event listeners
    video.addEventListener('playing', function() {
      loading.style.display = 'none';
      // playBtn.textContent = 'Pause'; // Commented out as button was removed
    });
    
    video.addEventListener('pause', function() {
      // playBtn.textContent = 'Play'; // Commented out as button was removed
    });

    // Advanced Video Timeline Component
    class VideoTimeline {
      constructor(videoId, timelineId) {
        console.log('VideoTimeline constructor called with:', videoId, timelineId);
        this.video = document.getElementById(videoId);
        this.timeline = document.getElementById(timelineId);
        this.scrubber = document.getElementById('scrubber');
        console.log('Elements found:', {
          video: this.video,
          timeline: this.timeline,
          scrubber: this.scrubber
        });
        this.thumbnails = [];
        this.zoomLevel = 1;
        this.visibleDuration = 60; // seconds visible at zoom level 1
        this.thumbnailInterval = 2; // seconds between thumbnails
        this.isDragging = false;
        this.dragStartX = 0;
        this.dragStartTime = 0;
        
        this.init();
      }

      init() {
        console.log('VideoTimeline init called');
        if (!this.video || !this.timeline) {
          console.log('Missing video or timeline element');
          return;
        }
        
        // Create basic timeline structure immediately
        this.createBasicTimeline();
        
        // Wait for video metadata to load
        this.video.addEventListener('loadedmetadata', () => {
          console.log('Video metadata loaded, generating thumbnails');
          this.generateThumbnails();
          this.setupEventListeners();
        });

        // If metadata is already loaded
        if (this.video.readyState >= 1) {
          console.log('Video metadata already loaded');
          this.generateThumbnails();
          this.setupEventListeners();
        }
      }

      createBasicTimeline() {
        console.log('Creating basic timeline structure');
        // Create a basic timeline with time markers even without video duration
        const container = document.createElement('div');
        container.className = 'timeline-container';
        container.id = 'timeline-container';
        this.timeline.appendChild(container);
        
        // Add some basic time markers (0, 30s, 1min, etc.)
        for (let time = 0; time <= 300; time += 30) { // 5 minutes worth
          const frame = this.createTimeMarker(time);
          container.appendChild(frame);
        }
      }

      createTimeMarker(time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        frame.style.width = '80px';
        frame.style.minWidth = '80px';
        
        // Create a simple placeholder
        const placeholder = document.createElement('div');
        placeholder.style.width = '100%';
        placeholder.style.height = 'calc(100% - 20px)';
        placeholder.style.background = 'linear-gradient(135deg, #1e293b, #0f172a)';
        placeholder.style.borderRadius = '4px 4px 0 0';
        placeholder.style.display = 'flex';
        placeholder.style.alignItems = 'center';
        placeholder.style.justifyContent = 'center';
        placeholder.style.color = '#70b8ff';
        placeholder.style.fontSize = '10px';
        placeholder.textContent = this.formatTime(time);
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(placeholder);
        frame.appendChild(tick);
        
        return frame;
      }

      async generateThumbnails() {
        console.log('generateThumbnails called');
        const duration = this.video.duration;
        console.log('Video duration:', duration);
        if (!duration) {
          console.log('No duration available, skipping thumbnail generation');
          return;
        }

        // Clear existing container and create new one for thumbnails
        const existingContainer = this.timeline.querySelector('.timeline-container');
        if (existingContainer) {
          existingContainer.remove();
        }
        
        const container = document.createElement('div');
        container.className = 'timeline-container';
        this.timeline.appendChild(container);
        console.log('Timeline container created and added');

        // Generate thumbnails every 2 seconds
        for (let time = 0; time < duration; time += this.thumbnailInterval) {
          console.log('Generating thumbnail for time:', time);
          const thumbnail = await this.captureThumbnail(time);
          const frame = this.createThumbnailFrame(thumbnail, time);
          container.appendChild(frame);
          this.thumbnails.push({ element: frame, time: time });
        }

        console.log('Generated', this.thumbnails.length, 'thumbnails');
        this.updateTimelineWidth();
      }

      async captureThumbnail(time) {
        return new Promise((resolve) => {
          // For now, create a placeholder thumbnail
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = 160;
          canvas.height = 90;
          
          // Create a simple gradient placeholder
          const gradient = ctx.createLinearGradient(0, 0, 160, 90);
          gradient.addColorStop(0, '#1e293b');
          gradient.addColorStop(1, '#0f172a');
          ctx.fillStyle = gradient;
          ctx.fillRect(0, 0, 160, 90);
          
          // Add time text
          ctx.fillStyle = '#70b8ff';
          ctx.font = '12px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(this.formatTime(time), 80, 50);
          
          resolve(canvas.toDataURL());
        });
      }

      createThumbnailFrame(thumbnailSrc, time) {
        const frame = document.createElement('div');
        frame.className = 'thumbnail-frame';
        
        const img = document.createElement('img');
        img.src = thumbnailSrc;
        img.alt = `Frame at ${this.formatTime(time)}`;
        
        const tick = document.createElement('div');
        tick.className = 'time-tick';
        tick.textContent = this.formatTime(time);
        
        frame.appendChild(img);
        frame.appendChild(tick);
        
        // Click to seek
        frame.addEventListener('click', () => {
          this.video.currentTime = time;
        });
        
        // Double-click to jump to live
        frame.addEventListener('dblclick', () => {
          jumpToLive();
        });
        
        return frame;
      }

      setupEventListeners() {
        // Update scrubber position on time update (only when not dragging)
        this.video.addEventListener('timeupdate', () => {
          if (!this.isDragging) {
            this.updateScrubberPosition();
          }
        });

        // Zoom with mouse wheel
        this.timeline.addEventListener('wheel', (e) => {
          e.preventDefault();
          const zoomFactor = e.deltaY > 0 ? 0.8 : 1.25;
          this.zoomLevel *= zoomFactor;
          this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
          this.updateTimelineWidth();
        });

        // Scrubber drag functionality
        this.setupScrubberDrag();

        // Click on timeline to seek
        this.timeline.addEventListener('click', (e) => {
          if (e.target === this.timeline || e.target.classList.contains('timeline-container')) {
            this.seekToPosition(e);
          }
        });
      }

      setupScrubberDrag() {
        // Mouse events
        this.scrubber.addEventListener('mousedown', (e) => {
          this.startDrag(e);
        });

        document.addEventListener('mousemove', (e) => {
          if (this.isDragging) {
            this.handleDrag(e);
          }
        });

        document.addEventListener('mouseup', () => {
          this.endDrag();
        });

        // Touch events for mobile
        this.scrubber.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.startDrag(e.touches[0]);
        });

        document.addEventListener('touchmove', (e) => {
          if (this.isDragging) {
            e.preventDefault();
            this.handleDrag(e.touches[0]);
          }
        });

        document.addEventListener('touchend', () => {
          this.endDrag();
        });
      }

      startDrag(event) {
        this.isDragging = true;
        this.dragStartX = event.clientX;
        this.dragStartTime = this.video.currentTime;
        this.scrubber.classList.add('dragging');
        
        // Pause video during drag for smoother scrubbing
        this.wasPlaying = !this.video.paused;
        this.video.pause();
      }

      handleDrag(event) {
        if (!this.isDragging) return;

        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        // Calculate new time based on position
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        // Update video time and scrubber position
        this.video.currentTime = newTime;
        this.updateScrubberPosition();
        
        // Show time tooltip during drag
        this.showTimeTooltip(event.clientX, newTime);
      }

      endDrag() {
        if (!this.isDragging) return;
        
        this.isDragging = false;
        this.scrubber.classList.remove('dragging');
        this.hideTimeTooltip();
        
        // Resume playback if it was playing before drag
        if (this.wasPlaying) {
          this.video.play();
        }
      }

      seekToPosition(event) {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;

        const timelineRect = this.timeline.getBoundingClientRect();
        const relativeX = event.clientX - timelineRect.left + this.timeline.scrollLeft;
        const timelineWidth = container.offsetWidth;
        
        const progress = Math.max(0, Math.min(1, relativeX / timelineWidth));
        const newTime = progress * this.video.duration;
        
        this.video.currentTime = newTime;
      }

      showTimeTooltip(x, time) {
        let tooltip = document.getElementById('scrubber-tooltip');
        if (!tooltip) {
          tooltip = document.createElement('div');
          tooltip.id = 'scrubber-tooltip';
          tooltip.style.cssText = `
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-family: monospace;
            pointer-events: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(233, 30, 99, 0.2);
          `;
          document.body.appendChild(tooltip);
        }
        
        tooltip.textContent = this.formatTime(time);
        tooltip.style.left = `${x - 25}px`;
        tooltip.style.top = `${this.timeline.getBoundingClientRect().top - 30}px`;
        tooltip.style.display = 'block';
      }

      hideTimeTooltip() {
        const tooltip = document.getElementById('scrubber-tooltip');
        if (tooltip) {
          tooltip.style.display = 'none';
        }
      }

      updateScrubberPosition() {
        if (!this.video.duration) return;
        
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const progress = this.video.currentTime / this.video.duration;
        const timelineWidth = container.offsetWidth;
        const scrubberPosition = progress * timelineWidth;
        
        this.scrubber.style.left = `${scrubberPosition}px`;
        
        // Auto-scroll to keep scrubber visible (only when not dragging)
        if (!this.isDragging) {
          const timelineScrollLeft = this.timeline.scrollLeft;
          const timelineVisibleWidth = this.timeline.offsetWidth;
          
          if (scrubberPosition < timelineScrollLeft || scrubberPosition > timelineScrollLeft + timelineVisibleWidth) {
            this.timeline.scrollLeft = scrubberPosition - timelineVisibleWidth / 2;
          }
        }
      }

      updateTimelineWidth() {
        const container = this.timeline.querySelector('.timeline-container');
        if (!container) return;
        
        const frameWidth = 160 * this.zoomLevel;
        const totalFrames = this.thumbnails.length;
        const totalWidth = totalFrames * frameWidth;
        
        container.style.minWidth = `${totalWidth}px`;
        
        // Update frame widths
        this.thumbnails.forEach(({ element }) => {
          element.style.width = `${frameWidth}px`;
        });
      }

      formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, '0')}`;
      }

      zoom(factor) {
        this.zoomLevel *= factor;
        this.zoomLevel = Math.max(0.1, Math.min(10, this.zoomLevel));
        this.updateTimelineWidth();
      }
    }

    // Global variables for new functionality
    let zoomEnabled = false;
    let isDraggingScrubber = false;
    let scrubberCentered = true;

    // Global functions for video controls
    function togglePlayPause() {
      const playPauseBtn = document.getElementById('playPauseBtn');
      
      if (isWebRTCMode && streamTimer) {
        // For WebRTC, toggle the stream timer
        if (streamTimer.isPaused) {
          streamTimer.resume();
          playPauseBtn.textContent = '⏸';
          console.log('▶️ WebRTC stream timer resumed');
        } else {
          streamTimer.pause();
          playPauseBtn.textContent = '▶';
          console.log('⏸️ WebRTC stream timer paused');
        }
      } else {
        // For regular video
        const video = document.getElementById('video');
        if (video.paused) {
          video.play();
          playPauseBtn.textContent = '⏸';
        } else {
          video.pause();
          playPauseBtn.textContent = '▶';
        }
      }
    }

    function rewindVideoClean(seconds = 10) {
      // Clean HLS rewind functionality - shift video currentTime as specified
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video && video.duration) {
        const newTime = Math.max(0, video.currentTime - seconds);
        video.currentTime = newTime;
        console.log(`⏪ HLS rewind ${seconds}s to ${newTime.toFixed(1)}s`);
        
        const timeLabel = seconds >= 60 ? Math.floor(seconds/60) + 'm' : seconds + 's';
        if (typeof showNotification === 'function') {
          showNotification(`Rewound ${timeLabel}`, 'info');
        }
      }
    }

    function forwardVideo() {
      // Clean HLS forward functionality
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video && video.duration) {
        video.currentTime = Math.min(video.duration, video.currentTime + 10);
        console.log(`⏩ HLS forward 10s to ${video.currentTime.toFixed(1)}s`);
      }
    }



    function zoomTimeline(factor) {
      if (window.videoTimeline) {
        window.videoTimeline.zoom(factor);
      }
    }

    // Update time display
    function updateTimeDisplay() {
      const video = document.getElementById('video');
      const currentTimeEl = document.getElementById('currentTime');
      const totalTimeEl = document.getElementById('totalTime');
      
      if (currentTimeEl && totalTimeEl) {
        currentTimeEl.textContent = formatTime(video.currentTime);
        totalTimeEl.textContent = formatTime(video.duration || 0);
      }
    }

    // formatTime function is defined earlier in the file

    // Initialize advanced timeline
    setTimeout(() => {
      console.log('Initializing VideoTimeline...');
      window.videoTimeline = new VideoTimeline('video', 'timeline');
      console.log('VideoTimeline initialized:', window.videoTimeline);
      
      // Set up video event listeners for time display
      const video = document.getElementById('video');
      if (video) {
        video.addEventListener('timeupdate', () => {
          updateTimeDisplay();
          updateTimelineViewport();
        });
        video.addEventListener('loadedmetadata', () => {
          updateTimeDisplay();
          if (window.enhancedTimeline) {
            // Reset timeline when new video loads
            resetTimelineZoom();
            window.enhancedTimeline.render();
          }
        });
        video.addEventListener('play', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>⏸</span>';
        });
        video.addEventListener('pause', () => {
          const btn = document.querySelector('.play-pause-btn');
          if (btn) btn.innerHTML = '<span>▶</span>';
        });
      }
    }, 1000);
    
    // ===== GLOBAL VARIABLES =====
    let isStreamActive = false;
    let pauseTimeout = null;
    let streamTimer = null;
    
    // ===== VIDEO CONTROL FUNCTIONS =====
    function togglePlayPause() {
      const video = document.getElementById('video');
      const webrtcVideo = document.getElementById('webrtcVideo');
      const activeVideo = video.style.display !== 'none' ? video : webrtcVideo;
      const playPauseBtn = document.querySelector('.play-pause-btn');
      
      if (activeVideo === video && video.src) {
        // Regular video controls
        if (video.paused) {
          video.play().catch(e => console.log('Play prevented:', e));
          playPauseBtn.innerHTML = Icons.pause;
        } else {
          video.pause();
          playPauseBtn.innerHTML = Icons.play;
        }
      } else if (streamTimer) {
        // For WebRTC, we can't actually pause the stream, but we can pause our timer
        if (!streamTimer.isPaused) {
          streamTimer.pause();
          playPauseBtn.innerHTML = Icons.play;
          console.log('⏸️ WebRTC stream timer paused');
        } else {
          streamTimer.resume();
          playPauseBtn.innerHTML = Icons.pause;
          console.log('▶️ WebRTC stream timer resumed');
        }
      }
    }

    function rewindVideo(seconds = 10) {
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video && video.duration) {
        const newTime = Math.max(0, video.currentTime - seconds);
        video.currentTime = newTime;
        console.log(`⏪ Rewind ${seconds}s to ${newTime.toFixed(1)}s`);
      }
    }

    function forwardVideo() {
      const video = document.getElementById('video');
      if (video.src) {
        video.currentTime = Math.min(video.duration || 0, video.currentTime + 10);
      }
    }
    
    function jumpToLive() {
      // Jump to live edge of HLS stream
      const video = document.getElementById('hlsVideo') || document.getElementById('video');
      if (video && video.duration) {
        video.currentTime = video.duration;
        console.log('🔴 Jumped to live edge:', video.duration);
        showNotification('Jumped to live edge', 'success');
      }
    }
    
    function toggleZoomMode() {
      // Toggle timeline zoom functionality
      if (zoomLevel === 1) {
        zoomLevel = 2;
        visibleDuration = 15;
      } else {
        zoomLevel = 1;
        visibleDuration = 30;
      }
      
      if (window.enhancedTimeline) {
        window.enhancedTimeline.render();
      }
      
      const btn = document.getElementById('zoomToggleBtn');
      if (btn) {
        btn.textContent = zoomLevel === 1 ? 'Zoom' : 'Zoom Out';
      }
    }
    
    function toggleFullscreen() {
      const videoContainer = document.querySelector('.video-container');
      
      if (!document.fullscreenElement) {
        videoContainer.requestFullscreen().catch(err => {
          console.log('Fullscreen error:', err);
        });
      } else {
        document.exitFullscreen();
      }
    }
    
    function updatePlayPauseButton(showPlay) {
      const btn = document.querySelector('.play-pause-btn');
      if (btn) {
        btn.innerHTML = showPlay ? Icons.play : Icons.pause;
      }
    }
    
    // ===== NOTIFICATION SYSTEM =====
    function showNotification(message, type = 'info') {
      // Create notification element
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.textContent = message;
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#22c55e' : type === 'error' ? '#ef4444' : '#3b82f6'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 10000;
        font-weight: 500;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        animation: slideIn 0.3s ease;
      `;
      
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        notification.style.animation = 'slideOut 0.3s ease';
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 300);
      }, 3000);
    }
    
    // ===== INITIALIZATION =====
    function initializeApp() {
      console.log('🚀 Initializing SMX Stream application...');
      
      // Extract classId from URL parameters
      const urlParams = new URLSearchParams(window.location.search);
      classId = urlParams.get('classId') || urlParams.get('class') || 'demo-class';
      console.log('📋 Class ID:', classId);
      
      // Detect user role
      detectUserRole();
      
      // Initialize Socket.IO connection
      initializeSocket();
      
      // Initialize enhanced timeline
      if (document.getElementById('timelineCanvas')) {
        window.enhancedTimeline = new EnhancedTimeline('timelineCanvas', 'video');
      }
      
      // Initialize screenshot feature
      initializeScreenshotFeature();
      
      // Initialize live edge enforcement for students
      if (!isInstructor) {
        initializeLiveEdgeEnforcement();
      }
      
      // Show welcome modal
      showWelcomeModal();
      
      // Set up HLS video error handling
      const hlsVideo = document.getElementById('hlsVideo');
      
      if (hlsVideo) {
        hlsVideo.addEventListener('error', (e) => {
          console.error('❌ HLS video error:', e);
          showStreamStatusOverlay('Stream loading error - Please refresh');
        });
        
        hlsVideo.addEventListener('loadstart', () => {
          console.log('📺 HLS video loading started');
        });
        
        hlsVideo.addEventListener('canplay', () => {
          console.log('📺 HLS video can start playing');
          hideStreamStatusOverlay();
        });
        
        // Set as current video
        currentVideo = hlsVideo;
      }
      
      // Initialize clean HLS streaming (as specified)
      if (classId && classId !== 'demo-class') {
        console.log('🎬 Initializing clean HLS for class:', classId);
        setTimeout(() => {
          initializeCleanHLS();
        }, 1000);
      }
      
      // Check for existing stream state
      setTimeout(() => {
        checkStreamState();
      }, 2000);
      
      console.log('✅ SMX Stream application initialized');
    }
    
    // ===== KEYBOARD SHORTCUTS =====
    document.addEventListener('keydown', (e) => {
      // Don't trigger shortcuts if user is typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
      }
      
      switch (e.key.toLowerCase()) {
        case ' ':
        case 'k':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'j':
          e.preventDefault();
          rewindVideo();
          break;
        case 'l':
          e.preventDefault();
          if (e.shiftKey) {
            jumpToLive();
          } else {
            forwardVideo();
          }
          break;
        case 'f':
          e.preventDefault();
          toggleFullscreen();
          break;
        case 'arrowleft':
          e.preventDefault();
          rewindVideo();
          break;
        case 'arrowright':
          e.preventDefault();
          forwardVideo();
          break;
      }
    });
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }
    
  </script>
</body>
</html>