<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>SMX Stream Control Center</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="https://fonts.googleapis.com/css?family=Inter:400,600,700&display=swap" rel="stylesheet">
  <script src="/socket.io/socket.io.js"></script>
  <style>
    :root {
      --primary: #0f172a;
      --secondary: #1e293b;
      --tertiary: #334155;
      --accent: #dc2626;
      --accent-hover: #b91c1c;
      --accent-light: rgba(220, 38, 38, 0.1);
      --accent-glow: rgba(220, 38, 38, 0.3);
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --text-muted: #64748b;
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --border: #475569;
      --border-light: #334155;
      --glass: rgba(15, 23, 42, 0.8);
      --shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      --gradient-primary: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      --gradient-accent: linear-gradient(135deg, var(--accent) 0%, var(--accent-hover) 100%);
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: var(--gradient-primary);
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
      line-height: 1.6;
    }
    
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
    }
    
    ::-webkit-scrollbar-track {
      background: var(--secondary);
    }
    
    ::-webkit-scrollbar-thumb {
      background: var(--tertiary);
      border-radius: 4px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: var(--border);
    }
    /* Header */
    .header {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border-light);
      padding: 1.5rem 2rem;
      position: sticky;
      top: 0;
      z-index: 100;
    }
    
    .header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .header-title {
      font-size: 1.75rem;
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .header-icon {
      width: 2.5rem;
      height: 2.5rem;
      background: var(--gradient-accent);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.25rem;
      box-shadow: var(--shadow);
    }
    
    .status-section {
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    
    .status-badge {
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-weight: 600;
      font-size: 0.875rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      border: 2px solid;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .status-badge::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.5s;
    }
    
    .status-badge:hover::before {
      left: 100%;
    }
    
    .status-live { 
      color: var(--accent); 
      border-color: var(--accent);
      background: var(--accent-light);
      animation: pulse-live 2s infinite;
    }
    
    .status-offline { 
      color: var(--text-muted); 
      border-color: var(--border);
      background: rgba(100, 116, 139, 0.1);
    }
    
    @keyframes pulse-live {
      0%, 100% { box-shadow: 0 0 0 0 var(--accent-glow); }
      50% { box-shadow: 0 0 0 10px transparent; }
    }
    
    /* Main Container */
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 2rem;
    }
    /* Main Layout */
    .main-layout {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    
    @media (max-width: 1200px) {
      .main-layout {
        grid-template-columns: 1fr;
      }
    }
    
    /* Cards */
    .card {
      background: var(--secondary);
      border-radius: 20px;
      border: 1px solid var(--border-light);
      box-shadow: var(--shadow);
      overflow: hidden;
      transition: all 0.3s ease;
    }
    
    .card:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
      border-color: var(--accent);
    }
    
    .card-header {
      padding: 1.5rem 2rem;
      border-bottom: 1px solid var(--border-light);
      background: var(--glass);
      backdrop-filter: blur(10px);
    }
    
    .card-title {
      font-size: 1.25rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .card-icon {
      width: 2rem;
      height: 2rem;
      background: var(--accent-light);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 1rem;
    }
    
    .card-content {
      padding: 2rem;
    }
    
    /* Stream Control Card */
    .stream-control-card {
      grid-column: 1;
    }
    
    /* Video Preview */
    .video-preview-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      border-radius: 16px;
      overflow: hidden;
      background: var(--primary);
      border: 2px solid var(--border-light);
      transition: all 0.3s ease;
    }
    
    .video-preview-container:hover {
      border-color: var(--accent);
      box-shadow: 0 0 30px var(--accent-glow);
    }
    .video-preview {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 14px;
    }
    
    .video-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: var(--text-muted);
      font-size: 1.125rem;
      font-weight: 500;
    }
    
    .video-placeholder-icon {
      width: 4rem;
      height: 4rem;
      background: var(--accent-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 2rem;
      margin-bottom: 1rem;
    }
    
    .video-ready-indicator {
      position: absolute;
      top: 1rem;
      right: 1rem;
      background: var(--success);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 50px;
      font-size: 0.875rem;
      font-weight: 600;
      display: none;
    }
    
    /* Class Selection */
    .class-selection {
      margin-bottom: 2rem;
    }
    
    .class-select {
      width: 100%;
      background: var(--tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-light);
      padding: 1rem 1.25rem;
      font-size: 1rem;
      border-radius: 12px;
      font-family: inherit;
      transition: all 0.3s ease;
    }
    
    .class-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px var(--accent-light);
    }
    
    /* Stream Controls */
    .stream-controls {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
      flex-wrap: wrap;
      align-items: center;
    }
    
    /* Buttons */
    .btn {
      padding: 0.875rem 1.5rem;
      border: none;
      border-radius: 12px;
      font-size: 0.875rem;
      font-weight: 600;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.5s;
    }
    
    .btn:hover::before {
      left: 100%;
    }
    
    .btn-primary {
      background: var(--gradient-accent);
      color: white;
      box-shadow: var(--shadow);
    }
    
    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }
    
    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .btn-secondary {
      background: var(--tertiary);
      color: var(--text-primary);
      border: 2px solid var(--border-light);
    }
    
    .btn-secondary:hover {
      background: var(--border);
      border-color: var(--accent);
    }
    
    .btn-danger {
      background: linear-gradient(135deg, var(--error) 0%, #dc2626 100%);
      color: white;
    }
    
    .btn-danger:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(239, 68, 68, 0.3);
    }
    
    .btn-full {
      width: 100%;
      justify-content: center;
    }
    
    /* File Upload */
    .file-upload-area {
      border: 2px dashed var(--border-light);
      border-radius: 16px;
      padding: 3rem 2rem;
      text-align: center;
      transition: all 0.3s ease;
      cursor: pointer;
      background: var(--glass);
      backdrop-filter: blur(10px);
    }
    
    .file-upload-area:hover,
    .file-upload-area.drag-over {
      border-color: var(--accent);
      background: var(--accent-light);
      transform: translateY(-2px);
    }
    
    .file-upload-icon {
      width: 4rem;
      height: 4rem;
      background: var(--accent-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 2rem;
      margin: 0 auto 1rem;
    }
    
    .file-upload-text {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }
    
    .file-upload-hint {
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    
    .file-info {
      background: var(--tertiary);
      border-radius: 12px;
      padding: 1rem;
      margin-top: 1rem;
      display: none;
    }
    
    .file-info.show {
      display: block;
    }
    
    .file-name {
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 0.5rem;
    }
    
    .file-details {
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    
    /* Sidebar */
    .sidebar-card {
      grid-column: 2;
    }
    

    
    /* Viewer Count */
    .viewer-count {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--text-muted);
      font-size: 0.875rem;
    }
    
    .viewer-count-icon {
      width: 1.5rem;
      height: 1.5rem;
      background: var(--accent-light);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
      font-size: 0.75rem;
    }
    .controls-row {
      display: flex;
      gap: 18px;
      align-items: center;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    .control-btn {
      background: var(--accent);
      color: #fff;
      border: none;
      border-radius: 9px;
      padding: 0.6em 2.3em;
      font-size: 1.04rem;
      font-weight: 600;
      cursor: pointer;
      transition: background .17s;
      box-shadow: 0 2px 12px #2172aa33;
    }
    .control-btn:active { background: var(--accent-fade); }
    .control-btn.paused { background: var(--paused); color: #2a2a13;}
    .control-btn.stop { background: var(--error); }
    .control-btn[disabled] { opacity: .64; cursor: not-allowed; }
    .viewers-label {
      margin-left: 20px;
      color: var(--text-secondary);
      font-size: 1.04rem;
      font-weight: 600;
    }
    .file-drop {
      border: 2px dashed var(--accent);
      border-radius: 12px;
      padding: 40px 20px;
      background: linear-gradient(135deg, var(--main-bg) 0%, #0f1520 100%);
      color: var(--accent);
      text-align: center;
      font-size: 1.1rem;
      margin-bottom: 18px;
      cursor: pointer;
      transition: all .2s ease;
      position: relative;
      overflow: hidden;
    }
    .file-drop::before {
      content: '⬆';
      font-size: 2.5rem;
      display: block;
      margin-bottom: 12px;
      opacity: 0.7;
    }
    .file-drop:hover {
      background: linear-gradient(135deg, #0f1520 0%, var(--main-bg) 100%);
      border-color: var(--success);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(69, 162, 255, 0.15);
    }
    .file-drop.dragover { 
      background: linear-gradient(135deg, #16203b 0%, #1a2540 100%); 
      border-color: var(--success);
      transform: scale(1.02);
      box-shadow: 0 12px 35px rgba(17, 227, 139, 0.2);
    }
    .file-drop.dragover::before {
      content: '⬇';
      animation: bounce 0.6s infinite alternate;
    }
    .file-drop.has-file {
      border-color: var(--success);
      background: linear-gradient(135deg, #0a1a0a 0%, #0f1f0f 100%);
    }
    .file-drop.has-file::before {
      content: '🎬';
      color: var(--success);
    }
    .file-drop.has-file:hover {
      border-color: var(--accent);
      transform: translateY(-2px);
    }
    .file-drop.dragging {
      opacity: 0.7;
      transform: rotate(3deg) scale(0.95);
    }
    @keyframes bounce {
      0% { transform: translateY(0); }
      100% { transform: translateY(-8px); }
    }
    .file-browse-text {
      color: var(--success);
      text-decoration: underline;
      font-weight: 600;
      cursor: pointer;
      transition: color .2s;
    }
    .file-browse-text:hover {
      color: #00ff88;
    }
    .upload-status {
      margin-top: 15px;
      font-size: 0.95rem;
      font-weight: 500;
      min-height: 20px;
      color: var(--text-secondary);
    }
    .upload-status.success {
      color: var(--success);
    }
    .upload-status.error {
      color: var(--error);
    }
    .upload-status.info {
      color: var(--accent);
    }
    .progress-bar {
      background: #112233;
      border-radius: 8px;
      height: 12px;
      width: 100%;
      margin: 15px 0 8px 0;
      overflow: hidden;
      box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent) 0%, var(--success) 100%);
      width: 0;
      transition: width .4s ease;
      border-radius: 8px;
      position: relative;
    }
    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%);
      animation: shimmer 2s infinite;
    }
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    .file-info {
      background: var(--control-bg);
      border-radius: 8px;
      padding: 12px 16px;
      margin-top: 12px;
      border-left: 4px solid var(--accent);
      display: none;
      cursor: grab;
      transition: all 0.2s ease;
    }
    .file-info.show {
      display: block;
      animation: slideIn 0.3s ease;
    }
    .file-info:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 15px rgba(69, 162, 255, 0.2);
    }
    .file-info.dragging {
      cursor: grabbing;
      opacity: 0.7;
      transform: rotate(5deg) scale(0.95);
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .file-info-title {
      font-weight: 600;
      color: var(--text-main);
      margin-bottom: 4px;
    }
    .file-info-details {
      color: var(--text-secondary);
      font-size: 0.9rem;
    }

    /* Right Panel */
    .settings-section {
      margin-bottom: 30px;
      background: var(--control-bg);
      border-radius: 8px;
      padding: 14px 17px;
      box-shadow: 0 2px 8px #0213231e;
    }
    .settings-title {
      font-weight: 700;
      color: var(--text-main);
      font-size: 1.08rem;
      margin-bottom: 8px;
    }
    .settings-row {
      margin-bottom: 8px;
      color: var(--text-secondary);
      font-size: 0.98rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    /* Stream Source Tabs */
    .stream-source-tabs {
      display: flex;
      gap: 8px;
      margin-bottom: 15px;
    }
    .source-tab {
      background: var(--control-bg);
      color: var(--text-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.5em 1.2em;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      flex: 1;
    }
    .source-tab:hover {
      background: var(--panel-bg);
      color: var(--text-main);
    }
    .source-tab.active {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    

    
    /* Live video styling */
    #liveVideo {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: var(--rounded);
    }

    @media (max-width: 1000px) {
      .main-panel { flex-direction: column; gap: 18px;}
      .right-panel { max-width: 100%;}
    }
    @media (max-width: 700px) {
      .left-panel, .right-panel { min-width: unset; padding: 14px 5vw;}
      .container { padding: 18px 0 28px 0;}
      .stream-source-tabs { flex-direction: column; }

    }

    /* Server Uploads Section */
    .server-uploads {
      margin-top: 12px;
      padding: 12px;
      background: var(--control-bg);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    .upload-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid var(--border);
    }
    .upload-item:last-child {
      border-bottom: none;
    }
    .upload-item button {
      background: var(--error);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.4em 0.8em;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background 0.2s;
    }
    .upload-item button:hover {
      background: #e03e3e;
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <div class="header-content">
      <div class="header-title">
        <div class="header-icon">🎥</div>
        Stream Control Center
      </div>
      <div class="status-section">
        <div class="viewer-count">
          <div class="viewer-count-icon">👥</div>
          <span id="viewerCount">0</span> viewers
        </div>
        <div class="status-badge status-offline" id="streamStatus">OFFLINE</div>
      </div>
    </div>
  </header>

  <!-- Main Container -->
  <div class="container">
    <div class="main-layout">
      <!-- Stream Control Card -->
      <div class="card stream-control-card">
        <div class="card-header">
          <div class="card-title">
            <div class="card-icon">🎬</div>
            Stream Setup
          </div>
        </div>
        <div class="card-content">
          <!-- Class Selection -->
          <div class="class-selection">
            <label for="classSelect" style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--text-secondary);">Select Class</label>
            <select id="classSelect" class="class-select">
              <option value="">Choose your class...</option>
              <!-- Dynamically populated -->
            </select>
          </div>

          <!-- Video Preview -->
          <div class="video-preview-container" id="videoPreview">
            <div class="video-placeholder">
              <div class="video-placeholder-icon">📹</div>
              <div>Upload a video or start live streaming</div>
            </div>
            <video id="previewVideo" class="video-preview" style="display:none;" controls></video>
            <video id="liveVideo" class="video-preview" style="display:none;" autoplay muted playsinline></video>
            <div class="video-ready-indicator" id="videoReady">✅ Ready to Stream</div>
          </div>

          <!-- Stream Controls -->
          <div class="stream-controls">
            <button class="btn btn-primary btn-full" id="goLiveBtn">
              � Go Live
            </button>
            <button class="btn btn-danger btn-full" id="stopBtn" disabled>
              ⏹️ End Stream
            </button>
            <button class="btn btn-secondary" id="startCameraBtn" style="display:none;">
              📹 Camera
            </button>
            <button class="btn btn-secondary" id="startScreenBtn" style="display:none;">
              �️ Screen Share
            </button>
            <button class="btn btn-danger" id="stopMediaBtn" style="display:none;">
              ⏹️ Stop Media
            </button>
          </div>
        </div>
      </div>
      <!-- Right: File Upload and Info -->
      <div class="right-panel">
        <div class="panel-section">
          <div class="section-title">Upload Video</div>
          <div class="file-drop" id="fileDrop">
            <input type="file" id="fileInput" accept="video/mp4" style="display:none;">
            <div><strong>Drop your MP4 video here</strong></div>
            <div style="margin-top: 8px; font-size: 0.95rem; opacity: 0.8;">
              or <span class="file-browse-text" id="fileBrowse">click to browse</span>
            </div>
            <div style="margin-top: 12px; font-size: 0.85rem; opacity: 0.6;">
              Maximum file size: 4GB • Auto-deleted after 24 hours
            </div>
            <div style="margin-top: 8px; font-size: 0.85rem; color: var(--accent); font-weight: 500;">
              📋 Workflow: Upload file → Drag to video player → Upload to server → Go Live
            </div>
            <div class="drag-instruction" id="dragInstruction" style="margin-top: 8px; font-size: 0.8rem; color: var(--success); display: none;">
              💡 You can drag this area to the video player to load the file
            </div>
          </div>
          <div class="upload-status" id="uploadStatus"></div>
          <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
          <div class="file-info" id="fileInfo">
            <div class="file-info-title" id="fileInfoTitle"></div>
            <div class="file-info-details" id="fileInfoDetails"></div>
            <div class="drag-hint" id="dragHint" style="font-size:0.8rem; color:var(--accent); margin-top:8px; display:none;">
              🎬 Drag this to the video player to load it
            </div>
            <button class="control-btn" id="uploadBtn" style="width:100%; margin-top:12px; display:none;">📤 Upload to Server (Required for Streaming)</button>
          </div>
        </div>
        <div class="settings-section">
          <div class="settings-title">Stream Information</div>
          <div class="settings-row">Class: <span id="classLabel">Not selected</span></div>
          <div class="settings-row">Status: <span id="streamStatusInfo">Offline</span></div>
          <div class="settings-row">Viewers: <span id="viewerCountInfo">0</span></div>
        </div>
        <!-- Add a section to display submitted files -->
        <div class="panel-section">
          <div class="section-title">Submitted Files</div>
          <div id="submittedFiles" class="server-uploads">
            <!-- Submitted files will be dynamically populated here -->
          </div>
        </div>
        
        <!-- Add a section to display server uploads -->
        <div class="panel-section">
          <div class="section-title">Server Uploads</div>
          <div id="serverUploads" class="server-uploads">
            <!-- Uploads will be dynamically populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>
  <script src="/socket.io/socket.io.js"></script>
  <script>
    // --- Configuration ---
    const apiBaseUrl = '/api';
    let currentClassId = null;
    let authToken = localStorage.getItem('token');
    
    // --- WebRTC Variables ---
    let localStream = null;
    let socket = null;
    let peerConnections = new Map();
    let isLiveMode = false;
    let isStreaming = false;
    let streamingMode = 'file'; // 'file' or 'webrtc'
    
    // --- Load classes on page load ---
    async function loadClasses() {
      try {
        if (!authToken) {
          console.warn('No auth token found');
          return;
        }
        
        const response = await fetch(`${apiBaseUrl}/classes`, {
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (response.ok) {
          const classes = await response.json();
          const classSelect = document.getElementById('classSelect');
          
          // Clear existing options except the first one
          while (classSelect.children.length > 1) {
            classSelect.removeChild(classSelect.lastChild);
          }
          
          // Add classes to dropdown
          classes.forEach(cls => {
            const option = document.createElement('option');
            option.value = cls._id;
            option.textContent = cls.name;
            classSelect.appendChild(option);
          });
        }
      } catch (error) {
        console.error('Error loading classes:', error);
      }
    }
    
    // --- Class select, dynamic labels ---
    const classSelect = document.getElementById('classSelect');
    const classLabel = document.getElementById('classLabel');
    classSelect.addEventListener('change', () => {
      currentClassId = classSelect.value;
      classLabel.textContent = classSelect.options[classSelect.selectedIndex].text;
      
      // If WebRTC socket is connected and we're in live mode, join the new class room
      if (socket && isLiveMode && currentClassId) {
        socket.emit('instructor-join-class', { classId: currentClassId });
        console.log('🏫 Joined WebRTC class room:', currentClassId);
      }
    });

    // --- Video Preview controls (stub/demo for now) ---
    const goLiveBtn = document.getElementById('goLiveBtn');
    const stopBtn = document.getElementById('stopBtn');
    const streamStatus = document.getElementById('streamStatus');
    let liveState = 'offline'; // 'offline' | 'live'
    async function setStatus(status) {
      liveState = status;
      streamStatus.className = 'status-badge status-' + status;
      streamStatus.textContent = status === 'live' ? 'LIVE' : 'OFFLINE';
      document.getElementById('streamStatusInfo').textContent = status === 'live' ? 'Live' : 'Offline';
      goLiveBtn.disabled = (status === 'live');
      stopBtn.disabled = (status === 'offline');

      try {
        if (!currentClassId) {
          alert('Please select a class first before going live.');
          return;
        }
        
        if (!authToken) {
          alert('Please login first.');
          return;
        }
        
        if (currentClassId && authToken) {
          const endpoint = status === 'live' ? 'start' : status === 'paused' ? 'pause' : 'stop';
          
          // Determine the source type
          let source = 'live';
          let requestBody = { source };
          
          // If we have an uploaded video and we're going live, use that
          if (status === 'live' && window.currentUploadedVideo) {
            source = 'upload';
            requestBody = { 
              source,
              streamUrl: window.currentUploadedVideo.url,
              filename: window.currentUploadedVideo.filename,
              originalName: window.currentUploadedVideo.originalName
            };
          }
          // If we only have a local video, warn user to upload first
          else if (status === 'live' && window.currentLocalVideo && !window.currentUploadedVideo) {
            alert('Please upload your video to the server first before going live. Click the "Upload to Server" button.');
            return;
          }
          
          console.log(`🎥 ${status.toUpperCase()} stream for class:`, currentClassId, 'with data:', requestBody);
          
          const response = await fetch(`${apiBaseUrl}/streams/${endpoint}/${currentClassId}`, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify(requestBody)
          });
          
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `Failed to ${endpoint} stream`);
          }
          
          const result = await response.json();
          console.log(`✅ Stream ${endpoint} successful:`, result);
          
          // Push stream URL to SMXStream.html when going live
          if (status === 'live') {
            let streamUrl = null;
            let streamType = 'live';
            
            if (window.currentUploadedVideo) {
              streamUrl = window.currentUploadedVideo.url;
              streamType = 'upload';
            } else if (window.currentLocalVideo) {
              streamUrl = window.currentLocalVideo.url;
              streamType = 'local';
            } else if (result.streamUrl) {
              streamUrl = result.streamUrl;
              streamType = 'live';
            }
            
            if (streamUrl) {
              // Store stream info for SMXStream.html
              localStorage.setItem('currentStreamUrl', streamUrl);
              localStorage.setItem('currentStreamType', streamType);
              localStorage.setItem('currentStreamClass', currentClassId);
              localStorage.setItem('streamStartTime', new Date().toISOString());
              
              console.log('🎯 Stream URL pushed to SMXStream:', streamUrl, 'Type:', streamType);
              
              // Optionally open SMXStream-new.html in a new tab
              if (confirm('Stream is now live! Would you like to open the viewer in a new tab?')) {
                window.open(`/SMXStream-new.html?classId=${currentClassId}`, '_blank');
              }
            }
          } else if (status === 'offline') {
            // Clear stream info when stopping
            localStorage.removeItem('currentStreamUrl');
            localStorage.removeItem('currentStreamType');
            localStorage.removeItem('currentStreamClass');
            localStorage.removeItem('streamStartTime');
          }
          
          // Control video playback based on status
          if (window.currentUploadedVideo || window.currentLocalVideo) {
            const previewVideo = document.getElementById('previewVideo');
            const videoOverlay = document.getElementById('videoOverlay');
            
            if (status === 'live') {
              // Start playing the video when going live
              if (previewVideo && previewVideo.src) {
                previewVideo.play().catch(e => console.log('Video autoplay prevented:', e));
                videoOverlay.style.display = 'none';
              }
            } else if (status === 'paused') {
              // Pause the video
              if (previewVideo && !previewVideo.paused) {
                previewVideo.pause();
                videoOverlay.style.display = 'flex';
              }
            } else if (status === 'offline') {
              // Stop the video and reset
              if (previewVideo) {
                previewVideo.pause();
                previewVideo.currentTime = 0;
                videoOverlay.style.display = 'flex';
              }
            }
          }
        }
      } catch (error) {
        console.error('Error updating stream status:', error);
        alert(`Error ${status === 'live' ? 'starting' : status === 'paused' ? 'pausing' : 'stopping'} stream: ${error.message}`);
        
        // Reset UI state on error
        liveState = 'offline';
        streamStatus.className = 'status-badge status-offline';
        streamStatus.textContent = 'OFFLINE';
        document.getElementById('streamStatusInfo').textContent = 'Offline';
        goLiveBtn.disabled = false;
        stopBtn.disabled = true;
      }
    }
    goLiveBtn.onclick = () => setStatus('live');
    stopBtn.onclick = () => setStatus('offline');
    setStatus('offline');
    
    // ===== NATIVE VIDEO EVENT HANDLING FOR LIVE STREAMING =====
    const previewVideo = document.getElementById('previewVideo');
    let lastPlayState = false;
    
    function setupVideoEventHandlers() {
      if (!previewVideo) return;
      
      // Play event - broadcast to all students
      previewVideo.addEventListener('play', () => {
        console.log('📹 Video play event - broadcasting to students');
        if (socket && currentClassId) {
          socket.emit('stream:play', {
            time: previewVideo.currentTime,
            timestamp: new Date().toISOString()
          });
        }
      });
      
      // Pause event - broadcast to all students
      previewVideo.addEventListener('pause', () => {
        console.log('⏸️ Video pause event - broadcasting to students');
        if (socket && currentClassId) {
          socket.emit('stream:pause', {
            time: previewVideo.currentTime,
            timestamp: new Date().toISOString()
          });
        }
      });
      
      // Seek event - broadcast to all students
      previewVideo.addEventListener('seeked', () => {
        console.log('⏭️ Video seek event - broadcasting to students');
        if (socket && currentClassId) {
          socket.emit('stream:seek', {
            time: previewVideo.currentTime,
            timestamp: new Date().toISOString()
          });
        }
      });
      
      // Time update - throttled broadcast (every 500ms) - SERVER-SIDE THROTTLED
      let lastTimeUpdate = 0;
      previewVideo.addEventListener('timeupdate', () => {
        const now = Date.now();
        if (now - lastTimeUpdate > 100) { // Send every 100ms, server will throttle to 500ms
          if (socket && currentClassId) {
            socket.emit('stream:time', {
              time: previewVideo.currentTime,
              playing: !previewVideo.paused,
              timestamp: new Date().toISOString()
            });
          }
          lastTimeUpdate = now;
        }
      });
      
      console.log('✅ Video event handlers set up for live streaming');
    }



    // --- File drop (Instant Stream) demo ---
    const fileDrop = document.getElementById('fileDrop');
    const fileInput = document.getElementById('fileInput');
    const fileBrowse = document.getElementById('fileBrowse');
    const uploadStatus = document.getElementById('uploadStatus');
    const progressFill = document.getElementById('progressFill');
    const fileInfo = document.getElementById('fileInfo');
    const fileInfoTitle = document.getElementById('fileInfoTitle');
    const fileInfoDetails = document.getElementById('fileInfoDetails');
    
    function showFileInfo(file) {
      const sizeGB = (file.size / 1024 / 1024 / 1024).toFixed(2);
      const sizeMB = (file.size / 1024 / 1024).toFixed(1);
      const displaySize = file.size > 1024 * 1024 * 1024 ? sizeGB + 'GB' : sizeMB + 'MB';
      
      fileInfoTitle.textContent = file.name;
      fileInfoDetails.textContent = `Size: ${displaySize} • Type: MP4 Video • Loaded in player`;
      fileInfo.classList.add('show');
      
      // Show upload button and drag hint
      document.getElementById('uploadBtn').style.display = 'block';
      document.getElementById('dragHint').style.display = 'block';
      
      uploadStatus.textContent = 'File loaded in player for preview';
      uploadStatus.className = 'upload-status info';
      progressFill.style.width = '0';
      
      // Load the file into the video player for immediate preview
      loadFileIntoPlayer(file);
      
      // Make file info draggable
      setupFileDragAndDrop(file);
      
      // Automatically add file to submitted files list for easier access
      const fileData = {
        name: file.name,
        url: URL.createObjectURL(file),
        size: file.size,
        type: file.type,
        originalFile: file,
        uploaded: false
      };
      
      console.log('📁 Auto-adding file to submitted files:', fileData.name);
      addSubmittedFile(fileData);
    }
    
    function loadFileIntoPlayer(file) {
      if (!file || !file.type.startsWith('video/')) {
        console.warn('Invalid file type for video preview');
        return;
      }
      
      const previewVideo = document.getElementById('previewVideo');
      const placeholder = document.querySelector('.video-preview .placeholder');
      const videoReady = document.getElementById('videoReady');
      
      // Create a local URL for the file
      const fileURL = URL.createObjectURL(file);
      
      // Load the video
      previewVideo.src = fileURL;
      previewVideo.style.display = 'block';
      placeholder.style.display = 'none';
      videoOverlay.style.display = 'flex';
      videoReady.style.display = 'block';
      videoReady.textContent = '⚠️ Upload Required';
      
      // Store the local file info
      window.currentLocalVideo = {
        file: file,
        url: fileURL,
        name: file.name
      };
      
      uploadStatus.textContent = `"${file.name}" loaded in player! You can preview it now or upload to stream.`;
      uploadStatus.className = 'upload-status success';
      
      // Add visual indicator to file drop area
      document.getElementById('fileDrop').classList.add('has-file');
      document.getElementById('dragInstruction').style.display = 'block';
      
      // Clean up the previous URL if it exists
      if (window.previousVideoURL) {
        URL.revokeObjectURL(window.previousVideoURL);
      }
      window.previousVideoURL = fileURL;
    }
    
    // Setup drag and drop from file info to video player
    function setupFileDragAndDrop(file) {
      const fileInfo = document.getElementById('fileInfo');
      const fileDrop = document.getElementById('fileDrop');
      const videoPreview = document.getElementById('videoPreview');
      
      // Make file info draggable
      fileInfo.draggable = true;
      
      // Also make the file drop area draggable when it has a file
      fileDrop.draggable = true;
      
      fileInfo.addEventListener('dragstart', (e) => {
        fileInfo.classList.add('dragging');
        e.dataTransfer.setData('text/plain', 'video-file');
        e.dataTransfer.effectAllowed = 'move';
        
        // Store file reference for drop handler
        window.draggedFile = file;
      });
      
      fileInfo.addEventListener('dragend', (e) => {
        fileInfo.classList.remove('dragging');
      });
      
      // Add drag handlers for file drop area too
      fileDrop.addEventListener('dragstart', (e) => {
        if (window.currentLocalVideo) {
          fileDrop.classList.add('dragging');
          e.dataTransfer.setData('text/plain', 'video-file');
          e.dataTransfer.effectAllowed = 'move';
          window.draggedFile = window.currentLocalVideo.file;
        } else {
          e.preventDefault(); // Don't allow dragging if no file
        }
      });
      
      fileDrop.addEventListener('dragend', (e) => {
        fileDrop.classList.remove('dragging');
      });
      
      // Setup video player as drop target
      videoPreview.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        videoPreview.classList.add('drop-target');
      });
      
      videoPreview.addEventListener('dragleave', (e) => {
        // Only remove if we're actually leaving the video preview area
        if (!videoPreview.contains(e.relatedTarget)) {
          videoPreview.classList.remove('drop-target');
        }
      });
      
      videoPreview.addEventListener('drop', (e) => {
        e.preventDefault();
        videoPreview.classList.remove('drop-target');
        
        if (window.draggedFile && e.dataTransfer.getData('text/plain') === 'video-file') {
          // Load the dragged file into the video player
          loadFileIntoPlayer(window.draggedFile);
          
          // Show success feedback
          const uploadStatus = document.getElementById('uploadStatus');
          uploadStatus.textContent = `"${window.draggedFile.name}" loaded into player!`;
          uploadStatus.className = 'upload-status success';
          
          // Clear after 3 seconds
          setTimeout(() => {
            uploadStatus.textContent = '';
            uploadStatus.className = 'upload-status';
          }, 3000);
          
          window.draggedFile = null;
        }
      });
    }
    
    function hideFileInfo() {
      fileInfo.classList.remove('show');
    }
    
    fileDrop.addEventListener('click', () => fileInput.click());
    fileBrowse.addEventListener('click', e => { e.stopPropagation(); fileInput.click(); });
    fileDrop.addEventListener('dragover', e => { e.preventDefault(); fileDrop.classList.add('dragover'); });
    fileDrop.addEventListener('dragleave', e => fileDrop.classList.remove('dragover'));
    fileDrop.addEventListener('drop', e => {
      e.preventDefault();
      fileDrop.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file) {
        showFileInfo(file);
        // Don't auto-upload, just load for preview
        // User can manually upload later if needed
      }
    });
    fileInput.addEventListener('change', e => {
      const file = fileInput.files[0];
      if (file) {
        showFileInfo(file);
        // Don't auto-upload, just load for preview
        // User can manually upload later if needed
      }
    });
    
    // Upload button handler
    document.getElementById('uploadBtn').addEventListener('click', () => {
      if (window.currentLocalVideo && window.currentLocalVideo.file) {
        handleFileUpload(window.currentLocalVideo.file);
      }
    });
    async function handleFileUpload(file) {
      if (!file || !file.name.endsWith('.mp4')) {
        uploadStatus.textContent = 'Please select an MP4 file only';
        uploadStatus.className = 'upload-status error';
        hideFileInfo();
        return;
      }
      
      // Check file size (4GB limit)
      const maxSize = 4 * 1024 * 1024 * 1024; // 4GB
      if (file.size > maxSize) {
        const currentSizeGB = (file.size / 1024 / 1024 / 1024).toFixed(2);
        uploadStatus.textContent = `File too large: ${currentSizeGB}GB (max 4GB)`;
        uploadStatus.className = 'upload-status error';
        hideFileInfo();
        return;
      }
      
      if (!currentClassId) {
        uploadStatus.textContent = 'Please select a class first';
        uploadStatus.className = 'upload-status error';
        return;
      }
      
      if (!authToken) {
        uploadStatus.textContent = 'Authentication required. Please login.';
        uploadStatus.className = 'upload-status error';
        return;
      }

      uploadStatus.textContent = `Uploading "${file.name}"...`;
      uploadStatus.className = 'upload-status info';
      progressFill.style.width = '25%';

      const formData = new FormData();
      formData.append('video', file);
      formData.append('classId', currentClassId);

      try {
        const response = await fetch(`${apiBaseUrl}/stream/upload`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authToken}`
          },
          body: formData
        });

        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Failed to upload file');
        }

        const result = await response.json();
        progressFill.style.width = '100%';
        uploadStatus.textContent = `Video uploaded successfully! Ready to stream.`;
        uploadStatus.className = 'upload-status success';
        
        // Hide upload button since file is now uploaded
        document.getElementById('uploadBtn').style.display = 'none';
        
        // Update file info
        fileInfoDetails.textContent = fileInfoDetails.textContent.replace('Loaded in player', 'Uploaded to server');
        
        // Load the uploaded video into the preview (replace local version)
        const previewVideo = document.getElementById('previewVideo');
        const placeholder = document.querySelector('.video-preview .placeholder');
        const videoReady = document.getElementById('videoReady');
        
        if (result.streamUrl) {
          // Clean up local video URL
          if (window.currentLocalVideo && window.currentLocalVideo.url) {
            URL.revokeObjectURL(window.currentLocalVideo.url);
          }
          
          previewVideo.src = result.streamUrl;
          previewVideo.style.display = 'block';
          placeholder.style.display = 'none';
          videoOverlay.style.display = 'flex';
          videoReady.style.display = 'block';
          videoReady.textContent = '✅ Ready to Stream';
          
          // Store the stream info for when user clicks "Go Live"
          window.currentUploadedVideo = {
            url: result.streamUrl,
            filename: result.filename,
            originalName: file.name
          };
          
          // Update the submitted files list with the uploaded video URL
          const files = loadSubmittedFiles();
          const existingFileIndex = files.findIndex(f => f.name === file.name);
          if (existingFileIndex !== -1) {
            // Update existing file with server URL
            files[existingFileIndex].url = result.streamUrl;
            files[existingFileIndex].uploaded = true;
            files[existingFileIndex].serverFilename = result.filename;
            saveSubmittedFiles(files);
            displaySubmittedFiles(files);
          }
          
          // Clear local video reference
          window.currentLocalVideo = null;
          
          uploadStatus.textContent = `"${file.name}" ready to stream! Click "Go Live" to broadcast.`;
        }

        // Clear status after 8 seconds but keep file info visible
        setTimeout(() => {
          uploadStatus.textContent = '';
          uploadStatus.className = 'upload-status';
          progressFill.style.width = '0';
          // Don't hide file info - keep it visible for user reference
        }, 8000);
      } catch (error) {
        console.error('Error uploading file:', error);
        uploadStatus.textContent = `Upload failed: ${error.message}`;
        uploadStatus.className = 'upload-status error';
        progressFill.style.width = '0';
        
        // Clear error after 5 seconds
        setTimeout(() => {
          uploadStatus.textContent = '';
          uploadStatus.className = 'upload-status';
        }, 5000);
      }
    }



    // --- Viewer count ---
    setInterval(async () => {
      try {
        if (currentClassId && authToken) {
          const response = await fetch(`${apiBaseUrl}/stream/viewers/${currentClassId}`, {
            headers: {
              'Authorization': `Bearer ${authToken}`
            }
          });
          if (response.ok) {
            const data = await response.json();
            document.getElementById('viewerCount').textContent = data.count || 0;
            document.getElementById('viewerCountInfo').textContent = data.count || 0;
          }
        }
      } catch (error) {
        console.error('Error fetching viewer count:', error);
      }
    }, 1800);

    // --- WebRTC Functions ---
    function switchToFileMode() {
      isLiveMode = false;
      streamingMode = 'file';
      
      document.getElementById('fileTab').classList.add('active');
      document.getElementById('liveTab').classList.remove('active');
      
      document.getElementById('liveVideo').style.display = 'none';
      // Hide live control buttons
      document.getElementById('startCameraBtn').style.display = 'none';
      document.getElementById('startScreenBtn').style.display = 'none';
      document.getElementById('stopMediaBtn').style.display = 'none';
      
      // Show file preview if a file is loaded, otherwise show placeholder
      const previewVideo = document.getElementById('previewVideo');
      const placeholder = document.querySelector('.video-preview .placeholder');
      
      if (window.currentLocalVideo && window.currentLocalVideo.url) {
        previewVideo.style.display = 'block';
        placeholder.style.display = 'none';
      } else {
        previewVideo.style.display = 'none';
        placeholder.style.display = 'flex';
      }
      
      // Stop any live stream
      if (localStream) {
        stopLiveMedia();
      }
      
      console.log('🔄 Switched to file upload mode');
    }
    
    function switchToLiveMode() {
      isLiveMode = true;
      streamingMode = 'webrtc';
      
      document.getElementById('liveTab').classList.add('active');
      document.getElementById('fileTab').classList.remove('active');
      
      document.getElementById('previewVideo').style.display = 'none';
      document.getElementById('liveVideo').style.display = 'block';
      // Show live control buttons
      document.getElementById('startCameraBtn').style.display = 'inline-block';
      document.getElementById('startScreenBtn').style.display = 'inline-block';
      
      // Initialize Socket.IO for WebRTC
      if (!socket) {
        initializeWebRTCSocket();
      }
      
      console.log('🔄 Switched to live streaming mode');
    }
    
    function initializeWebRTCSocket() {
      socket = io();
      
      socket.on('connect', () => {
        console.log('🔌 WebRTC Socket connected');
        if (currentClassId) {
          socket.emit('instructor-join-class', { classId: currentClassId });
          // Join streaming room for real-time sync
          socket.emit('join-stream', { classId: currentClassId, streamKey: currentStreamKey });
        }
      });
      
      socket.on('disconnect', () => {
        console.log('❌ WebRTC Socket disconnected');
      });
      
      socket.on('student-joined', (data) => {
        console.log('👤 Student joined:', data.studentId);
        if (isStreaming && localStream) {
          createPeerConnection(data.studentId);
        }
      });
      
      socket.on('student-left', (data) => {
        console.log('👋 Student left:', data.studentId);
        if (peerConnections.has(data.studentId)) {
          peerConnections.get(data.studentId).close();
          peerConnections.delete(data.studentId);
        }
      });
      
      socket.on('webrtc-answer', async (data) => {
        console.log('📡 Received answer from student:', data.from);
        const pc = peerConnections.get(data.from);
        if (pc) {
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        }
      });
      
      socket.on('webrtc-ice-candidate', async (data) => {
        console.log('🧊 Received ICE candidate from student:', data.from);
        const pc = peerConnections.get(data.from);
        if (pc) {
          await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
        }
      });
    }
    
    async function startCamera() {
      try {
        console.log('📹 Starting camera...');
        localStream = await navigator.mediaDevices.getUserMedia({
          video: { width: 1280, height: 720 },
          audio: true
        });
        
        document.getElementById('liveVideo').srcObject = localStream;
        document.getElementById('startCameraBtn').style.display = 'none';
        document.getElementById('startScreenBtn').style.display = 'none';
        document.getElementById('stopMediaBtn').style.display = 'inline-block';
        
        console.log('✅ Camera started successfully');
        
        // Notify students that WebRTC streaming has started
        if (socket && currentClassId) {
          socket.emit('instructor-started-webrtc', { 
            classId: currentClassId,
            mediaType: 'Camera'
          });
          console.log('📡 Notified students: WebRTC Camera streaming started');
        }
      } catch (error) {
        console.error('❌ Camera error:', error);
        alert('Failed to access camera. Please check permissions.');
      }
    }
    
    async function startScreen() {
      try {
        console.log('🖥️ Starting screen share...');
        localStream = await navigator.mediaDevices.getDisplayMedia({
          video: { width: 1920, height: 1080 },
          audio: true
        });
        
        document.getElementById('liveVideo').srcObject = localStream;
        document.getElementById('startCameraBtn').style.display = 'none';
        document.getElementById('startScreenBtn').style.display = 'none';
        document.getElementById('stopMediaBtn').style.display = 'inline-block';
        
        // Handle screen share end
        localStream.getVideoTracks()[0].addEventListener('ended', () => {
          console.log('🖥️ Screen share ended by user');
          stopLiveMedia();
        });
        
        console.log('✅ Screen share started successfully');
        
        // Notify students that WebRTC streaming has started
        if (socket && currentClassId) {
          socket.emit('instructor-started-webrtc', { 
            classId: currentClassId,
            mediaType: 'Screen Share'
          });
          console.log('📡 Notified students: WebRTC Screen Share streaming started');
        }
      } catch (error) {
        console.error('❌ Screen share error:', error);
        alert('Failed to start screen share. Please check permissions.');
      }
    }
    
    function stopLiveMedia() {
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        document.getElementById('liveVideo').srcObject = null;
        
        document.getElementById('startCameraBtn').style.display = 'inline-block';
        document.getElementById('startScreenBtn').style.display = 'inline-block';
        document.getElementById('stopMediaBtn').style.display = 'none';
        
        if (isStreaming) {
          stopLiveStream();
        }
        
        console.log('⏹️ Live media stopped');
        
        // Notify students that WebRTC streaming has stopped
        if (socket && currentClassId) {
          socket.emit('instructor-stopped-webrtc', { 
            classId: currentClassId
          });
          console.log('📡 Notified students: WebRTC streaming stopped');
        }
      }
    }
    
    async function startLiveStream() {
      if (!currentClassId) {
        alert('Please select a class first');
        return;
      }
      
      if (!localStream) {
        alert('Please start camera or screen share first');
        return;
      }
      
      try {
        console.log('🔴 Starting WebRTC live stream...');
        isStreaming = true;
        
        // Update UI
        document.getElementById('streamStatus').textContent = 'LIVE';
        document.getElementById('streamStatus').className = 'status-badge status-live';
        document.getElementById('streamStatusInfo').textContent = 'Live (WebRTC)';
        
        // Notify server and students
        socket.emit('instructor-start-webrtc', { 
          classId: currentClassId,
          mediaType: localStream.getVideoTracks()[0].label.includes('screen') ? 'Screen Share' : 'Camera'
        });
        
        console.log('✅ WebRTC live stream started');
      } catch (error) {
        console.error('❌ WebRTC stream start error:', error);
        isStreaming = false;
        document.getElementById('streamStatus').textContent = 'ERROR';
        document.getElementById('streamStatus').className = 'status-badge status-offline';
      }
    }
    
    function stopLiveStream() {
      console.log('⏹️ Stopping WebRTC live stream...');
      isStreaming = false;
      
      // Update UI
      document.getElementById('streamStatus').textContent = 'OFFLINE';
      document.getElementById('streamStatus').className = 'status-badge status-offline';
      document.getElementById('streamStatusInfo').textContent = 'Offline';
      
      // Close all peer connections
      peerConnections.forEach((pc, studentId) => {
        pc.close();
      });
      peerConnections.clear();
      
      // Notify server and students
      if (currentClassId && socket) {
        socket.emit('instructor-stop-webrtc', { classId: currentClassId });
      }
      
      console.log('✅ WebRTC live stream stopped');
    }
    
    async function createPeerConnection(studentId) {
      console.log('🔗 Creating peer connection for student:', studentId);
      
      const pc = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      });
      
      // Add local stream to peer connection
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
      }
      
      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-ice-candidate', {
            to: studentId,
            candidate: event.candidate
          });
        }
      };
      
      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        console.log(`🔗 Connection state with ${studentId}: ${pc.connectionState}`);
      };
      
      peerConnections.set(studentId, pc);
      
      // Create and send offer
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        
        socket.emit('webrtc-offer', {
          to: studentId,
          offer: offer
        });
        
        console.log(`📤 Sent offer to student: ${studentId}`);
      } catch (error) {
        console.error(`❌ Error creating offer for ${studentId}:`, error);
      }
    }
    
    // ===== STREAMING SYNCHRONIZATION FUNCTIONS =====
    let currentStreamKey = null;
    let streamSyncInterval = null;
    let lastTimeUpdate = 0;
    
    function initializeStreamSync() {
      if (!socket || !currentClassId) return;
      
      // Use consistent class-based stream key
      currentStreamKey = `class_${currentClassId}`;
      
      // Join streaming room
      socket.emit('join-stream', { classId: currentClassId, streamKey: currentStreamKey });
    }
    
    // ===== STREAMING SOCKET INITIALIZATION =====
    function initializeStreamingSocket() {
      if (!currentClassId) {
        console.log('❌ No class selected for streaming');
        return;
      }
      
      if (!socket) {
        socket = io();
        console.log('🔌 Initializing streaming socket');
      }
      
      socket.on('connect', () => {
        console.log('✅ Streaming socket connected');
        
        // Join the class streaming room (instructor)
        socket.emit('instructor-join-class', { classId: currentClassId });
        
        console.log(`🏫 Instructor joined class streaming room: ${currentClassId}`);
      });
      
      socket.on('disconnect', () => {
        console.log('❌ Streaming socket disconnected');
      });
      
      // If already connected, join immediately
      if (socket.connected) {
        socket.emit('instructor-join-class', { classId: currentClassId });
        console.log(`🏫 Instructor joined class streaming room: ${currentClassId}`);
      }
    }
    
    function startStreamSync(videoElement) {
      if (streamSyncInterval) clearInterval(streamSyncInterval);
      
      // Throttled time updates (every 500ms)
      streamSyncInterval = setInterval(() => {
        if (!videoElement || !socket) return;
        
        const currentTime = videoElement.currentTime;
        const isPlaying = !videoElement.paused;
        
        // Only send if time changed significantly or play state changed
        if (Math.abs(currentTime - lastTimeUpdate) > 0.5 || isPlaying !== lastPlayState) {
          socket.emit('stream:time', {
            time: currentTime,
            playing: isPlaying,
            timestamp: new Date().toISOString()
          });
          
          lastTimeUpdate = currentTime;
          lastPlayState = isPlaying;
        }
      }, 500);
      
      // Send initial stream state
      socket.emit('stream:init', {
        streamUrl: videoElement.src,
        startTime: new Date().toISOString(),
        currentTime: videoElement.currentTime,
        playing: !videoElement.paused
      });
      
      // Listen for video events and broadcast them
      videoElement.addEventListener('play', () => {
        socket.emit('stream:play', {
          time: videoElement.currentTime,
          timestamp: new Date().toISOString()
        });
      });
      
      videoElement.addEventListener('pause', () => {
        socket.emit('stream:pause', {
          time: videoElement.currentTime,
          timestamp: new Date().toISOString()
        });
      });
      
      videoElement.addEventListener('seeked', () => {
        socket.emit('stream:seek', {
          time: videoElement.currentTime,
          timestamp: new Date().toISOString()
        });
      });
    }
    
    function stopStreamSync() {
      if (streamSyncInterval) {
        clearInterval(streamSyncInterval);
        streamSyncInterval = null;
      }
    }
    
    // ===== ENHANCED STREAMING FUNCTIONS =====
    async function enhancedToggleStream() {
      const statusElement = document.getElementById('streamStatus');
      const currentStatus = statusElement.textContent;
      
      if (currentStatus === 'OFFLINE') {
        // Start streaming
        const previewVideo = document.getElementById('previewVideo');
        
        if (!window.currentUploadedVideo && !window.currentLocalVideo) {
          alert('Please upload a video file first before going live.');
          return;
        }
        
        try {
          // Initialize stream sync
          initializeStreamSync();
          
          // Start the stream
          await toggleStream();
          
          // Set up video event handlers for live streaming
          setupVideoEventHandlers();
          
          // Initialize streaming socket and join room
          initializeStreamingSocket();
          
          // Start synchronization if we have a video
          if (previewVideo && previewVideo.src) {
            startStreamSync(previewVideo);
          }
          
        } catch (error) {
          console.error('Failed to start enhanced stream:', error);
        }
        
      } else {
        // Stop streaming
        stopStreamSync();
        await toggleStream();
      }
    }

    // --- Event Listeners for WebRTC ---
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('startCameraBtn').addEventListener('click', startCamera);
      document.getElementById('startScreenBtn').addEventListener('click', startScreen);
      document.getElementById('stopMediaBtn').addEventListener('click', stopLiveMedia);
      
      // Modify existing Go Live button to handle both modes
      const goLiveBtn = document.getElementById('goLiveBtn');
      const originalGoLive = goLiveBtn.onclick;
      
      goLiveBtn.onclick = function() {
        if (streamingMode === 'webrtc') {
          startLiveStream();
        } else {
          // Call original file-based streaming function
          if (originalGoLive) originalGoLive();
        }
      };
      
      // Modify existing Stop button to handle both modes
      const stopBtn = document.getElementById('stopBtn');
      const originalStop = stopBtn.onclick;
      
      stopBtn.onclick = function() {
        if (streamingMode === 'webrtc') {
          stopLiveStream();
        } else {
          // Call original file-based stop function
          if (originalStop) originalStop();
        }
      };
    });

    // --- Initialize page ---
    document.addEventListener('DOMContentLoaded', () => {
      loadClasses();
    });
    
    // Load classes immediately if DOM is already ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadClasses);
    } else {
      loadClasses();
    }

    // --- Server Uploads ---
    async function fetchServerUploads() {
      try {
        const response = await fetch('/api/stream/uploads');
        if (!response.ok) throw new Error('Failed to fetch uploads');

        const uploads = await response.json();
        const container = document.getElementById('serverUploads');
        container.innerHTML = uploads.map(upload => `
          <div class="upload-item">
            <span>${upload.filename}</span>
            <button onclick="deleteUpload('${upload.filename}')">Delete</button>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error fetching uploads:', error);
      }
    }

    async function deleteUpload(filename) {
      try {
        const response = await fetch(`/api/stream/uploads/${filename}`, { method: 'DELETE' });
        if (!response.ok) throw new Error('Failed to delete upload');

        alert('Upload deleted successfully');
        fetchServerUploads();
      } catch (error) {
        console.error('Error deleting upload:', error);
      }
    }

    // Fetch uploads on page load
    fetchServerUploads();

    // --- Persistent Submitted Files Management ---
    const SUBMITTED_FILES_KEY = 'smx_submitted_files';
    const LIVE_STREAM_VIDEO_KEY = 'liveStreamVideo';

    // Load submitted files from localStorage
    function loadSubmittedFiles() {
      try {
        const files = JSON.parse(localStorage.getItem(SUBMITTED_FILES_KEY) || '[]');
        console.log('📂 Loaded submitted files from localStorage:', files.length);
        displaySubmittedFiles(files);
        updateFileDropStatus(files);
        return files;
      } catch (error) {
        console.error('❌ Error loading submitted files:', error);
        return [];
      }
    }

    // Save submitted files to localStorage
    function saveSubmittedFiles(files) {
      try {
        localStorage.setItem(SUBMITTED_FILES_KEY, JSON.stringify(files));
        console.log('💾 Saved submitted files to localStorage:', files.length);
        updateFileDropStatus(files);
      } catch (error) {
        console.error('❌ Error saving submitted files:', error);
      }
    }

    // Add a new submitted file
    function addSubmittedFile(fileData) {
      const files = loadSubmittedFiles();
      
      // Check if file already exists (by name and size)
      const existingIndex = files.findIndex(f => f.name === fileData.name && f.size === fileData.size);
      if (existingIndex !== -1) {
        console.log('📝 File already exists, updating:', fileData.name);
        files[existingIndex] = {
          ...files[existingIndex],
          ...fileData,
          timestamp: new Date().toISOString()
        };
      } else {
        const newFile = {
          id: Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          name: fileData.name,
          url: fileData.url,
          size: fileData.size,
          type: fileData.type,
          timestamp: new Date().toISOString(),
          originalFile: fileData.originalFile || null,
          uploaded: fileData.uploaded || false
        };
        
        files.unshift(newFile); // Add to beginning of array (most recent first)
        console.log('🟢 File added to submitted files:', newFile.name);
      }
      
      saveSubmittedFiles(files);
      displaySubmittedFiles(files);
      return files[0];
    }

    // Delete a submitted file
    function deleteSubmittedFile(fileId) {
      const files = loadSubmittedFiles();
      const fileIndex = files.findIndex(f => f.id === fileId);
      
      if (fileIndex !== -1) {
        const deletedFile = files[fileIndex];
        files.splice(fileIndex, 1);
        saveSubmittedFiles(files);
        displaySubmittedFiles(files);
        console.log('🗑️ File deleted from submitted files:', deletedFile.name);
        
        // Clean up object URL if it exists
        if (deletedFile.url && deletedFile.url.startsWith('blob:')) {
          URL.revokeObjectURL(deletedFile.url);
        }
        
        return true;
      }
      return false;
    }

    // Display submitted files in the UI
    function displaySubmittedFiles(files) {
      const container = document.getElementById('submittedFiles');
      if (!container) return;

      if (files.length === 0) {
        container.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; padding: 12px;">No files submitted yet</div>';
        return;
      }

      container.innerHTML = files.map(file => {
        const fileSize = file.size ? formatFileSize(file.size) : 'Unknown size';
        const timestamp = new Date(file.timestamp).toLocaleString();
        const isUploaded = file.uploaded || false;
        const statusText = isUploaded ? 'Uploaded to server' : 'Local file';
        const statusColor = isUploaded ? 'var(--success)' : 'var(--text-secondary)';
        
        return `
          <div class="upload-item" data-file-id="${file.id}">
            <div style="flex: 1;">
              <div style="font-weight: 600; color: var(--text-main);">${file.name}</div>
              <div style="font-size: 0.8rem; color: var(--text-secondary);">${fileSize} • ${timestamp}</div>
              <div style="font-size: 0.75rem; color: ${statusColor}; margin-top: 2px;">📁 ${statusText}</div>
            </div>
            <div style="display: flex; gap: 8px; align-items: center;">
              <button onclick="viewSubmittedFile('${file.id}')" style="background: var(--accent); color: white; border: none; border-radius: 4px; padding: 0.3em 0.6em; font-size: 0.8rem; cursor: pointer;">👁️ View</button>
              <button onclick="streamSubmittedFile('${file.id}')" style="background: var(--success); color: white; border: none; border-radius: 4px; padding: 0.3em 0.6em; font-size: 0.8rem; cursor: pointer;">🎬 Stream</button>
              <button onclick="deleteSubmittedFile('${file.id}')" style="background: var(--error); color: white; border: none; border-radius: 4px; padding: 0.3em 0.6em; font-size: 0.8rem; cursor: pointer;">🗑️ Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }

    // View a submitted file
    function viewSubmittedFile(fileId) {
      const files = loadSubmittedFiles();
      const file = files.find(f => f.id === fileId);
      
      if (file) {
        console.log('👁️ Viewing submitted file:', file.name);
        
        // Load the file into the video player
        const previewVideo = document.getElementById('previewVideo');
        const placeholder = document.querySelector('.video-preview .placeholder');
        const videoReady = document.getElementById('videoReady');
        
        previewVideo.src = file.url;
        previewVideo.style.display = 'block';
        placeholder.style.display = 'none';
        videoOverlay.style.display = 'flex';
        videoReady.style.display = 'block';
        
        // Update current video reference based on whether it's uploaded or local
        if (file.uploaded) {
          videoReady.textContent = '✅ Ready to Stream';
          window.currentUploadedVideo = {
            url: file.url,
            filename: file.serverFilename,
            originalName: file.name
          };
          window.currentLocalVideo = null;
        } else {
          window.currentLocalVideo = {
            file: file.originalFile,
            url: file.url,
            name: file.name
          };
          window.currentUploadedVideo = null;
        }
        
        // Update upload status
        const uploadStatus = document.getElementById('uploadStatus');
        uploadStatus.textContent = `"${file.name}" loaded from submitted files`;
        uploadStatus.className = 'upload-status success';
        
        // Clear status after 3 seconds
        setTimeout(() => {
          uploadStatus.textContent = '';
          uploadStatus.className = 'upload-status';
        }, 3000);
      }
    }

    // Stream a submitted file directly
    function streamSubmittedFile(fileId) {
      const files = loadSubmittedFiles();
      const file = files.find(f => f.id === fileId);
      
      if (file) {
        console.log('🎬 Streaming submitted file:', file.name);
        
        // First load the file into the player
        viewSubmittedFile(fileId);
        
        // Then trigger the streaming
        setTimeout(() => {
          if (file.uploaded) {
            // File is already uploaded, can stream directly
            setStatus('live');
            
            // Open SMXStream-new.html in a new tab with class ID
            window.open(`/SMXStream-new.html?classId=${currentClassId}`, '_blank');
          } else {
            // File needs to be uploaded first
            alert('This file needs to be uploaded to the server first. Please click "View" to load it, then click "Upload to Server".');
          }
        }, 500);
      }
    }

    // Format file size helper
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // Update file drop area status based on submitted files
    function updateFileDropStatus(files) {
      const fileDrop = document.getElementById('fileDrop');
      const uploadStatus = document.getElementById('uploadStatus');
      
      if (!fileDrop) return;
      
      if (files.length > 0) {
        const latestFile = files[0]; // Most recent file
        const isUploaded = latestFile.uploaded || false;
        
        fileDrop.classList.add('has-file');
        
        if (!uploadStatus.textContent) { // Only update if no current status message
          uploadStatus.textContent = `${files.length} file(s) available. Latest: "${latestFile.name}" ${isUploaded ? '(uploaded)' : '(local)'}`;
          uploadStatus.className = 'upload-status info';
        }
      } else {
        fileDrop.classList.remove('has-file');
        if (!uploadStatus.textContent) {
          uploadStatus.textContent = '';
          uploadStatus.className = 'upload-status';
        }
      }
    }

    // Enhanced Go Live functionality
    function enhancedGoLive() {
      console.log('📡 Go Live triggered');
      
      // Check if we have a current video loaded (either local or uploaded)
      if (window.currentUploadedVideo) {
        console.log('🎬 Using uploaded video for live stream:', window.currentUploadedVideo.originalName);
        
        // Store the uploaded video info for the streaming page
        const videoData = {
          name: window.currentUploadedVideo.originalName,
          url: window.currentUploadedVideo.url,
          uploaded: true,
          serverFilename: window.currentUploadedVideo.filename
        };
        localStorage.setItem(LIVE_STREAM_VIDEO_KEY, JSON.stringify(videoData));
        console.log('💾 Stored uploaded video in localStorage');
        
        // Continue with original go live functionality
        setStatus('live');
        
        // Open SMXStream-new.html in a new tab with class ID
        window.open(`/SMXStream-new.html?classId=${currentClassId}`, '_blank');
        return;
      }
      
      if (window.currentLocalVideo) {
        console.log('🎬 Using local video for live stream:', window.currentLocalVideo.name);
        
        // For local videos, we need to upload them first
        alert('Please upload your video to the server first before going live. Click the "Upload to Server" button.');
        return;
      }
      
      // Fallback: Check submitted files
      const files = loadSubmittedFiles();
      if (files.length > 0) {
        const mostRecentFile = files[0]; // First item is most recent
        console.log('🎬 Using most recent submitted file for live stream:', mostRecentFile.name);
        
        if (!mostRecentFile.uploaded) {
          alert('The selected video needs to be uploaded to the server first. Please click "View" to load it, then "Upload to Server".');
          return;
        }
        
        // Store the file for the streaming page
        localStorage.setItem(LIVE_STREAM_VIDEO_KEY, JSON.stringify(mostRecentFile));
        console.log('💾 Stored live stream video in localStorage');
        
        // Continue with original go live functionality
        setStatus('live');
        
        // Open SMXStream-new.html in a new tab with class ID
        window.open(`/SMXStream-new.html?classId=${currentClassId}`, '_blank');
        return;
      }
      
      // No video available
      alert('No video available for streaming. Please upload a video first, then drag it to the video player or click "Upload to Server".');
    }

    // Enhanced file handling to add files to submitted list
    function enhancedShowFileInfo(file) {
      console.log('🔄 Enhanced file handling for:', file.name);
      
      // Call original showFileInfo
      showFileInfo(file);
      
      // Add file to submitted files list
      const fileData = {
        name: file.name,
        url: URL.createObjectURL(file),
        size: file.size,
        type: file.type,
        originalFile: file
      };
      
      console.log('📁 Adding file to submitted files:', fileData.name);
      addSubmittedFile(fileData);
    }

    // Make functions globally accessible
    window.deleteSubmittedFile = deleteSubmittedFile;
    window.viewSubmittedFile = viewSubmittedFile;
    window.streamSubmittedFile = streamSubmittedFile;

    // Initialize on page load
    document.addEventListener('DOMContentLoaded', () => {
      // Override the original Go Live button
      const goLiveBtn = document.getElementById('goLiveBtn');
      if (goLiveBtn) {
        // Store original onclick handler
        const originalOnClick = goLiveBtn.onclick;
        
        // Replace with enhanced functionality
        goLiveBtn.onclick = function() {
          if (streamingMode === 'webrtc') {
            // Use original WebRTC functionality
            startLiveStream();
          } else {
            // Use enhanced file-based functionality
            enhancedGoLive();
          }
        };
      }

      // Override file input handlers to use enhanced functionality
      const fileDrop = document.getElementById('fileDrop');
      const fileInput = document.getElementById('fileInput');
      
      if (fileDrop) {
        // Remove existing event listeners by cloning the element
        const newFileDrop = fileDrop.cloneNode(true);
        fileDrop.parentNode.replaceChild(newFileDrop, fileDrop);
        
        // Add enhanced event listeners
        newFileDrop.addEventListener('click', () => fileInput.click());
        newFileDrop.addEventListener('dragover', e => { 
          e.preventDefault(); 
          newFileDrop.classList.add('dragover'); 
        });
        newFileDrop.addEventListener('dragleave', e => newFileDrop.classList.remove('dragover'));
        newFileDrop.addEventListener('drop', e => {
          e.preventDefault();
          newFileDrop.classList.remove('dragover');
          const file = e.dataTransfer.files[0];
          if (file) {
            enhancedShowFileInfo(file);
          }
        });
      }
      
      if (fileInput) {
        // Remove existing event listeners by cloning the element
        const newFileInput = fileInput.cloneNode(true);
        fileInput.parentNode.replaceChild(newFileInput, fileInput);
        
        // Add enhanced event listener
        newFileInput.addEventListener('change', e => {
          const file = newFileInput.files[0];
          if (file) {
            enhancedShowFileInfo(file);
          }
        });
      }
      
      // Load submitted files on page load
      loadSubmittedFiles();
    });

    // Load submitted files immediately if DOM is already ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', loadSubmittedFiles);
    } else {
      loadSubmittedFiles();
    }
  </script>
</body>
</html>
